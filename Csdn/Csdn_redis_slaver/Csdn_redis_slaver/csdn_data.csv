webSource,source,title,author,tags,created,updated,content
CSDN,https://blog.csdn.net/sinianliushui/article/details/56479208,LTS 轻量级分布式任务调度框架(Light Task Schedule),zeegates,分布式,,2017-02-22 09:17:08,"'框架概况：''LTS是一个轻量级分布式任务调度框架，参考hadoop的部分思想。有三种角色, JobClient, JobTracker, TaskTracker。各个节点都是无状态的，可以部署多个，来实现负载均衡，实现更大的负载量, 并且框架具有很好的容错能力。 采用Zookeeper暴露节点信息，master选举。Mongo存储任务队列和任务执行日志, netty做底层通信。''JobClient : 主要负责提交任务, 和 接收任务执行反馈结果。''JobTracker : 负责接收并分配任务，任务调度。''TaskTracker: 负责执行任务，执行完反馈给JobTracker。''框架支持实时任务，也支持定时任务，同时也支持CronExpression, 有问题，请联系QQ254963746, 或加入群：109500214 一起探讨''github地址:https://github.com/qq254963746/light-task-schedule''架构图''节点组:''1. 一个节点组等同于一个集群，同一个节点组中的各个节点是对等的，外界无论连接节点组中的任务一个节点都是可以的。''2. 每个节点组中都有一个master节点，采用zookeeper进行master选举(master宕机，会自动选举出新的master节点)，框架会提供接口API来监听master节点的变化，用户可以自己使用master节点做自己想做的事情。''3. JobClient和TaskTracker都可以存在多个节点组。譬如 JobClient 可以存在多个节点组。 譬如：JobClient 节点组为 ‘lts_WEB’ 中的一个节点提交提交一个 只有节点组为’lts_TRADE’的 TaskTracker 才能执行的任务。''4. (每个集群中)JobTacker只有一个节点组。''5. 多个JobClient节点组和多个TaskTracker节点组再加上一个JobTacker节点组, 组成一个大的集群。''工作流程:''1. JobClient 提交一个 任务 给 JobTracker, 这里我提供了两种客户端API, 一种是如果JobTracker 不存在或者提交失败，直接返回提交失败。另一种客户端是重试客户端, 如果提交失败，先存储到本地leveldb(可以使用NFS来达到同个节点组共享leveldb文件的目的,多线程访问，做了文件锁处理)，返回给客户端提交成功的信息，待JobTracker可用的时候，再将任务提交。''2. JobTracker 收到JobClient提交来的任务，先生成一个唯一的JobID。然后将任务储存在Mongo集群中。JobTracker 发现有（任务执行的）可用的TaskTracker节点(组) 之后，将优先级最大，最先提交的任务分发给TaskTracker。这里JobTracker会优先分配给比较空闲的TaskTracker节点，达到负载均衡。''3. TaskTracker 收到JobTracker分发来的任务之后，执行。执行完毕之后，再反馈任务执行结果给JobTracker（成功or 失败[失败有失败错误信息]），如果发现JobTacker不可用，那么存储本地leveldb，等待TaskTracker可用的时候再反馈。反馈结果的同时，询问JobTacker有没有新的任务要执行。''4. JobTacker收到TaskTracker节点的任务结果信息，生成并插入(mongo)任务执行日志。根据任务信息决定要不要反馈给客户端。不需要反馈的直接删除, 需要反馈的（同样JobClient不可用存储文件，等待可用重发）。''5. JobClient 收到任务执行结果，进行自己想要的逻辑处理。''特性''负载均衡:''JobClient 和 TaskTracker会随机连接JobTracker节点组中的一个节点，实现JobTracker负载均衡。当连接上后，将一直保持连接这个节点,保持连接通道，知道这个节点不可用，减少每次都重新连接一个节点带来的性能开销。''JobTracker 分发任务时，是优先分配给最空闲的一个TaskTracker节点，实现TaskTracker节点的负载均衡。''健壮性:''当节点组中的一个节点当机之后，自动转到其他节点工作。当整个节点组当机之后，将会采用存储文件的方式，待节点组可用的时候进行重发。''当执行任务的TaskTracker节点当机之后，JobTracker 会将这个TaskTracker上的未完成的任务(死任务)，重新分配给节点组中其他节点执行。''伸缩性：''因为各个节点都是无状态的，可以动态增加机器部署实例, 节点关注者会自动发现。''开发计划：''WEB后台管理''框架优化''调用示例''安装 zookeeper 和 mongo , 执行 data/mongo 目录下的 mongo.md 中的语句''运行 job-example模块中的例子（包含API启动例子和Spring例子） 分别执行 JobTrackerTest TaskTrackerTest JobClientTest''这里给出的是java API(设置配置)方式启动, 也可以使用spring启动默认不启用spring，需引入job-ext-spring包''JobTracker 端''final''JobTracker jobTracker =''new''JobTracker();''// 节点信息配置''jobTracker''.setZookeeperAddress''(''""localhost:2181""'');''// jobTracker.setListenPort(35001); // 默认 35001''// jobTracker.setClusterName(""lts"");''// mongo 配置''Config''config''=''new''Config();''config''.setAddresses''(''new''String[]{''""localhost:27017""''});''config''.setUsername''(''""lts""'');''config''.setPassword''(''""lts""'');''config''.setDbName''(''""job""'');\n    jobTracker''.setStoreConfig''(''config'');''// 启动节点''jobTracker''.start''();\n\n    Runtime''.getRuntime''()''.addShutdownHook''(''new''Thread(''new''Runnable() {\n        @Override\n        public''void''run() {\n            jobTracker''.stop''();\n        }\n    }));''或者Spring配置''<''bean''id''=''""mongoConfig""''class''=''""com.lts.job.store.Config""''>''<''property''name''=''""addresses""''>''<''array''>''<''value''>''localhost:27017''</''value''>''</''array''>''</''property''>''<''property''name''=''""username""''value''=''""lts""''/>''<''property''name''=''""password""''value''=''""lts""''/>''<''property''name''=''""dbName""''value''=''""job""''/>''</''bean''>''<''bean''id''=''""jobTracker""''class''=''""com.lts.job.spring.JobTrackerFactoryBean""''init-method''=''""start""''>''<!--<property name=""clusterName"" value=""lts""/>-->''<!-- 集群名称 -->''<!--<property name=""listenPort"" value=""35001""/>-->''<!-- 默认 35001 -->''<''property''name''=''""zookeeperAddress""''value''=''""localhost:2181""''/>''<''property''name''=''""storeConfig""''ref''=''""mongoConfig""''/>''<''property''name''=''""masterNodeChangeListeners""''>''<''array''>''<''bean''class''=''""com.lts.job.example.support.MasterNodeChangeListenerImpl""''/>''</''array''>''</''property''>''</''bean''>''TaskTracker端''TaskTracker taskTracker =''new''TaskTracker();\ntaskTracker.setJobRunnerClass(TestJobRunner.class);''// jobClient.setClusterName(""lts"");''taskTracker.setZookeeperAddress(''""localhost:2181""'');\ntaskTracker.setNodeGroup(''""test_trade_TaskTracker""'');\ntaskTracker.setWorkThreads(''20'');\ntaskTracker.start();''// 任务执行类''public''class''TestJobRunner''implements''JobRunner''{''@Override''public''void''run''(Job job)''throws''Throwable''{\n\t\tSystem.out.println(''""我要执行""''+ job);\n\t\tSystem.out.println(job.getParam(''""shopId""''));''try''{\n\t\t\tThread.sleep(''5''*''1000L'');\n\t\t}''catch''(InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}''或者Spring方式配置''<''bean''id''=''""taskTracker""''class''=''""com.lts.job.spring.TaskTrackerFactoryBean""''init-method''=''""start""''>''<!--<property name=""clusterName"" value=""lts""/>-->''<''property''name''=''""nodeGroup""''value''=''""test_trade_TaskTracker""''/>''<!-- 所属节点组名称 -->''<''property''name''=''""zookeeperAddress""''value''=''""localhost:2181""''/>''<''property''name''=''""jobRunnerClass""''value''=''""com.lts.job.example.support.TestJobRunner""''/>''<!-- 任务执行类 -->''<''property''name''=''""workThreads""''value''=''""1""''/>''<!-- 工作线程个数 -->''<''property''name''=''""masterNodeChangeListeners""''>''<!-- 所属节点组中master节点变化监听器，可以不用配置 -->''<''array''>''<''bean''class''=''""com.lts.job.example.support.MasterNodeChangeListenerImpl""''/>''</''array''>''</''property''>''</''bean''>''JobClient端''JobClient jobClient = new RetryJobClient();''//''JobClient jobClient = new JobClient();\n    jobClient.setNodeGroup(''""test_JobClient""'');''//''jobClient.setClusterName(''""lts""'');\n    jobClient.setZookeeperAddress(''""localhost:2181""'');\n    jobClient.start();''//''提交任务\n    Job job = new Job();\n    job.setParam(''""shopId""'',''""11111""'');\n    job.setTaskTrackerNodeGroup(''""test_trade_TaskTracker""'');''//''job.setCronExpression(''""0 0/1 * * * ?""'');''//''支持 cronExpression表达式''//''job.setTriggerTime(new Date().getTime());''//''支持指定时间执行\n    Response response = jobClient.submitJob(job);''或者spring方式启动''<''bean''id''=''""jobClient""''class''=''""com.lts.job.spring.JobClientFactoryBean""''init-method''=''""start""''>''<''property''name''=''""clientType""''value''=''""retry""''/>''<!-- 取值: 为空（默认normal）, normal, retry  -->''<!--<property name=""clusterName"" value=""lts""/>-->''<!-- 默认 defaultCluster -->''<''property''name''=''""nodeGroup""''value''=''""test_JobClient""''/>''<!-- 节点组名称 -->''<''property''name''=''""zookeeperAddress""''value''=''""localhost:2181""''/>''<''property''name''=''""jobFinishedHandler""''>''<''bean''class''=''""com.lts.job.example.support.JobFinishedHandlerImpl""''/>''<!-- 任务完成处理器 -->''</''property''>''<''property''name''=''""masterNodeChangeListeners""''>''<!-- 所属节点组中master节点变化监听器 -->''<''array''>''<''bean''class''=''""com.lts.job.example.support.MasterNodeChangeListenerImpl""''/>''</''array''>''</''property''>''</''bean''>''//''从Spring容器中取得JobClient Bean\n    JobClient jobClient = (JobClient) applicationContext.getBean(''""jobClient""'');''//''提交任务\n    Job job = new Job();\n    job.setParam(''""shopId""'',''""11111""'');\n    job.setTaskTrackerNodeGroup(''""test_trade_TaskTracker""'');''//''job.setCronExpression(''""0 0/1 * * * ?""'');''//''支持 cronExpression表达式''//''job.setTriggerTime(new Date().getTime());''//''支持指定时间执行\n    Response response = jobClient.submitJob(job);'"
CSDN,https://blog.csdn.net/adi851270440/article/details/80512157,分布式定时任务调度平台TBSchedule技术介绍,adi851270440,分布式定时任务调度平台,,2018-05-30 16:49:06,'1. 概述''TBSchedule是阿里开发的一款分布式任务调度平台，旨在将调度作业从业务系统中分离出来，降低或者是消除和业务系统的耦合度，进行高效异步任务处理，目前被广泛应用在阿里巴巴、淘宝、支付宝、京东、聚美、汽车之家、国美等很多互联网企业的流程调度系统中。''TBSchedule调度平台关键字''TBSchedule有很多特性，包括批量任务，多主机，多线程，动态扩展，实时或定时任务，分片，并发，不重复执行。TBSchedule通过任务分片将一个大的任务拆分成多个子任务，这些子任务在多台应用服务器上不重复的并发执行，而分配给每台服务器上的任务又可以启动多个线程处理，从而大大提高执行效率；应用服务器支持动态扩容和失效转移，当任务量较大时，可以随时扩展应用服务器的个数，当有服务器宕机时，他的待执行任务将会分配给其他服务器执行；TBSchedule的任务管理可以通过管理页面进行，可以设置任务的定时的开始和结束，也可以设置任务立即执行；另外，TBSchedule可以设置应用白名单，即某个任务在哪些机器上执行。''TBSchedule依赖于ZK存储调度数据，包括注册的服务器信息，调度策略，任务分片信息，任务的分配情况等。TBSchedule启动两个心跳线程：服务器信息心跳检测线程和任务信息的心跳检测线程，通过这两个线程维护zk上的调度信息，清除没有心跳的服务器和任务，重新分配任务项，停止或恢复执行任务等。''2. 技术原理''TBSchedule运行流程图''TBSchedule会在初始化zk配置时，根据用户配置的根节点名称创建一个根节点，以后对zk所有的操作都在该根节点下进行。初始化配置中，TBSchedule会在根节点下创建三个子节点：factory、strategy、baseTaskType，这三个节点分别维护着调度服务器信息、调度策略信息和任务信息。''初始化配置完成后，TBSchedule会创建并启动两个线程：服务器信息心跳检测和任务信息的心跳检测。服务器信息心跳检测每2秒钟执行一次，主要工作包括在factory目录下创建服务器节点，并且根据调度策略的白名单将服务器分配给调度策略；然后根据调度策略配置单台服务器线程组数和总的线程组数，给每台服务器分配线程组数，线程组数即每台服务器启动的任务处理器数，每个线程组都会启动若干个线程来处理任务；最后维护任务处理器数和线程组数的平衡，如果任务处理器数超过分配的线程组数，则删除多余的任务处理器（要等任务执行完毕），否则新增任务处理器。任务信息的心跳检测的启动时间是每个任务分别配置的，它的主要工作包括，清除没有心跳的任务处理器，选举leader，并由leader处理器执行任务分配。在服务器信息心跳检测线程最后会去启动任务的执行，计算任务的开始时间，包括实时和定时执行任务，然后Timer调度器启动任务执行。任务开始执行时，每个线程组会启动多个线程执行任务，当taskList中没有数据时，其他线程等待，最后一个线程调用selectTasks方法获取数据，并唤醒其他线程调用execute方法执行任务。''TBSchedule策略和任务的创建只能通过管理页面完成，它提供了功能丰富的管理页面。当要创建一个调度任务时，首先应该给这个任务创建调度策略，创建策略如图所示。''创建调度策略''其中，单JVM最大线程组数量表示每个服务器上可以创建的任务处理器个数，最大线程组数量表示所有服务器最多创建的线程组数量，IP地址表示该任务可以在哪些机器上执行。''创建任务''创建调度策略后开始创建调度任务，包括任务实体beanId，心跳检测线程的频率，假定服务死亡间隔表示任务处理器没有心跳多长时间判定为死亡，线程数表示每个线程组执行任务时启动的线程个数，每次获取数据量表示每次查取数据的条数，处理模式分为sleep和notsleep两种，执行开始时间和执行结束时间表示定时任务的开始和结束时间，格式为cron表达式，不填标识实时任务，立即执行。任务项是任务拆分的依据，作为参数传递，以逗号分隔，表示该定时任务要拆分成几个任务项以及每个任务项的参数。''3. 总结''1）''TBSchedule功能强大''，''在很多大型互联网公司被应用，经过了充分的验证，是一款优秀的调度平台。''2）TBSchedule没有官方文档，而且开源代码在淘宝平台http://code.taobao.org/svn/tbschedule上面，不方便下载。''3）不支持jdk1.8以上（因为依赖的spring jar包较老，程序中需要通过该jar包获取版本信息，只能取到1.7以下的jdk信息）''4）TBSchedule获取的是内网IP地址（127.0.0.1或者localhost），不容易通过IP地址区分服务器。'
CSDN,https://blog.csdn.net/u012190514/article/details/84680301,怎么把Vue项目发布到Tomcat上,潇兮水寒,Vue,,2018-12-02 00:57:46,"'前言：''好久没学的Vue，最近又接着学了，好不容易使用vuecli写了一下Demo想在tomcat运行，但是''页面是空白''，打开一看，发现所有的JS全部都是404了。''我的操作顺序这样的：''1.打开终端\xa0执行 npm run build （node编译打包命令，最后生成的网页都在工程的dist文件夹下）''2.拷贝./dist文件夹的所有网页相关文件''3.进行我的Tomcat目录，创建一个文件夹(我的名称是vuecli)''4.粘贴生成的网页等文件''5.重启Tomcat（默认本地运行）''6.访问项目''http://localhost:8080/vuecli/''搜了好几个结果，最后定位到一个地方。''修改项目文件夹下 /config/index.js''网上普遍的方法：''修改：assetsPublicPath：''从 ""/""\xa0改为""./""''哇，效果是达到了。但是我觉得，我有必要搞清楚这个''打包路径''的问题。''首先，这里是想路径变为了相对路径，问题得到了解决，那么我们使用绝对路径应该怎么做呢，首先，tomcat默认的路径的是在webapp目录下，一个工程对应一个文件，正如我上文所说的,创建的vuecli文件夹，那么这就是对应了这个文件夹，那么，我如果在vue项目打包的时候，把工程名设置到打包路径下就行了。''（我的webapps目录）''（工程文件详情）''那么问题就非常简单了，在打包路径（assetsPublicPath）下不要使用''“./”''，而是去使用你在tomcat中创建的文件夹名称（即，工程名称，如上图，我的工程的名称是vuecli）''那么修改配置文件吧：./config/index.js\xa0中\xa0 搜索\xa0assetsPublicPath ，共两条记录，一条是在build里面，一条是在dev下，我们这里需要改的是build下''再次使用打包命令 npm run build''把文件部署到tomcat''重启tomcat，完事！''我们又可以看到熟悉的页面了！'"
CSDN,https://blog.csdn.net/weixin_43481793/article/details/89455448,springboot+vue打包发布到tomcat服务器详细介绍,高小胖爱胡小宝,工作总结,,2019-04-22 16:47:33,"'最近在写一个后台管理系统，后台用的是springboot，前台用的是vue+iview，打包发布到tomcat的时候遇到了不少坑，在这我有必要记录一下自己发布的过程，以便下次自己好复习。''先来看看后台代码注意的地方：''程序的启动类必须继承SpringBootServletInitializer并且覆盖其中的configure方法''@SpringBootApplication\n@MapperScan(""com.wky.dao.repository"")\npublic class AdminApplication extends SpringBootServletInitializer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AdminApplication.class, args);\n    }\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(AdminApplication.class);\n    }''接下来去看pom.xml，增加依赖屏蔽自带的tomcat''<!--屏蔽 tomcat-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n            <scope>compile</scope>\n        </dependency>''现在看看前台代码是如何配置的：''首先在config/index.js'""// Paths\n    assetsSubDirectory: 'static',\n    assetsPublicPath: './',\n`\n// Paths\n    assetsRoot: path.resolve(__dirname, '../dist'),\n    assetsSubDirectory: 'static',\n    assetsPublicPath: './',``""'这个 assetsPublicPath: ‘./’,这个点是必须要的''在bulid/utils.js中主要代码如下：'""if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader',\n       publicPath: '../../'  //服务器上没有这个就会少静态样式\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }""'可以看到增加了publicPath: ‘…/…/’，如果没有这个那么就会少了部分静态样式。''在router/index.js中注释掉 mode:‘history’,''base:__dirname,'""/* mode:'history',\n  base:__dirname,*/\n  routes: [\n    {path: '/', name: 'Login', component: Login},\n    {path: '/home', name: 'Home',component: Home,""'最后一步：在src/api/requestUrl.js中将''return (’/api’) + actionName;''修改为return (‘服务器地址/tomcat端口号/项目打包的名字’) + actionName;''比如：return (‘''http://47.100.208.63:8080/hcx-admin''’) + actionName;''运行 npm run build 命令后项目中多了一个dist文件，复制文件到桌面上，然后修改文件名字，比如我修改为hcx-vue，然后通过xftp6（我 比较喜欢这个软件，大家随意）发布到tomcat的webapps目录下''如图所示：''接下来将打包好的后台代码war包也放到这个目录，至于怎么打包不在这篇范围之内。''重新启动tomcat服务''然后我们直接请求：''http://47.100.208.63:8080/hcx-vue（ip地址是假的）'"
CSDN,https://blog.csdn.net/u012190514/article/details/84680301,怎么把Vue项目发布到Tomcat上,潇兮水寒,Vue,,2018-12-02 00:57:46,"'前言：''好久没学的Vue，最近又接着学了，好不容易使用vuecli写了一下Demo想在tomcat运行，但是''页面是空白''，打开一看，发现所有的JS全部都是404了。''我的操作顺序这样的：''1.打开终端\xa0执行 npm run build （node编译打包命令，最后生成的网页都在工程的dist文件夹下）''2.拷贝./dist文件夹的所有网页相关文件''3.进行我的Tomcat目录，创建一个文件夹(我的名称是vuecli)''4.粘贴生成的网页等文件''5.重启Tomcat（默认本地运行）''6.访问项目''http://localhost:8080/vuecli/''搜了好几个结果，最后定位到一个地方。''修改项目文件夹下 /config/index.js''网上普遍的方法：''修改：assetsPublicPath：''从 ""/""\xa0改为""./""''哇，效果是达到了。但是我觉得，我有必要搞清楚这个''打包路径''的问题。''首先，这里是想路径变为了相对路径，问题得到了解决，那么我们使用绝对路径应该怎么做呢，首先，tomcat默认的路径的是在webapp目录下，一个工程对应一个文件，正如我上文所说的,创建的vuecli文件夹，那么这就是对应了这个文件夹，那么，我如果在vue项目打包的时候，把工程名设置到打包路径下就行了。''（我的webapps目录）''（工程文件详情）''那么问题就非常简单了，在打包路径（assetsPublicPath）下不要使用''“./”''，而是去使用你在tomcat中创建的文件夹名称（即，工程名称，如上图，我的工程的名称是vuecli）''那么修改配置文件吧：./config/index.js\xa0中\xa0 搜索\xa0assetsPublicPath ，共两条记录，一条是在build里面，一条是在dev下，我们这里需要改的是build下''再次使用打包命令 npm run build''把文件部署到tomcat''重启tomcat，完事！''我们又可以看到熟悉的页面了！'"
CSDN,https://blog.csdn.net/adi851270440/article/details/80512157,分布式定时任务调度平台TBSchedule技术介绍,adi851270440,分布式定时任务调度平台,,2018-05-30 16:49:06,'1. 概述''TBSchedule是阿里开发的一款分布式任务调度平台，旨在将调度作业从业务系统中分离出来，降低或者是消除和业务系统的耦合度，进行高效异步任务处理，目前被广泛应用在阿里巴巴、淘宝、支付宝、京东、聚美、汽车之家、国美等很多互联网企业的流程调度系统中。''TBSchedule调度平台关键字''TBSchedule有很多特性，包括批量任务，多主机，多线程，动态扩展，实时或定时任务，分片，并发，不重复执行。TBSchedule通过任务分片将一个大的任务拆分成多个子任务，这些子任务在多台应用服务器上不重复的并发执行，而分配给每台服务器上的任务又可以启动多个线程处理，从而大大提高执行效率；应用服务器支持动态扩容和失效转移，当任务量较大时，可以随时扩展应用服务器的个数，当有服务器宕机时，他的待执行任务将会分配给其他服务器执行；TBSchedule的任务管理可以通过管理页面进行，可以设置任务的定时的开始和结束，也可以设置任务立即执行；另外，TBSchedule可以设置应用白名单，即某个任务在哪些机器上执行。''TBSchedule依赖于ZK存储调度数据，包括注册的服务器信息，调度策略，任务分片信息，任务的分配情况等。TBSchedule启动两个心跳线程：服务器信息心跳检测线程和任务信息的心跳检测线程，通过这两个线程维护zk上的调度信息，清除没有心跳的服务器和任务，重新分配任务项，停止或恢复执行任务等。''2. 技术原理''TBSchedule运行流程图''TBSchedule会在初始化zk配置时，根据用户配置的根节点名称创建一个根节点，以后对zk所有的操作都在该根节点下进行。初始化配置中，TBSchedule会在根节点下创建三个子节点：factory、strategy、baseTaskType，这三个节点分别维护着调度服务器信息、调度策略信息和任务信息。''初始化配置完成后，TBSchedule会创建并启动两个线程：服务器信息心跳检测和任务信息的心跳检测。服务器信息心跳检测每2秒钟执行一次，主要工作包括在factory目录下创建服务器节点，并且根据调度策略的白名单将服务器分配给调度策略；然后根据调度策略配置单台服务器线程组数和总的线程组数，给每台服务器分配线程组数，线程组数即每台服务器启动的任务处理器数，每个线程组都会启动若干个线程来处理任务；最后维护任务处理器数和线程组数的平衡，如果任务处理器数超过分配的线程组数，则删除多余的任务处理器（要等任务执行完毕），否则新增任务处理器。任务信息的心跳检测的启动时间是每个任务分别配置的，它的主要工作包括，清除没有心跳的任务处理器，选举leader，并由leader处理器执行任务分配。在服务器信息心跳检测线程最后会去启动任务的执行，计算任务的开始时间，包括实时和定时执行任务，然后Timer调度器启动任务执行。任务开始执行时，每个线程组会启动多个线程执行任务，当taskList中没有数据时，其他线程等待，最后一个线程调用selectTasks方法获取数据，并唤醒其他线程调用execute方法执行任务。''TBSchedule策略和任务的创建只能通过管理页面完成，它提供了功能丰富的管理页面。当要创建一个调度任务时，首先应该给这个任务创建调度策略，创建策略如图所示。''创建调度策略''其中，单JVM最大线程组数量表示每个服务器上可以创建的任务处理器个数，最大线程组数量表示所有服务器最多创建的线程组数量，IP地址表示该任务可以在哪些机器上执行。''创建任务''创建调度策略后开始创建调度任务，包括任务实体beanId，心跳检测线程的频率，假定服务死亡间隔表示任务处理器没有心跳多长时间判定为死亡，线程数表示每个线程组执行任务时启动的线程个数，每次获取数据量表示每次查取数据的条数，处理模式分为sleep和notsleep两种，执行开始时间和执行结束时间表示定时任务的开始和结束时间，格式为cron表达式，不填标识实时任务，立即执行。任务项是任务拆分的依据，作为参数传递，以逗号分隔，表示该定时任务要拆分成几个任务项以及每个任务项的参数。''3. 总结''1）''TBSchedule功能强大''，''在很多大型互联网公司被应用，经过了充分的验证，是一款优秀的调度平台。''2）TBSchedule没有官方文档，而且开源代码在淘宝平台http://code.taobao.org/svn/tbschedule上面，不方便下载。''3）不支持jdk1.8以上（因为依赖的spring jar包较老，程序中需要通过该jar包获取版本信息，只能取到1.7以下的jdk信息）''4）TBSchedule获取的是内网IP地址（127.0.0.1或者localhost），不容易通过IP地址区分服务器。'
CSDN,https://blog.csdn.net/weixin_43481793/article/details/89455448,springboot+vue打包发布到tomcat服务器详细介绍,高小胖爱胡小宝,工作总结,,2019-04-22 16:47:33,"'最近在写一个后台管理系统，后台用的是springboot，前台用的是vue+iview，打包发布到tomcat的时候遇到了不少坑，在这我有必要记录一下自己发布的过程，以便下次自己好复习。''先来看看后台代码注意的地方：''程序的启动类必须继承SpringBootServletInitializer并且覆盖其中的configure方法''@SpringBootApplication\n@MapperScan(""com.wky.dao.repository"")\npublic class AdminApplication extends SpringBootServletInitializer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AdminApplication.class, args);\n    }\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(AdminApplication.class);\n    }''接下来去看pom.xml，增加依赖屏蔽自带的tomcat''<!--屏蔽 tomcat-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n            <scope>compile</scope>\n        </dependency>''现在看看前台代码是如何配置的：''首先在config/index.js'""// Paths\n    assetsSubDirectory: 'static',\n    assetsPublicPath: './',\n`\n// Paths\n    assetsRoot: path.resolve(__dirname, '../dist'),\n    assetsSubDirectory: 'static',\n    assetsPublicPath: './',``""'这个 assetsPublicPath: ‘./’,这个点是必须要的''在bulid/utils.js中主要代码如下：'""if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader',\n       publicPath: '../../'  //服务器上没有这个就会少静态样式\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }""'可以看到增加了publicPath: ‘…/…/’，如果没有这个那么就会少了部分静态样式。''在router/index.js中注释掉 mode:‘history’,''base:__dirname,'""/* mode:'history',\n  base:__dirname,*/\n  routes: [\n    {path: '/', name: 'Login', component: Login},\n    {path: '/home', name: 'Home',component: Home,""'最后一步：在src/api/requestUrl.js中将''return (’/api’) + actionName;''修改为return (‘服务器地址/tomcat端口号/项目打包的名字’) + actionName;''比如：return (‘''http://47.100.208.63:8080/hcx-admin''’) + actionName;''运行 npm run build 命令后项目中多了一个dist文件，复制文件到桌面上，然后修改文件名字，比如我修改为hcx-vue，然后通过xftp6（我 比较喜欢这个软件，大家随意）发布到tomcat的webapps目录下''如图所示：''接下来将打包好的后台代码war包也放到这个目录，至于怎么打包不在这篇范围之内。''重新启动tomcat服务''然后我们直接请求：''http://47.100.208.63:8080/hcx-vue（ip地址是假的）'"
CSDN,https://blog.csdn.net/qq_41352018/article/details/79939775,利用python+opencv识别图片中的圆形（霍夫变换）,智元元,opencv,,2018-04-14 14:11:40,"'在图片中识别足球''先补充下霍夫圆变换的几个参数知识：''dp，用来检测圆心的累加器图像的分辨率于输入图像之比的倒数，且此参数允许创建一个比输入图像分辨率低的累加器。上述文字不好理解的话，来看例子吧。例如，如果dp= 1时，累加器和输入图像具有相同的分辨率。如果dp=2，累加器便有输入图像一半那么大的宽度和高度。''minDist，为霍夫变换检测到的圆的圆心之间的最小距离，即让我们的算法能明显区分的两个不同圆之间的最小距离。这个参数如果太小的话，多个相邻的圆可能被错误地检测成了一个重合的圆。反之，这个参数设置太大的话，某些圆就不能被检测出来了。''param1，有默认值100。它是method设置的检测方法的对应的参数。对当前唯一的方法霍夫梯度法，它表示传递给canny边缘检测算子的高阈值，而低阈值为高阈值的一半。''param2，也有默认值100。它是method设置的检测方法的对应的参数。对当前唯一的方法霍夫梯度法，它表示在检测阶段圆心的累加器阈值。它越小的话，就可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了。''minRadius，默认值0，表示圆半径的最小值。''maxRadius，也有默认值0，表示圆半径的最大值。''源代码：''[python]''view plain''copy''#\xa0-*-\xa0coding:\xa0utf-8\xa0-*-''""""""''Created\xa0on\xa0Tue\xa0Sep\xa026\xa023:15:39\xa02017''@author:\xa0tina''""""""''import''cv2''import''numpy\xa0as\xa0np''import''matplotlib.pyplot\xa0as\xa0plt''img\xa0=\xa0cv2.imread('""'C:\\\\Users\\\\tina\\\\Pictures\\\\ahh\\\\ball.jpg'""')''gray\xa0=\xa0cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)''plt.subplot(''121''),plt.imshow(gray,'""'gray'""')''plt.xticks([]),plt.yticks([])''circles1\xa0=\xa0cv2.HoughCircles(gray,cv2.HOUGH_GRADIENT,''1'',''600'',param1=''100'',param2=''30'',minRadius=''80'',maxRadius=''97'')''circles\xa0=\xa0circles1[''0'',:,:]''circles\xa0=\xa0np.uint16(np.around(circles))''for''i''in''circles[:]:''cv2.circle(img,(i[''0''],i[''1'']),i[''2''],(''255'',''0'',''0''),''5'')''cv2.circle(img,(i[''0''],i[''1'']),''2'',(''255'',''0'',''255''),''10'')''cv2.rectangle(img,(i[''0'']-i[''2''],i[''1'']+i[''2'']),(i[''0'']+i[''2''],i[''1'']-i[''2'']),(''255'',''255'',''0''),''5'')''print''(''""圆心坐标""'',i[''0''],i[''1''])''plt.subplot(''122''),plt.imshow(img)''plt.xticks([]),plt.yticks([])''原图：''识别后效果：'"
CSDN,https://blog.csdn.net/qq_35010227/article/details/86102084,Java中this关键字详解,雪碧~,java基础,,2019-01-08 22:15:36,"'最近几天学习了一下Java的spring框架，课程中遇到了几个关于Java的基础知识拿捏不到位，经过查阅了各类Java资料，对几个问题有了大致的理解。干脆写下来和大家分享一下，希望对大家有所帮助。''this''this表示某个对象''this可以出现在实例方法和构造方法中，但是不可以出现在类方法中''this出现在类的构造方法中，就代表该构造方法所创建的对象''this出现在实例方法中，就代表正在调用该方法的当前对象''this不能出现在类方法中，是因为类方法可以通过类名直接调用。在这个时候，可能还没有任何对象诞生。''实例方法:''实例方法只能通过对象来调用，不能用类名来调用''当实例成员变量在实例方法中出现时，默认格式为 ：''this.成员变量''当static成员变量在实例方法中出现时，默认格式为：''类.成员变量''示例如下:''class''A''{''int x'';''static''int y'';''void''f''('')''{''this''.''x''=''100'';''A''.''y''=''200'';''}''}''当一个对象调用方法时，方法中的实例成员变量就是指分配给该对象的实例成员变量。而static变量与其他对象共享。所以通常情况可以省略实例成员变量名字前边的“this”，以及static变量前的“类名”。但是''当实例成员名字和局部变量名字相同时''，成员变量前的“this”以及“类名”就不可以省略。''class''A''{''private''String name'';''public''void''f''(''String name'')''{''this''.''name''=''name'';''//this不能省略''}''}''我们知道类的实例方法可以调用类的其他方法，对于实例方法调用的默认格式是：''this.方法''class''B''{''void''f''('')''{''this''.''g''('')'';''//this可省略''B''.''h''('')'';''//B(类名)可省略''}''void''g''('')''{''System''.''out''.''print''(''""Hello""'')'';''}''static''void''h''('')''{''System''.''out''.''print''(''""World！""'')'';''}''}''以上均为个人理解，有错误的地方还请各位指正，欢迎交流~'"
CSDN,https://blog.csdn.net/wei_zhi/article/details/52765287,Java 关键字this详解,志见,Java,,2016-10-09 11:52:48,"'在整个Java中，只要是代码开发，几乎都离不开this。在Java中this可以完成三件事情：表示本类属性、表示本类方法、当前对象。''一、“this.属性”表示本类属性''讲解之前，我们先看一段代码：''package com.wz.thisdemo;\n\nclass Person {''private''String name ;''private''int''age ;''public''Person''(String n,''int''a) {\n              name = n ;\n              age = a ;\n    }''// setter、getter略''public''String''getInfo''() {''return''""姓名：""''+ name +''""，年龄：""''+ age ;\n    }\n}''public''class''TestDemo {''public''static''void''main''(String args[]) {\n              Person per =''new''Person(''""张三""'',''20'') ;\n              System.''out''.println(per.getInfo()) ;\n    }\n}''运行结果：''姓名：张三，年龄：20''我们来观察一下构造方法：''public''Person''(String n,''int''a) {\n              name = n ;\n              age = a ;\n    }''这个时候的构造方法的两个参数的目的是为类中的name和age两个属性初始化，可是这个方法上的两个参数，一个是字母n，另外一个是字母a，什么意思？那么最好的做法，既然构造方法的两个参数是为了name和age属性初始化使用的，最好将其的名称也定义为name和age才最为合适：''public''Person''(String name,''int''age) {\n              name = name ;\n              age = age ;\n    }''此时构造方法上的两个参数的名称变得有意义了。但是这样一来，一个问题就出现了，发现属性没有内容了。因为在程序之中是以“{}”作为一个分界，采用就近的取用原则，所以现在为了可以明确的指定要操作的是类中属性的话，那么应该采用“this.属性”的形式完成，代码应该变为：''public''Person''(String name,''int''age) {''this''.name = name ;''this''.age = age ;\n    }''一个开发建议：''只要是调用本类中的属性，都使用“this.属性”的方式来进行。''二、this调用本类方法''一个类中的方法分为两种：''（1）普通方法：如果现在要调用的是本类方法，可以使用“this.方法()”调用；''（2）构造方法：调用构造方法使用“this(参数…)”调用。''例如：现在一个类之中存在了三个构造方法（无参、有一个参数、有两个参数），但是不管使用何种构造方法，都要求在实例化对象产生的时候输出一行提示信息：“一个新的类对象被实例化”。按照之前的学习，代码编写如下：''package com.wz.thisdemo;\n\nclass Person {''private''String name ;''private''int''age ;''public''Person''() {\n              System.''out''.println(''""*** 一个新的Person类对象被实例化。""'') ;\n    }''public''Person''(String name) {\n             System.''out''.println(''""*** 一个新的Person类对象被实例化。""'') ;''this''.name = name ;\n    }''public''Person''(String name,''int''age) {\n             System.''out''.println(''""*** 一个新的Person类对象被实例化。""'') ;''this''.name = name ;''this''.age = age ;\n    }''// setter、getter略''public''String''getInfo''() {''return''""姓名：""''+''this''.name +''""，年龄：""''+''this''.age ;\n    }\n}''public''class''TestDemo {''public''static''void''main''(String args[]) {\n              Person per =''new''Person(''""张三""'',''20'') ;\n              System.''out''.println(per.getInfo()) ;\n    }\n}''运行结果：''*** 一个新的Person类对象被实例化。''姓名：张三，年龄：20''不过，遗憾的是，此时的程序之中出现了大量的重复代码，而我们的目标是尽量没有重复。这种情况下就可以利用this()来完成：''package com.wz.thisdemo;\n\nclass Person {''private''String name ;''private''int''age ;''public''Person''() {\n              System.''out''.println(''""*** 一个新的Person类对象被实例化。""'') ;\n    }''public''Person''(String name) {''this''() ;''// 调用无参构造''this''.name = name ;\n    }''public''Person''(String name,''int''age) {''this''(name) ;''// 调用有一个参数的构造''this''.age = age ;\n    }''// setter、getter略''public''String''getInfo''() {''return''""姓名：""''+''this''.name +''""，年龄：""''+''this''.age ;\n    }\n}''public''class''TestDemo {''public''static''void''main''(String args[]) {\n              Person per =''new''Person(''""张三""'',''20'') ;\n              System.''out''.println(per.getInfo()) ;\n    }\n}''运行结果：''*** 一个新的Person类对象被实例化。''姓名：张三，年龄：20''以上就使用this()就完成了构造方法之间的互相调用操作。''但是要注意的是：所有的构造方法是在对象实例化的时候被默认调用，而且是在调用普通方法之前调用，所以使用“this()”调用构造方法的操作，一定要放在构造方法的首行；''public''Person''(String name) {''this''() ;''// 调用无参构造，放在首行''this''.name = name ;\n    }''另外，我们来看一段代码：''package com.wz.thisdemo;\nclass Person {''private''String name ;''private''int''age ;''public''Person''() {''this''(''""""'',''10'') ;''// 调用两个参数的构造''System.''out''.println(''""*** 一个新的Person类对象被实例化。""'') ;\n    }''public''Person''(String name) {''this''() ;''// 调用一个参数的构造''this''.name = name ;\n    }''public''Person''(String name,''int''age) {''this''(name) ;''// 调用有一个参数的构造''this''.age = age ;\n    }''// setter、getter略''public''String''getInfo''() {''return''""姓名：""''+''this''.name +''""，年龄：""''+''this''.age ;\n    }\n}''public''class''TestDemo {''public''static''void''main''(String args[]) {\n              Person per =''new''Person(''""张三""'',''20'') ;\n              System.''out''.println(per.getInfo()) ;\n    }\n}''运行结果：''Exception''in''thread''""main""''java''.lang''.Error'': Unresolved compilation problems: \n    Recursive constructor invocation Person(String, int)\n    Recursive constructor invocation Person()\n    Recursive constructor invocation Person(String)\n\n    at''com''.wz''.thisdemo''.Person''.<init>(TestDemo''.java'':''6'')\n    at''com''.wz''.thisdemo''.TestDemo''.main''(TestDemo''.java'':''23'')''通过以上代码和运行结果不难看出：递归调用了构造器。''所以，''如果一个类之中存在了多个构造方法的话，并且这些构造方法都使用了this()互相调用，那么至少要保留一个构造方法没有调用其他构造，以作为程序的出口。''我们来看一个构造方法互相操作的实例：''定义一个雇员类（员工号、姓名、薪水、部门），在这个类中提供四个工作方法：''A、单参，只传递员工号，则员工姓名：无名氏，薪水：0，部门：未定''B、双参，传递员工号，姓名，则员工薪水为1000，部门：后勤''C、四参，传递员工号，姓名，部门，薪水''D、无参，则均为空值''来看代码：''package com.wz.thisdemo;\nclass Emp {''private''int''empno ;''private''String ename ;''private''double''salary ;''private''String dept ;''public''Emp''(){}''public''Emp''(''int''empno){''this''.empno = empno ;''this''.ename =''""无名氏""'';''this''.salary =''0.0'';''this''.dept =''""未定""'';\n    }''public''Emp''(''int''empno,String ename){''this''.empno = empno ;''this''.ename = ename ;''this''.salary =''1000.0'';''this''.dept =''""后勤""'';\n    }''public''Emp''(''int''empno,String ename,''double''salary,String dept){''this''.empno = empno ;''this''.ename = ename ;''this''.salary = salary ;''this''.dept = dept ;\n    }''public''String''getInfo''() {''return''""雇员编号：""''+''this''.empno +''""，姓名：""''+''this''.ename +''""，工资：""''+''this''.salary +''""，部门：""''+''this''.dept ;\n    }\n}''public''class''TestDemo {''public''static''void''main''(String args[]) {\n        Emp emp1 =''new''Emp();\n        System.''out''.println(emp1.getInfo());\n\n        Emp emp2 =''new''Emp(''4555'');\n        System.''out''.println(emp2.getInfo());\n\n        Emp emp3 =''new''Emp(''6542'',''""小王""'');\n        System.''out''.println(emp3.getInfo());\n\n        Emp emp4 =''new''Emp(''4578'',''""小明""'',''12000'',''""技术部""'');\n        System.''out''.println(emp4.getInfo());\n\n    }\n}''运行结果：''雇员编号：''0''，姓名：''null''，工资：''0.0''，部门：''null''雇员编号：''4555''，姓名：无名氏，工资：''0.0''，部门：未定\n雇员编号：''6542''，姓名：小王，工资：''1000.0''，部门：后勤\n雇员编号：''4578''，姓名：小明，工资：''12000.0''，部门：技术部''如果按照以上的方式开发，是可以完成功能的实现，但是代码中却存在了重复的代码，很明显，这样不合适。于是，我们通过构造方法的相互调用来对构造方法进行如下改动：''public''Emp''(){}''public''Emp''(''int''empno){''this''(empno,''""无名氏""'',''0.0'',''""未定""'') ;''//调用四参构造方法''}''public''Emp''(''int''empno,String ename){''this''(empno,ename,''1000.0'',''""后勤""'') ;''//调用四参构造方法''}''public''Emp''(''int''empno,String ename,''double''salary,String dept){''this''.empno = empno ;''this''.ename = ename ;''this''.salary = salary ;''this''.dept = dept ;\n    }''运行结果如下：''雇员编号：''0''，姓名：''null''，工资：''0.0''，部门：''null''雇员编号：''4555''，姓名：无名氏，工资：''0.0''，部门：未定\n雇员编号：''6542''，姓名：小王，工资：''1000.0''，部门：后勤\n雇员编号：''4578''，姓名：小明，工资：''12000.0''，部门：技术部''这种构造方法的互相调用是在对象实例化的时候，不同的构造有一些相同操作的情况下去使用。''三、this表示当前对象''当前对象，是指当前正在调用类中方法的对象。''先来看一段代码：''package com.wz.thisdemo;\n\nclass Book{\n\n}''public''class''TestDemo {''public''static''void''main''(String args[]) {\n        Book booka =''new''Book();\n        System.''out''.println(booka);\n\n        Book bookb =''new''Book();\n        System.''out''.println(bookb);\n\n    }\n}''运行结果：''com''.wz''.thisdemo''.Book''@15''db9742''com''.wz''.thisdemo''.Book''@6''d06d69c''在Book类中加上一个打印this的方法：''package com.wz.thisdemo;\n\nclass Book{''public''void''print''(){''//this就是当前调用该方法的对象''System.''out''.println(''""this = ""''+''this'');\n    }\n}''public''class''TestDemo {''public''static''void''main''(String args[]) {\n        Book booka =''new''Book();\n        System.''out''.println(booka);\n        booka.print();\n\n        System.''out''.println();\n\n        Book bookb =''new''Book();\n        System.''out''.println(bookb);\n        bookb.print();\n\n    }\n}''运行结果：''com''.wz''.thisdemo''.Book''@15''db9742\nthis =''com''.wz''.thisdemo''.Book''@15''db9742''com''.wz''.thisdemo''.Book''@6''d06d69c\nthis =''com''.wz''.thisdemo''.Book''@6''d06d69c''那么，之前的“this.属性”实际上就是当前对象的属性，一定是堆内存中保存的内容。'"
CSDN,https://blog.csdn.net/qq_43555323/article/details/84993460,Java之路：this关键字的用法,星云999,Java之路,,2018-12-15 09:42:22,"'（1）this代表当前对象的一个引用。所谓当前对象，指的是调用类中方法或属性的那个对象。''最经常使用this关键字的情况，是在对象的一个属性被方法或构造器的参数屏蔽时，需要调用这个被屏蔽的属性，如下：''class''Person''{''private''String name'';''private''int''age'';''public''Person''(''String name'',''int''age'')''{''// 局部变量name,age把Person类的属性屏蔽''this''.''name''=''name'';''this''.''age''=''age'';''}''}''（2）this只能在方法内部使用，表示对“调用方法的那个对象”的引用。但要注意，如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的this引用会自动应用于同一类中的其他方法。''如下：''public''class''Apricot''{''void''pick''('')''{''}''void''pit''('')''{''pick''('')'';''}''}''在pit()内部，你可以写this.pick()，但无此必要。编译器能帮你自动添加。只有当需要明确指出对当前对象的引用时，才需要使用this关键字。''注：有些人执意将this放在每一个方法调用和字段引用前，认为这样“更清楚更明确”。但是造成别这样做。我们使用高级语言的原因之一就是它们能帮我们做一些事情。要是你把this放在一些没必要的地方，就会使读你程序的人不知所措，因为别人写的代码不会到处用到this。人们期望只在必要处使用this。遵循一种一致而直观的编程风格能节省时间和金钱。''（3）this不能用于静态方法。main方法也是静态的，所以this也不能用于main方法。''Static方法是类方法，先于任何的实例（对象）存在。即Static方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成，而this指代的是当前的对象。''在方法中定义使用的this关键字，它的值是当前对象的引用。也就是说你只能用它来调用属于当前对象的方法或者使用this处理方法中成员变量和局部变量重名的情况.。''而且,更为重要的是''this和super都无法出现在static 修饰的方法中''，static 修饰的方法是属于类的，该方法的调用者可能是一个类，而不是对象。如果使用的是类来调用而不是对象，则this就无法指向合适的对象。所以static 修饰的方法中不能使用this。''（4）可以''使用this关键字调用重载构造方法''。避免相同的初始化代码，只能在构造方法中用，并且''必须位于构造方法的第一句''。并且，除了构造器之外，编译器禁止在其他任何方法中调用构造器。''package''this_constructor'';''class''Person''{''String name'';''int''age'';''public''Person''('')''{''System''.''out''.''println''(''""Person() constructor!""'')'';''}''public''Person''(''String name'',''int''age'')''{''this''('')'';''// 调用本类中无参构造方法''this''.''name''=''name'';''this''.''age''=''age'';''System''.''out''.''println''(''""Person(String name, int age) constructor!""'')'';''}''}''public''class''ThisConstructor''{''public''static''void''main''(''String''['']''args'')''{''{''new''Person''(''""小光""'',''25'')'';''}''}''}''【结果】''再看下例：''public''class''Rectangle''{''private''int''x'',''y'';''private''int''width'',''height'';''public''Rectangle''('')''{''this''(''0'',''0'',''0'',''0'')'';''// 调用当前对象带有四个参数的构造器''}''public''Rectangle''(''int''width'',''int''height'')''{''this''(''0'',''0'',''width'',''height'')'';''}''public''Rectangle''(''int''x'',''int''y'',''int''width'',''int''height'')''{''this''.''x''=''x'';''this''.''y''=''y'';''this''.''width''=''width'';''this''.''height''=''height'';''}''.''.''.''}''有的读者经常会有这样的疑问，如果我把this()调用无参构造方法的位置任意调换，那不就可以在任何时候都可以调用构造方法了么？实际上这样理解是错误的。构造方法是在实例化一个对象时被自动调用的，也就是说在类中的所有方法里，只有构造方法是被优先调用的，所以使用this调用构造方法必须也只能放在类中。'"
CSDN,https://blog.csdn.net/qq_43555323/article/details/84993460,Java之路：this关键字的用法,星云999,Java之路,,2018-12-15 09:42:22,"'（1）this代表当前对象的一个引用。所谓当前对象，指的是调用类中方法或属性的那个对象。''最经常使用this关键字的情况，是在对象的一个属性被方法或构造器的参数屏蔽时，需要调用这个被屏蔽的属性，如下：''class''Person''{''private''String name'';''private''int''age'';''public''Person''(''String name'',''int''age'')''{''// 局部变量name,age把Person类的属性屏蔽''this''.''name''=''name'';''this''.''age''=''age'';''}''}''（2）this只能在方法内部使用，表示对“调用方法的那个对象”的引用。但要注意，如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的this引用会自动应用于同一类中的其他方法。''如下：''public''class''Apricot''{''void''pick''('')''{''}''void''pit''('')''{''pick''('')'';''}''}''在pit()内部，你可以写this.pick()，但无此必要。编译器能帮你自动添加。只有当需要明确指出对当前对象的引用时，才需要使用this关键字。''注：有些人执意将this放在每一个方法调用和字段引用前，认为这样“更清楚更明确”。但是造成别这样做。我们使用高级语言的原因之一就是它们能帮我们做一些事情。要是你把this放在一些没必要的地方，就会使读你程序的人不知所措，因为别人写的代码不会到处用到this。人们期望只在必要处使用this。遵循一种一致而直观的编程风格能节省时间和金钱。''（3）this不能用于静态方法。main方法也是静态的，所以this也不能用于main方法。''Static方法是类方法，先于任何的实例（对象）存在。即Static方法在类加载时就已经存在了，但是对象是在创建时才在内存中生成，而this指代的是当前的对象。''在方法中定义使用的this关键字，它的值是当前对象的引用。也就是说你只能用它来调用属于当前对象的方法或者使用this处理方法中成员变量和局部变量重名的情况.。''而且,更为重要的是''this和super都无法出现在static 修饰的方法中''，static 修饰的方法是属于类的，该方法的调用者可能是一个类，而不是对象。如果使用的是类来调用而不是对象，则this就无法指向合适的对象。所以static 修饰的方法中不能使用this。''（4）可以''使用this关键字调用重载构造方法''。避免相同的初始化代码，只能在构造方法中用，并且''必须位于构造方法的第一句''。并且，除了构造器之外，编译器禁止在其他任何方法中调用构造器。''package''this_constructor'';''class''Person''{''String name'';''int''age'';''public''Person''('')''{''System''.''out''.''println''(''""Person() constructor!""'')'';''}''public''Person''(''String name'',''int''age'')''{''this''('')'';''// 调用本类中无参构造方法''this''.''name''=''name'';''this''.''age''=''age'';''System''.''out''.''println''(''""Person(String name, int age) constructor!""'')'';''}''}''public''class''ThisConstructor''{''public''static''void''main''(''String''['']''args'')''{''{''new''Person''(''""小光""'',''25'')'';''}''}''}''【结果】''再看下例：''public''class''Rectangle''{''private''int''x'',''y'';''private''int''width'',''height'';''public''Rectangle''('')''{''this''(''0'',''0'',''0'',''0'')'';''// 调用当前对象带有四个参数的构造器''}''public''Rectangle''(''int''width'',''int''height'')''{''this''(''0'',''0'',''width'',''height'')'';''}''public''Rectangle''(''int''x'',''int''y'',''int''width'',''int''height'')''{''this''.''x''=''x'';''this''.''y''=''y'';''this''.''width''=''width'';''this''.''height''=''height'';''}''.''.''.''}''有的读者经常会有这样的疑问，如果我把this()调用无参构造方法的位置任意调换，那不就可以在任何时候都可以调用构造方法了么？实际上这样理解是错误的。构造方法是在实例化一个对象时被自动调用的，也就是说在类中的所有方法里，只有构造方法是被优先调用的，所以使用this调用构造方法必须也只能放在类中。'"
CSDN,https://blog.csdn.net/fengsx0521/article/details/81281321,vue项目部署运行到tomcat上,oR聊,vue,,2018-07-30 10:53:23,'使用webstrorm开发vue前端工程项目时，使用命令npm run dev开启服务，可以通过访问电脑IP:电脑端口实时预览页面，当时我在想使用手机端来调试页面时，发现即使手机与电脑处于同一局域网环境下，仍然无法访问。''这就很奇怪了 ，平时只要我的电脑和手机处于同一局域网环境下，使用手机访问电脑IP:电脑端口/项目名，就可以正常访问，现在却不行，结果去网上搜索，普遍的一个解决办法是在webstorm中通过添加一个部署来使用的，就像是下图一样：''经过了好一番折腾，发现手机端可以访问电脑端的文件了，可是发现这是一个坑，这样子设置了只是说手机可以访问电脑当前目录的一些文件，对于静态文件还好，但是这是一个服务，那就没办法了。''闲话少叙，说一个我自己的解决办法：''1.【修改index.js】修改config目录下的index.js，将assetsPublicPath: ‘/’改为assetsPublicPath: ‘./’，注意，有两处，都要改，不然打包部署到tomcat上面访问是一片空白；还有一点需要注意的就是，webstorm起服务时，需要改回来，不然也是不行的''2.【打包】项目文件目录下运行命令：npm run build，将项目打包好，然后当前项目目录下有一个dist文件夹，该文件夹下有一个index.html和static文件夹''3.【tomcat部署】现在，在tomcat的webapps文件夹下以项目名称新建一个文件夹，比如my_app，然后将index.html和static文件夹复制到my_app文件夹下，现在就可以启动服务器了，访问正常。'
CSDN,https://blog.csdn.net/qq_41352018/article/details/80274257,深度强化学习――从DQN到DDPG,智元元,深度强化学习,,2018-05-10 21:46:10,"'引言''深度强化学习最近取得了很多进展，并在机器学习领域得到了很多的关注。传统的强化学习局限于动作空间和样本空间都很小，且一般是离散的情境下。然而比较复杂的、更加接近实际情况的任务则往往有着很大的状态空间和连续的动作空间。实现端到端的控制也是要求能处理高维的，如图像、声音等的数据输入。前些年开始兴起的深度学习，刚好可以应对高维的输入，如果能将两者结合，那么将使智能体同时拥有深度学习的理解能力和强化学习的决策能力。2013和2015年DeepMind的DQN可谓是将两者成功结合的开端，它用一个深度网络代表价值函数，依据强化学习中的Q-Learning，为深度网络提供目标值，对网络不断更新直至收敛。DQN用到了两个关键技术，一是用来打破样本间关联性的样本池，二是使训练稳定性和收敛性更好的固定目标网络。DQN可以应对高维输入，而对高维的动作输出则束手无策。随后，同样是DeepMind提出的DDPG，则可以解决有着高维或者说连续动作空间的情境。它包含一个策略网络用来生成动作，一个价值网络用来评判动作的好坏，并吸取DQN的成功经验，同样使用了样本池和固定目标网络，是一种结合了深度网络的Actor-Critic方法。''一、强化学习''智能体在完成某项任务时，如上图所示，首先通过动作A与周围环境进行交互，在动作A和环境的作用下，智能体会产生新的状态，同时环境会给出一个立即回报。如此循环下去，智能体与环境进行不断地交互从而产生很多数据。强化学习算法利用产生的数据修改自身的动作策略，再与环境交互，产生新的数据，并利用新的数据进一步改善自身的行为，经过数次迭代学习后，智能体能最终地学到完成相应任务的最优动作（最优策略）。这就是一个强化学习的过程。''强化学习所面对的是一个连续决策过程。这一问题框架基于一个MDP过程，即马尔科夫决策过程，如上图所示。智能体面对的环境有一个状态空间X，智能体自己有一个动作空间U，智能体根据状态的观察值O来进行决策。环境动态模型或者说转移概率描述了状态间是如何转化的，策略描述了智能体如何决策。''如上图所示，强化学习根据以策略为中心还是以值函数最优可以分为两大类，策略优化 方法和动态规划方法。其中策略优化方法又分为进化算法和策略梯度方法；动态规划方法分为策略迭代算法和值迭代算法。策略迭代算法和值迭代算法可以用广义策略迭代方法进行统一描述。另外，强化学习算法根据策略是否是随机的，分为确定性策略强化学习和随机性策略强化学习。根据转移概率是否已知可以分为基于模型的强化学习和无模型的强化学习算法。另外，强化学习算法中的回报函数r十分关键，根据回报函数是否已知，可以分为强化学习和逆向强化学习。逆向强化学习是根据专家演示将回报函数学习出来。''二、策略梯度''策略梯度方法中，将策略参数化表示为，计算出关于动作的策略函数梯度，不断调整动作，靠近最优策略。策略梯度的计算公式已由相关学者推导得到，且有两种策略梯度，一是随机性策略梯度，二是确定性策略梯度。''1、随机性策略梯度：''2、确定性策略梯度：''证明可参考相关论文。总之，策略梯度的直观理解是调整策略函数的参数，使得其给出的动作可以获得较大的Q值。''Actor-Critic方法是一种很重要的强化学习算法，其是一种时序差分方法（TD method），结合了基于值函数的方法和基于策略函数的方法。其中策略函数为行动者（Actor），给出动作；价值函数为评价者（Critic），评价行动者给出动作的好坏，并产生时序差分信号，来指导价值函数和策略函数的更新。其框架如下图：''将此方法与深度学习结合的话，则是分别用两个深度网络去代表价值函数和策略函数。之后所介绍的DDPG就是基于这样一种Actor-Critic架构的深度强化学习方法。''三、DQN''DeepMind在2013年提出的DQN算法（2015年提出了DQN的改进版本）可以说是深度学习和强化学习的第一次成功结合。要想将深度学习融合进强化学习，是有一些很关键的问题需要解决的，其中的两个问题如下：''1、深度学习需要大量有标签的数据样本；而强化学习是智能体主动获取样本，样本量稀疏且有延迟。''2、深度学习要求每个样本相互之间是独立同分布的；而强化学习获取的相邻样本相互关联，并不是相互独立的。''若想将这两者结合，必须解决包括上面两点在内的问题。''DQN具体来说，是基于经典强化学习算法Q-Learning，用深度神经网络拟合其中的Q值的一种方法。Q-Learning算法提供给深度网络目标值，使其进行更新。先来看Q-Learning的算法流程图：''智能体采用off-policy即执行的和改进的不是同一个策略，这通过方法实现。用这种方式采样，并以在线更新的方式，每采集一个样本进行一次对Q函数的更新。更新所依据的是时序差分公式。以更新后的Q函数得到新的策略。而这种经典强化学习算法的局限性在于，无法应对高维的输入，且无法应用于大的动作空间，特别的，无法应用于连续动作输出。DQN所做的是用一个深度神经网络进行端到端的拟合，发挥深度网络对高维数据输入的处理能力。其2013年版本结构如下：''在2015年又发布了其改进版本：''其有两个关键技术：''1、样本池（experience reply）：将采集到的样本先放入样本池，然后从样本池中随机选出一条样本用于对网络的训练。这种处理打破了样本间的关联，使样本间相互独立。''2、固定目标值网络（fixed Q-target）：计算网络目标值需用到现有的Q值，现用一个更新较慢的网络专门提供此Q值。这提高了训练的稳定性和收敛性。''四、DDPG''DQN是一种基于值函数的方法，基于值函数的方法难以应对的是大的动作空间，特别是连续动作情况。因为网络难以有这么多输出，且难以在这么多输出之中搜索最大的Q值。而DDPG是基于上面所讲到的Actor-Critic方法，在动作输出方面采用一个网络来拟合策略函数，直接输出动作，可以应对连续动作的输出及大的动作空间。''再来回顾一下Acror-Critic结构。如下图：''该结构包含两个网络，一个策略网络（Actor），一个价值网络（Critic）。策略网络输出动作，价值网络评判动作。两者都有自己的更新信息。策略网络通过梯度计算公式进行更新，而价值网络根据目标值进行更新。''DDPG采用了DQN的成功经验。即采用了样本池和固定目标值网络这两项技术。也就是说这两个网络分别有一个变化较慢的副本，该变化较慢的网络提供给更新信息中需要的一些值。DDPG的整体结构如下：''DDPG方法是深度学习和强化学习的又一次成功结合，是深度强化学习发展过程中很重要的一个研究成果。其可以应对高维的输入，实现端对端的控制，且可以输出连续动作，使得深度强化学习方法可以应用于较为复杂的有大的动作空间和连续动作空间的情境。''参考文献：''[1] Silver D, Lever G, Heess N, et al. Deterministic Policy Gradient''Algorithms[C]// International Conference on Machine Learning. 2014:387-395.''[2] Mnih V, Kavukcuoglu K, Silver D, et al. Human-level control through''deep reinforcement learning.[J]. Nature, 2015, 518(7540):529.''[3] Mnih V, Kavukcuoglu K, Silver D, et al. Playing Atari with Deep''Reinforcement Learning[J]. Computer Science, 2013.''[4] Lillicrap T P, Hunt J J, Pritzel A, et al. Continuous control with deep''reinforcement learning[J]. Computer Science, 2015, 8(6):A187.''注：前四张图片来自别处，如有侵权立即修改。文字及后五张彩色图片为自己写的和画的，尤其是图片画得很用心~'"
CSDN,https://blog.csdn.net/qq_41352018/article/details/80274282,强化学习――从Q-Learning到DQN到底发生了什么？,智元元,强化学习,,2018-05-10 21:47:55,"'1 学习目标''1. 复习Q-Learning；''2. 理解什么是值函数近似（Function Approximation）；''3. 理解什么是DQN，弄清它和Q-Learning的区别是什么。''2 用Q-Learning解决经典迷宫问题''现有一个5房间的房子，如图1所示，房间与房间之间通过门连接，编号0到4,5号是房子外边，即我们的终点。我们将agent随机放在任一房间内，每打开一个房门返回一个reward。图2为房间之间的抽象关系图，箭头表示agent可以从该房间转移到与之相连的房间，箭头上的数字代表reward值。''图1 房子原型图''图2 抽象关系图''根据此关系，可以得到reward矩阵为''Q-Learning是一种off-policy TD方法，伪代码如图所示''Q-Learning伪代码''我们首先会初始化一个Q表，用于记录状态-动作对的值，每个episode中的每一步都会根据下列公式更新一次Q表''这里的迷宫问题，每一次episode的结束指的是到达终点状态5。为了简单起见，这里将学习率''设为1，更新公式变为''另外，将衰减系数''设为0.8。Q表初始化为一个5×5的全0矩阵。下面这个小视频展示了一个episode中一步的更新过程，每次这样更新，最终Q表会收敛到一个矩阵。''最终Q表收敛为''因此，也可以得到最优路径如下红色箭头所示''Python代码：''import''numpy''as''np''GAMMA''=''0.8''Q''=''np''.''zeros''((''6'',''6''))''R''=''np''.''asarray''([[''-''1'',''-''1'',''-''1'',''-''1'',''0'',''-''1''],''[''-''1'',''-''1'',''-''1'',''0'',''-''1'',''100''],''[''-''1'',''-''1'',''-''1'',''0'',''-''1'',''-''1''],''[''-''1'',''0'',''0'',''-''1'',''0'',''-''1''],''[''0'',''-''1'',''-''1'',''0'',''-''1'',''100''],''[''-''1'',''0'',''-''1'',''-''1'',''0'',''100'']])''def''getMaxQ''(''state''):''return''max''(''Q''[''state'','':])''def''QLearning''(''state''):''curAction''=''None''for''action''in''range''(''6''):''if''(''R''[''state''][''action'']''==''-''1''):''Q''[''state'',''action'']''=''0''else'':''curAction''=''action''Q''[''state'',''action'']''=''R''[''state''][''action'']''+''GAMMA''*''getMaxQ''(''curAction'')''count''=''0''while''count''<''1000'':''for''i''in''range''(''6''):''QLearning''(''i'')''count''+=''1''print''(''Q''/''5'')''Q-Learning方法很好的解决了这个迷宫问题，但是这终究只是一个小问题（状态空间和动作空间都很小），''实际情况下，大部分问题都是有巨大的状态空间或者动作空间，想建立一个Q表，内存是绝对不允许的，而且数据量和时间开销也是个问题。''3 值函数近似与DQN''值函数近似（Function Approximation）的方法就是为了解决状态空间过大，也称为“维度灾难”的问题。通过用''函数''而不是Q表来表示''，这个函数可以是线性的也可以使非线性的。''其中''称为“权重”。那怎么把这个权重求出来，即拟合出这样一个合适的函数呢？''这里就要结合机器学习算法里的一些有监督学习算法，对输入的状态提取特征作为输入，通过MC/TD计算出值函数作为输出，然后对函数参数''进行训练，直到收敛。''这里主要说的是回归算法，比如线性回归、决策树、''神经网络''等。''这里，就可以引入DQN（Deep Q-Network）了，''实际上它就是Q-Learning和神经网络的结合，将Q-Learning的Q表变成了Q-Network。''好，现在关键问题来了。这么去训练这个网络呢？换句话说，怎么去确定网络参数''呢？''第一，我们需要一个Loss Function；第二，我们需要足够的训练样本。''训练样本好说，通过''策略去生成就好。回忆一下Q-Learning，我们更新Q表是利用每步的reward和当前Q表来迭代的。那么我们可以用这个计算出来的Q值作为监督学习的“标签”来设计Loss Function，我们采用如下形式，即近似值和真实值的均方差''采用随机梯度下降法（SGD）来迭代求解，得到我们想要的''，具体公式和过程还请看参考资料，这里不展开了，其实就是求导啦。值得一提的是，上述公式中的''根据不同方法算出来，其形式不一样，比如利用MC，则为''（回报）；利用TD(0)，则为''；Q-Learning呢，就是''。''在David Silver的课里，他根据每次更新所参与样本量的不同把更新方法分为增量法（Incremental Methods）和批处理法（Batch Methods）。前者是来一个数据就更新一次，后者是先攒一堆样本，再从中采样一部分拿来更新Q网络，称之为“''经验回放''”，实际上DeepMind提出的DQN就是采用了经验回放的方法。为什么要采用经验回放的方法？因为对神经网络进行训练时，''假设样本是独立同分布的''。而通过强化学习采集到的数据之间存在着关联性，利用这些数据进行顺序训练，神经网络当然不稳定。经验回放可以打破数据间的关联。''最后附上DQN的伪代码''DQN伪代码''学到这里，其实可以做一个阶段性总结了，强化学习算法的基本框架可以用下图概括''强化学习框架''本专栏文章介绍了这个图里的大部分内容，但最重要、应用最为广泛的policy-based方法还没有介绍，这也是后面要着重去学习的。''参考''[1]Reinforcement Learning: An Introduction - Chapter 9: On-policy Prediction with Approximation''[2]Reinforcement Learning: An Introduction - Chapter 10: On-policy Control with Approximation'""[3]David Silver's RL Course Lecture 6 - Value Function Approximation (""'video'',''slides'')''[4]''DQN从入门到放弃5 深度解读DQN算法''[5]''一条咸鱼的强化学习之路6之值函数近似（Value Function Approximation）和DQN'"
CSDN,https://blog.csdn.net/woshimeihuo/article/details/85772751,tomcat + vue打包部署，图片访问绝对路径设置,魅惑青花瓷,前端,,2019-01-04 13:55:50,'vue vsCode打包 路径设置''1.部署tomcat，打包vue项目，将打包好后的项目放在tomcat的webapps下''2.设置图片访问路径，tomcat的conf的server.xml中，添加这一句''3.图片的保存路径是''4.图片的访问是''5.vue设置打包路径是在config目录下的index.js中'
CSDN,https://blog.csdn.net/fengsx0521/article/details/81281321,vue项目部署运行到tomcat上,oR聊,vue,,2018-07-30 10:53:23,'使用webstrorm开发vue前端工程项目时，使用命令npm run dev开启服务，可以通过访问电脑IP:电脑端口实时预览页面，当时我在想使用手机端来调试页面时，发现即使手机与电脑处于同一局域网环境下，仍然无法访问。''这就很奇怪了 ，平时只要我的电脑和手机处于同一局域网环境下，使用手机访问电脑IP:电脑端口/项目名，就可以正常访问，现在却不行，结果去网上搜索，普遍的一个解决办法是在webstorm中通过添加一个部署来使用的，就像是下图一样：''经过了好一番折腾，发现手机端可以访问电脑端的文件了，可是发现这是一个坑，这样子设置了只是说手机可以访问电脑当前目录的一些文件，对于静态文件还好，但是这是一个服务，那就没办法了。''闲话少叙，说一个我自己的解决办法：''1.【修改index.js】修改config目录下的index.js，将assetsPublicPath: ‘/’改为assetsPublicPath: ‘./’，注意，有两处，都要改，不然打包部署到tomcat上面访问是一片空白；还有一点需要注意的就是，webstorm起服务时，需要改回来，不然也是不行的''2.【打包】项目文件目录下运行命令：npm run build，将项目打包好，然后当前项目目录下有一个dist文件夹，该文件夹下有一个index.html和static文件夹''3.【tomcat部署】现在，在tomcat的webapps文件夹下以项目名称新建一个文件夹，比如my_app，然后将index.html和static文件夹复制到my_app文件夹下，现在就可以启动服务器了，访问正常。'
CSDN,https://blog.csdn.net/qq_41352018/article/details/80084974,大数据和人工智能概念全面解析,智元元,人工智能,,2018-04-27 08:52:00,'一、大数据和人工智能''大数据是伴随着信息数据爆炸式增长和网络计算技术迅速发展而兴起的一个新型概念。根据麦肯锡全球研究所的定义，大数据是一种规模大到在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合，具有海量的数据规模、快速的数据流转、多样的数据类型和价值密度低四大特征。大数据能够帮助各行各业的企业从原本毫无价值的海量数据中挖掘出用户的需求，使数据能够从量变到质变，真正产生价值。随着大数据的发展，其应用已经渗透到农业、工业、商业、服务业、医疗领域等各个方面，成为影响产业发展的一个重要因素。''当前人们所说的人工智能，是指研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术以及应用系统的一门新的技术科学，是由人工制造出来的系统所表现出来的智能。''传统人工智能受制于计算能力，并没能完成大规模的并行计算和并行处理，人工智能系统的能力较差。2006年，Hinton教授提出“深度学习”神经网络使得人工智能性能获得突破性进展，进而促使人工智能产业又一次进入快速发展阶段。“深度学习”神经网络主要机理是通过深层神经网络算法来模拟人的大脑学习过程，通过输入与输出的非线性关系将低层特征组合成更高层的抽象表示，最终达到掌握运用的水平。数据量的丰富程度决定了是否有充足数据对神经网络进行训练，进而使人工智能系统经过深度学习训练后达到强人工智能水平。因此，能否有足够多的数据对人工神经网络进行深度训练，提升算法有效性是人工智能能否达到类人或超人水平的决定因素之一。''随着移动互联网的爆发，数据量呈现出指数级的增长，大数据的积累为人工智能提供了基础支撑。同时受益于计算机技术在数据采集、存储、计算等环节的突破，人工智能已从简单的算法+数据库发展演化到了机器学习+深度理解的状态。''二、人工智能产业及生态''按产业链结构划分，人工智能可以分为基础技术层、AI技术层和AI应用层。基础技术层主要聚焦于数据资源、计算能力和硬件平台，数据资源主要是各类大数据，硬件资源包括芯片研发、存储设备开发等。AI技术层着重于算法、模型及可应用技术，如计算智能算法、感知智能算法、认知智能算法。AI应用层则主要关注将人工智能与下游各领域结合起来，如无人机、机器人、虚拟客服、语音输入法等。''图1 人工智能产业链''资料来源：中国产业信息网，《2017年中国人工智能行业发展概况及未来发展趋势分析》''（一）基础技术层''1.1 大数据''数据资源是机器学习训练的基本素材，通过对于数据的学习，机器能不断积累经验和优化决策参数，逐渐变得更贴近人类智能。''从数据流动方向的角度来看，大数据的产业链可分为底层平台、处理分析、应用三个层次。底层平台由基础设施与数据资产池构成，主要提供数据采集、分享和交易服务，处理分析则是在原始数据的基础上对数据进行清洗后以不同方式呈现。在数据处理分析的基础之上，挖掘各行业的数据需求，最终为用户提供服务。''根据数据应用程度不同，大数据产业链下各参与方功能可细分为数据标准与规范化、数据采集、数据安全、数据储存与管理、数据分析与挖掘、数据运维和数据运用七个方面。''1.2 计算能力和硬件平台''数据资源、核心算法、运算能力是人工智能的三大核心要素。随着全球移动互联网和物联网等快速发展，人类可获取利用的数据正以爆炸式增长。海量的大数据通过最新的深度学习技术将为人工智能的发展与应用带来难以估量的价值，而运算能力提升是人工智能发展的前提保障。其中，芯片是运算能力的核心。''就目前而言，AI 芯片主要类型有GPU、FPGA、ASIC和类人脑芯片四种。''1.2.1 GPU''1.2.1.1 GPU简介''GPU 即图形处理器，最初是用来做图像运算的微处理器。GPU 优化和调整了CPU 结构，使其运算速度突飞猛进，拥有了更强大的处理浮点运算的能力。2009 年，斯坦福大学的吴恩达及其团队发现GPU 芯片可以并行运行神经网络。用GPU来运行机器学习模型，同样的大训练集，GPU在耗费功率更低、占用基础设施更少的情况下能够支持远比单纯使用CPU时10-100倍的应用吞吐量。因此GPU已经成为数据科学家处理大数据的处理器。''1.2.1.2 GPU行业现状''目前国际GPU市场被NVIDIA 和AMD 两大公司瓜分，全球GPU 行业的市场份额有超过70％被NVIDIA占据，而应用在人工智能领域的可进行通用计算的GPU 市场则基本被NVIDIA垄断。目前公司已与谷歌、微软、IBM、丰田、百度等多家尝试利用深度神经网络来解决海量复杂计算问题的企业建立和合作关系。NVIDIA与下游客户在深度学习领域的合作不断加深，已经开发出多款针对深度学习的GPU产品。从产品成熟度、生态圈的规模角度而言，NVIDIA的GPU 已具备统治性的地位。''中国在GPU芯片设计领域起步较晚，目前只有景嘉微和兆芯两家掌握核心技术的公司正在逐步打破国外芯片在我国GPU市场的垄断局面，但产品还是主要用于GPU最初的图形显控领域，距人工智能所需要的GPU技术还有很远的距离。''1.2.2 FPGA''1.2.2.1 FPGA简介''FPGA，即场效可编程逻辑闸阵列，最初是从专用集成电路上发展起来的半定制化的可编程电路，FPGA 还具有静态可重复编程和动态在系统重构的特性，使得硬件的功能可以像软件一样通过编程来修改，不同的编程数据在同一片FPGA上可以产生不同的电路功能，具有很强的灵活性和适应性。''FPGA 和GPU 内都有大量的计算单元，因此它们的计算能力都很强。在进行神经网络运算的时候，两者的速度会比CPU 快很多。但是GPU 由于架构固定，硬件原生支持的指令也就固定了，而FPGA 则是可编程的。其可编程性是关键，因为它让软件与终端应用公司能够提供与其竞争对手不同的解决方案，并且能够灵活地针对自己所用的算法修改电路。与GPU相比，FPGA具有性能高、能耗低及可硬件编程的特点。''1.2.2.2 FPGA行业现状''目前FPGA 整个市场被国外的两大巨头所寡占，据东方证券研究所数据显示，Xilinx 和Altera 占了近90%的份额，合计专利达到6000多项，剩余份额被Lattice和Microsemi两家占据，两家专利合计共有超过3000项。技术专利的限制和漫长的开发周期使得FPGA行业有着极高的壁垒。''尽管我国政府多年来在此领域投入了数百亿的科研经费，但FPGA的专利限制及技术门槛使得中国FPGA的研发之路十分艰辛，国内如同创国芯、京微雅格、高云等公司在FPGA研发方面已获得一定进展，但产品性能、功耗、容量和应用领域上都同国外先进技术存在着较大差距。当前国内部分资本已经试图走出国门，通过并购半导体类公司的方法进入FPGA的行业，实现弯道超车。''1.2.3 ASIC''1.2.3.1 ASIC简介''ASIC，即专用集成电路，是指应特定用户要求或特定电子系统的需要而设计、制造的集成电路。ASIC 作为集成电路技术与特定用户的整机或系统技术紧密结合的产物，与通用集成电路相比，具有以下几个方面的优越性：体积更小、功耗更低、可靠性提高、性能提高、保密性增强。FPGA一般来说比ASIC的速度要慢，而且无法完成更复杂的设计，并且会消耗更多的电能，因此就算力而言ASIC远优于FPGA；但ASIC的专用特点使得其生产成本很高，如果出货量较小，则采用ASIC在经济上不太实惠。一旦人工智能技术成熟，ASIC专用集成的特点反而会达到规模效应，较通用集成电路而言，成本大大降低。''当前ASIC 在人工智能深度学习方面的应用还不多，但是我们可以拿比特币矿机芯片的发展做类似的推理。比特币挖矿和人工智能深度学习有类似之处，都是依赖于底层的芯片进行大规模的并行计算。比特币矿机的芯片经历了四个阶段：CPU、GPU、FPGA 和ASIC。其中ASIC 在比特币挖矿领域，展现出了得天独厚的优势。随着人工智能越来越多的应用在各个领域并表现出优越的性能，长期来看ASIC大有可为。''1.2.3.2 ASIC市场现状''随着人工智能的兴起，科技巨头纷纷布局芯片制造。高通、AMD、ARM、Intel和NVIDIA都在致力于将定制化芯片整合进它们的现有解决方案中。Nervana 和 Movidius（目前都在Intel旗下）据说正在开发集合方案。ASIC中较为成熟的产品是谷歌针对AlphaGo研发的TPU。第一代TPU产品由谷歌在2016年I/O大会上正式推出，今年5月的开发者I/O大会上，谷歌正式公布了第二代TPU，又称Cloud TPU，相较于初代TPU，既能用于训练神经网络，又可以用于推理，浮点性能方面较传统的GPU提升了15倍。''ASIC在人工智能领域的应用起步较晚，国内外水平相差不大。目前国内已有数家公司致力于人工智能相关ASIC芯片研究，代表公司为地平线机器人、中科寒武纪与中星微电子。其中地平线机器人公司作为初创企业，致力于打造基于深度神经网络的人工智能“大脑”平台-包括软件和芯片，可以做到低功耗、本地化的解决环境感知、人机交互、决策控制等问题。其关于芯片的研发目前还未成熟。中科寒武纪和中星微电子则已经有了相对成熟的产品。寒武纪芯片专门面向深度学习技术，研制了国际首个深度学习专用处理器芯片NPU，目前已研发的三款芯片分别面向神经网络的原型处理器结构、大规模神经网络和多种机器学习算法，预计将于2018年实现芯片的产业化。中星微电子于2016年6月推出中国首款嵌入式神经网络处理器（NPU）芯片，这是全球首颗具备深度学习人工智能的嵌入式视频采集压缩编码系统级芯片。这款基于深度学习的芯片运用在人脸识别上，最高能达到98%的准确率，超过人眼的识别率。该芯片于2017年3月6日实现量产，截止到今年5月出货量为十几万件。''1.2.4 类人脑芯片''1.2.4.1 类人脑芯片简介''类人脑芯片是一种基于神经形态工程、借鉴人脑信息处理方式，旨在打破“冯・诺依曼”架构束缚，适于实时处理非结构化信息、具有学习能力的超低功耗新型计算芯片。从理论上来看，类人脑芯片更加接近于人工智能目标的芯片，力图在基本架构上模仿人脑的工作原理，使用神经元和突触的方式替代传统架构体系，使芯片能够进行异步、并行、低俗和分布式处理信息数据的能力，同时具备自护感知、识别和学习的能力。''1.2.4.2 类人脑芯片市场现状''类人脑芯片是人工智能芯片发展的重点方向。目前各国政府及科技巨头都在大力推动类人脑芯片的研发进程，包括美国、日本、德国、英国、瑞士等发达国家已经制定相应的发展战略，中国的类人脑科学研究项目目前也已经正式启动。当前世界上已有一批科技公司走在前列，在类人脑芯片研发中取得了突破，代表产品包括IBM的TrueNorth芯片、高通Zeroth芯片、谷歌的“神经网络图灵机”等。''（二）AI技术层''AI技术层主要着眼于算法、模型及可应用技术。按照智能程度不同，人工智能可分为运算智能、感知智能、认知智能三个阶段。运算智能，即快速计算和记忆存储能力，在这一阶段主要是算法与数据库相结合，使得机器开始像人类一样会计算和传递信息； 感知智能，即视觉、听觉、触觉等感知能力，在这一阶段，数据库与浅层学习算法结合，使得机器开始看懂和听懂，并做出判断、采取行动；认知智能，即能理解会思考的能力，这一阶段主要是采用深度学习算法，使得机器能够像人一样思考，主动采取行动。''AI技术层可以分为框架层和算法层，其中框架层指TensorFlow，Caffe，Theano，Torch，DMTK，DTPAR，ROS等框架或操作系统，算法层指的是对数据的处理方法。''根据数据类型的不同，对一个问题会采用不同的建模方式，即学习方式。按照学习方式来分类，人工智能算法可以分为传统机器学习和神经网络算法，其中传统机器学习又可细分为监督式学习、非监督式学习、半监督式学习、强化学习。''2.1 传统机器学习''2.1.1 监督式学习''在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，如对防垃圾邮件系统中“垃圾邮件”“非垃圾邮件”，对手写数字识别中的“1“，”2“，”3“，”4“等。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。监督式学习的常见应用场景如分类问题和回归问题。常用算法有回归算法、朴素贝叶斯、SVM等。''2.1.2 非监督式学习''在非监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。常见的应用场景包括关联规则的学习以及聚类等。关联规则学习的常见算法主要为Apriori算法及其拓展算法，聚类的常用算法有k-Means算法及其相似算法。''2.1.3 半监督式学习''在此学习方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。''2.1.4 强化学习''在此学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。常见算法包括Q-Learning以及时间差学习（Temporal difference learning）。''2.2 神经网络''人工神经网络是模拟生物神经网络，由众多的神经元可调的连接权值连接而成，具有大规模并行处理、分布式信息存储、良好的组织学习能力特点，并通过一定学习准则进行学习，进而建立相关模型，解决一定工作。在人工神经网络的学习算法设计方面，一般对人工神经网络进行大量的数据训练和调整，不断修正各层级节点参数，通过不断学习使得人工神经网络具有初步的自适应能力和自我组织能力及较强的泛化能力，进而较快适应周边环境要求，基于其众多优点，人工神经网络已然成为人工智能算法的核心。深度学习算法是人工神经网络当前最新算法，其实质是通过很多隐层的机器学习模型和海量的训练数据来学习更有用的特征，从而提升分类或预测的准确性。''（三）AI应用层''人工智能的应用主要是采用了“AI+垂直行业”的方式渗透到传统各行业，按发展层次的不同可以分为专用人工智能、通用人工智能和超级人工智能三个层次。其中，专用人工智能以一个或多个专门的领域和功能为主；通用人工智能即机器与人类一样拥有进行所有工作的可能，关键在于自动地认知和拓展；超级人工智能是指具有自我意识，包括独立自主的价值观、世界观等，目前仅存在于文化作品构想中。''按应用技术类型进行划分，人工智能的应用技术可以分为计算机视觉、机器学习、自然语言处理和机器人四块。''3.1 计算机视觉''计算机视觉，是指计算机从图像中识别出物体、场景和活动的能力。计算机视觉技术运用由图像处理操作及其他技术所组成的序列来将图像分析任务分解为便于管理的小块任务目前计算机视觉主要应用在人脸识别、图像识别方面（包括静态、动态两类信息）。''人脸识别，亦叫人像识别、面部识别，是基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行处理的一系列相关技术。''图像识别，是计算机对图像进行处理、分析和理解，以识别各种不同模式的目标和对象的技术。识别过程包括图像预处理、图像分割、特征提取和判断匹配。由于动态监测与识别的技术限制，静态图像识别与人脸识别的研究暂时处于领先位置。''当前国外科技巨头自行研发和收购双管齐下布局计算机视觉领域，将技术广泛用于自身产品升级，并基于自身基因打造技术服务平台和新品类持续提升影响力。中国国内BAT都已纷纷布局相关领域，并基于自身产品进行功能研发。百度相对更加激进，成立了独立风投公司，专注于AI早期投资。''除BAT三巨头外，国内也有不少初创公司涉足计算机视觉技术，主要聚焦于技术应用。其中典型代表当属旷视科技。公司成立于2012年11月，公司专注于人脸识别技术和相关产品应用研究，面向开发者提供服务，能提供一整套人脸检测、人脸识别、人脸分析以及人脸3D技术的视觉技术服务，主要通过提供云端API、离线SDK、以及面向用户的自主研发产品形式，将人脸识别技术广泛应用到互联网及移动应用场景中。Face++通过和众多互联网公司合作，并通过“脱敏”技术掌握到了500万张人脸图片数据库，在互联网图片人脸识别LFW的准确率达到99.6%，合作伙伴包括阿里、360等一批大型的图片、社交、设备类企业。''当前国内计算机视觉创业热度不断提高，iiMedia Research(艾媒咨询)数据显示， 中国人工智能创业公司所属领域分布中，计算机视觉领域拥有最多创业公司，高达35家。''3.2 机器学习''机器学习是指计算机通过对大量已有数据的处理分析和学习，从而拥有预测判断和做出最佳决策的能力。其核心在于，机器学习是从数据中自动发现模式，模式一旦被发现便可用于做预测。''机器学习的应用范围非常广泛，针对那些产生庞大数据的活动，它几乎拥有改进一切性能的潜力。除了欺诈甄别之外，这些活动还包括销售预测、库存管理、石油和天然气勘探、以及公共卫生。机器学习技术在其他的认知技术领域也扮演着重要角色，比如计算机视觉，它能在海量图像中通过不断训练和改进视觉模型来提高其识别对象的能力。''现如今，机器学习已经成为认知技术中最炙手可热的研究领域之一，在2011-2014年中这段时间内就已吸引了近十亿美元的风险投资。谷歌也在2014年斥资4亿美金收购Deepmind这家研究机器学习技术的公司。目前国内机器学习相关企业数量相对较少。BAT在机器学习方面有着先天的优势，国内初创公司第四范式是基于机器学习的解决方案提供商。''3.3 自然语言处理''自然语言处理就是用人工智能来处理、理解以及运用人类语言，通过建立语言模型来预测语言表达的概率分布，从而实现目标。''自然语言处理技术在生活中应用广泛，例如机器翻译、手写体和印刷体字符识别、语音识别后实现文字转换、信息检索、抽取与过滤、文本分类与聚类、舆情分析和观点挖掘等。它们分别应用了自然语言处理当中的语法分析、语义分析、篇章理解等技术，是人工智能界最前沿的研究领域。时至今日AI在这些技术领域的发展已经把识别准确率从70%提高到了90%以上，但只有当准确率提高到99%及以上时，才能被认定为自然语言处理的技术达到人类水平。''在资本与产业助力之下，我国人工智能的语音识别技术已处于国际领先水平，技术成熟，通用识别率上，各企业均维持在了95%左右的水平。类似百度、科大讯飞等上市公司凭借深厚的技术和数据积累在市场上占据前列，且通过软硬件服务的开发不断进化着自身的服务能力。在科大讯飞之后发布国内第二家“语音识别公有云”的云知声在各项通用语音服务技术的提供上也占据着不小的市场空间。除此之外，依托中科院自动化所的紫冬锐意和纳象立方以及有着海外背景的苏州思必驰在教育领域的语音识别上占据着领先的位置。''3.4 机器人''将机器视觉、自动规划等认知技术整合至极小却高性能的传感器、致动器、以及设计巧妙的硬件中，这就催生了新一代的机器人，它有能力与人类一起工作，能在各种未知环境中灵活处理不同的任务。''目前世界上至少有48个国家在发展机器人，其中25个国家已涉足服务型机器人开发。在日本、北美和欧洲，迄今已有7种类型计40余款服务型机器人进入实验和半商业化应用在服务机器人领域。美国是机器人的发源地，美国的机器人技术在国际上仍一直处于领先地位，其技术全面、先进，适应性十分强，在军用、医疗、家用服务机器人产业都占有绝对的优势，占服务机器人市场约60%的份额。国内智能机器人行业的研发主要集中于家庭机器人、工业/企业服务和智能助手三个方面。其中工业及企业服务类的机器人研发企业依托政策背景和市场需求处于相对领先的发展阶段。然而在中国涉足智能机器人的企业中，从事家庭机器人和智能助手研发的企业占据了绝大多数比例。''因为服务一般都要结合特定市场进行开发，本土企业更容易结合特定的环境和文化进行开发占据良好的市场定位，从而保持一定的竞争优势；另一方面，外国的服务机器人公司也属于新兴产业，大部分成立的时候还比较短，因而我国的服务机器人产业面临着比较大的机遇和可发展空间。'
CSDN,https://blog.csdn.net/blogdevteam/article/details/103478461,博客帮助文档,CSDN官方博客,帮助文档,,2019-12-11 14:46:59,"'目录''博客积分规则''博客等级''C币规则（试运营）''博客VIP文章说明''博客专家''如何成为博客专家？''企业博客''如何开通企业博客''博客勋章''分类专栏''博客搬家''自定义百度统计''CSDN博客用户准则''总则：''博客注册''博客行为规则''被投诉侵权用户处理规则''附则''博客评论活跃等级规则（试运营）''Markdown帮助''付费专栏开通规则''博客积分规则''博客积分是CSDN对用户努力的认可和奖励，也是衡量博客水平的重要标准。博客等级也将由博客积分唯一决定。积分规则具体如下：''1、每发布一篇原创或者翻译文章：可获得10分；''2、每发布一篇转载文章：可获得2分；''3、博主的文章每被评论一次：可获得1分；''4、每发表一次评论：可获得1分（自己给自己评论、博主回复评论不获得积分）；''5、博文阅读次数每超过100次：可获得1分，阅读加分最高加到100分，即文章点击上万次截止；''6、文章被管理员或博主本人删除，相应减去博主基于该篇博文所获得的分数；''7、评论被管理员或博主删除，相应减去发评论者和博主基于该评论各自获得的分数（博主应减积分不会动态实时去掉，是每周固定时间清理一次）；''8、另外会开设相应的抄袭举报功能，一旦举报证实某篇原创文章抄袭，将扣除博主该篇文章相应的得分。''博客等级''图标''等级''所需积分''L1''0''L2''100''L3''400''L4''800''L5''1600''L6''4500''L7''9000''L8''25000''L9''50000''L10''100000''L11''200000''L12''300000''L13''500000''L14''800000''L15''1000000''C币规则（试运营）''什么是C币''查看详细C币规则''博客VIP文章说明''博主专享福利,发付费文章后可获得返利。''VIP文章即读者购买VIP付费后才可解锁阅读的文章，拥有VIP文章发表权限的作者可以发表VIP文章。''发VIP文章,根据文章购买转化数据返利(详见收益中心:''https://order.csdn.net/myorder/revenue''）''如何取消VIP可读：进入该篇文章的编辑页面，在“发布形式”模块取消选择“VIP可见”重新发布''博客专家''“博客专家”是CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定。''成为博客专家后会得到什么：''用户头像上显示“专家”勋章；''发布博客时可以直接引用CSDN站外的图片；''有机会免费参加CSDN举办的各种会议；''有机会成为CSDN学院讲师、CSDN博乐、CSDN问答导师等；''有更多演讲机会，CSDN会推荐给厂商或者各种IT技术大会作为演讲嘉宾；''享有月度原创奖励，C币、图书或定制礼品；''享有自定义模块、自定义域名、全站免广告等权益；''文章获得更多的推荐机会：博客专家所发的文章都会进入文章预选库，我们有专门的编辑负责从中筛选优质内容，并推荐到CSDN首页或其他内容频道。''注意情况：''所有博客专家（包括荣誉专家）均为实名制；''CSDN博客专家在三个月内如果没有发布任何原创或翻译博文，其博客专家身份将自动取消，转为博客频道荣誉专家，不能继续享有博客专家的福利；''CSDN博客专家不是CSDN博客的全职或兼职管理人员，不具备CSDN博客的管理权力，其观点及行为仅代表个人，不代表CSDN官方立场；''CSDN博客专家如有违反CSDN网站规则的行为，如大量发布广告或软文，对CSDN网站造成不良影响等，将永久取消其CSDN博客专家身份；希望恢复博客专家身份可重新申请，''点击这里申请博客专家''。''如何成为博客专家？''申请CSDN博客专家应具备的条件：''在CSDN坚持写作三年及以上；''原创技术文章总数超过100篇，并且最近6个月内有一定的活跃度；''博客文章总浏览量超过20万次以上，同时参考点赞、评论、收藏等交互数据；''原创文章占比80%以上，且文章内容有一定深度；''企业、团队等非个人开设的博客，需要原创技术文章总数超过150篇，并且最近一个月内发布了新的原创技术文章，博文总浏览量超30万次才能申请博客专家；''其他情况：''在CSDN学院成功发布过课程的博主可适当放宽要求；''如果已经在某IT领域具有较大影响力，但是尚没有达到上述申请条件的用户，可以通过现有博客专家或者CSDN编辑部的推荐，暂时成为“特约专家”，待达到上述条件之后，再转为正式的博客专家（申请用户自成为“特约专家”后六个月内如仍未达到CSDN博客专家应具备的条件，则“特约专家”身份取消）。''CSDN已开通博客专家在线申请功能，''点击这里申请博客专家''。''企业博客''CSDN企业博客旨在利用CSDN站内流量、内容、用户等资源，为技术型企业提供营销推广平台''企业博客免费版主要功能如下：''1、优质企业博文可提高推荐权重；''2、支持设置自定义主题图，方便更换企业品牌形象及广告图；''3、企业博客内无联盟广告展示；''4、企业博客有专属身份标识；''5、企业博客内的相关推荐内容为该企业自己的博文；''6、支持设置自定义背景色，支持添加自定义链接导航（目前最多可添加五个）；''7、支持百度关键词查询；''8、搜索专区。''如何开通企业博客''企业博客已经开通在线申请功能，''点击这里开通企业博客''CSDN管理员在收到您的申请后，会在2个工作日内开通服务。如有问题可以直接发信至tobblog@csdn.net咨询。''博客勋章''博客专家''CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定。成为博客专家后会得到我们一系列的服务，如在头像上加象征荣誉的专家勋章、有专人对接提供服务、文章获得更多的推荐机会、不定时获得CSDN的礼品、优先获得CSDN举办的各种会议的的门票等。''博客之星''授予在“CSDN年度博客之星评选”中获得“博客之星”称号的用户。为了鼓励专业、乐于分享的广大CSDN博客用户。每年12月的CSDN博客之星评选中，综合专家评审和大众投票的结果，评选出“CSDN年度博客之星”。''1024勋章''#1024程序员节#活动勋章，当日发布原创博客即可获得''1024超级勋章''授予原创文章总数达到1024篇的博主，感谢你对CSDN社区的贡献，CSDN与你一起成长。''勤写标兵Lv1''授予每个自然周发布1篇到3篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv2''授予每个自然周发布4篇到6篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv3''授予每个自然周发布7篇到8篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv4''授予每个自然周发布9篇以上（包括9篇）原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''分类专栏''分类专栏是把相同标签属性的技术博文聚集起来，集中展示，系统全面，更具目标性。CSDN鼓励每位博主撰写专属自己的专栏博文，构建自己的知识体系。''发布分类专栏建议：''1. 每个专栏至少发布10篇原创技术博文。''2. 博文紧扣专栏主题，技术定位清晰，内容扎实详尽。''CSDN博客频道编辑定期会把精华分类专栏荐给相应的受众群体。''博客搬家''CSDN是IT技术网站，欢迎大家发布原创或翻译IT技术类博客，非IT技术类博客将不提供搬家服务。博主可以''点击这里''申请博客搬家。''CSDN推出博客搬家功能，目前支持以下站点的博客搬迁：''博客园，微信公众号，简书，51CTO.com,新浪，开源中国，chinaUnix,个人博客，掘金，GitHub,知乎，segmentfault''。''温馨提示：''原创技术文章不能少于10篇方可申请。''原博客数据不会丢失，仍然保留。''如果检测到恶意导入，您的博客使用将会受到影响。''审核通过的搬家申请，会持续与搬家源进行内容同步（个人博客和github同步历史文章）。''审核时间一般为1个工作日，审核结果将通过站内信等方式告知。''同一个站点只允许进行1次搬家申请，如申请失败则需要重新申请。''对博客搬家有任何问题或建议请向博客客服邮箱发邮件咨询：webmaster@csdn.net。''声明：CSDN用户要完成博客搬家需要承诺搬迁的博客为用户本人博客，如搬迁非用户本人博客所产生的后果由用户本人承担。''自定义百度统计''申请方式''百度统计账号查询方式如下图所示''1）登录百度统计账号链接：''https://tongji.baidu.com/sc-web/home/site/getjs''2）路径是：管理/代码管理/代码获取''CSDN博客用户准则''总则：''第1条 CSDN博客隶属于CSDN（包括CSDN网站与相应客户端、自媒体平台、主运营网站等），是为中国的软件开发者、IT从业者及其他人员提供以交流IT技术为主的网络社区。''第2条 为保障CSDN博客健康发展，维护用户正当权益，规范信息发布行为，依据国家有关法律、法规、政策及CSDN相关规定，制定本博客用户准则（以下称“本准则”）。''第3条 CSDN经营者（即北京创新乐知网络技术有限公司及其他相关联的公司）无法对用户传播内容的权属、合法性、真实性、科学性、完整性等问题进行实质审查，博客用户须对自己发布的内容独立承担责任，CSDN经营者不承担因此产生的任何法律责任。''第4条 为保障CSDN博客的专业性与集成性，博客用户的交流不得涉及任何政治话题，CSDN博客用户须严格按照本准则的规定行使权利和履行义务。''博客注册''第1条 拟注册用户在CSDN博客进行注册时，需要按照提示填写详尽的用户信息（包括但不限于姓名或名称、身份证号码、邮箱、联系方式等），并对提供信息的真实性负责。在用户信息发生变动时，用户有责任及时更新、修改信息。如果博客用户提供的信息资料不准确，CSDN经营者保留终止用户使用CSDN博客提供的相关网络服务的权利。''第2条 CSDN博客用户因提供用户信息不真实、不准确等而发生纠纷或需要帮助时，因不能确认用户身份及其帐号的使用权利，无法向用户提供相应的帮助所带来的一切后果由用户自己承担。''第3条 CSDN经营者尊重用户隐私，未经用户合法授权，不会公开或透露其注册资料。''第4条 用户注册并激活成功后，便成为CSDN博客的正式用户，正式博客用户拥有CSDN博客规定用户所应享有的一切权限。用户将获得一个用户名和密码，用户对自己的用户名、密码及帐号安全性负全部责任。用户同意，若发现任何非法使用帐号、密码或存在安全漏洞等其它有损用户利益的情况，应立即通知CSDN经营者。每个用户都应对以其用户名进行的所有活动和事件负全部责任。''博客行为规则''第1条 CSDN博客用户享有言论自由的权利，但不得违反法律法规及政策规定，不得违反诚实信用原则及公序良俗，不得损害国家、CSDN经营者及第三方权利及利益，不得违反CSDN用户协议及相关规则。严禁发表含有下列内容的信息：''1.违反宪法确定的基本原则的；''2.危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；''3.损害国家荣誉和利益的；''4.煽动民族仇恨、民族歧视，破坏民族团结的；''5.破坏国家宗教政策，宣扬邪教和封建迷信的；''6.散布谣言，扰乱社会秩序，破坏社会稳定的；''7.散布淫秽、色情、赌博、暴力、恐怖或者教唆犯罪的；''8.侮辱或者诽谤他人，侵害他人合法权益的；''9.煽动非法集会、结社、游行、示威、聚众扰乱社会秩序的；''10.以非法民间组织名义活动的；''11.可能教唆他人犯罪的；''12.可能损害CSDN经营者名誉或商誉等权益的；''13.其他违反中华人民共和国法律、法规、政策，违反诚实信用及公序良俗，或CSDN经营者认为不当及不宜传播的信息。 CSDN博客用户违反上述规定的，CSDN经营者有权在不通知用户的情况下，根据其独立判断，采取删除已发表言论，暂停账户使用，直至取消用户资格等措施。''第2条 CSDN博客用户发表的文章、言论或其他信息仅代表其自身观点与立场，CSDN经营者不对用户发表内容的准确性、合法性、完整性负责。博客用户须承担一切因自己的行为而直接或间接导致的民事、行政或刑事法律责任。在任何情况下，CSDN经营者不承担因用户发表内容而引起的任何损失、损害的法律责任。''第3条 CSDN博客用户不得发布非IT技术内容。''第4条 未经CSDN经营者同意，禁止在博客发布与CSDN提供服务无关的广告。博客管理规则''第1条 CSDN博客的管理权限由博客管理员享有，博客管理员由CSDN经营者正式全职员工担任，并由其按照相关法律、法规、政策以及CSDN规则行使本博客全部站务管理职责和权利，管理员代表本博客官方立场，除管理员之外的任何用户及网友言论或行为，由相关人员自行承担，均与本博客无关。''第2条 用户恶意破坏CSDN博客版块正常秩序（包含但不限于恶意投票、刷流量、刷评论、利用自定义栏目传播病毒、垃圾广告、非法信息等）的，CSDN经营者有权视情节轻重给予警告、删帖、暂停账号使用、注销帐号等处理，并依法追究民事责任及其他法律责任。''被投诉侵权用户处理规则''第一次：封杀，解封时要求文章改为转载并注明出处''第二次：封杀一个月，给予严重警告，解封时要求文章改为转载并注明出处''第三次：不予解封''附则''第1条 CSDN提示博客用户，在用户与通过博客相识的其他用户进行交往时，应遵循谨慎原则。对于博客用户之间相识、交往所发生或可能发生的任何心理、身体上的伤害和经济上的损失与纠纷，由相关用户自行承担一切法律责任，CSDN经营者不承担任何法律责任。''第2条 本准则如存在与国家法律、法规或司法解释、政策等有冲突的条款，以届时有效的国家法律、法规或司法解释、政策等为准。本准则的其余条款仍然有效并具有约束力。''第3条 CSDN经营者有权对本准则进行修改，相关条款修改后，CSDN经营者将在相关页面公布修改的内容，修改后的条款一经公布即有效的代替原条款。用户如不同意相关条款的修改，可立即停止访问或使用CSDN博客或取消已经获得的服务；如用户选择在本准则修改后继续访问或使用CSDN博客，则视为用户已接受相关条款的修改。''第4条 用户接受本准则的内容，并不能完全涵盖用户使用CSDN博客所产生的权利和义务，CSDN经营者公布的其他声明、规则等均视为本准则之补充条款，为本准则不可分割的组成部分，与本准则具有同等法律效力。''第5条 本准则自发布之日起生效。''第6条 本准则最终解释权归北京创新乐知网络技术有限公司所有。''博客评论活跃等级规则（试运营）''评论活跃等级是CSDN对用户在博客评论区活跃程度的辨别标准，旨在鼓励读者和博主互动交流，提高用户活跃度。活跃等级规则具体如下（该规则适用于所有用户）：''1、所有用户初始评论次数均为零''2、活跃等级用评论次数衡量，评论次数越多，等级越高''3、超过10天没有进行任何评论，等级称谓变成“潜水”，初始评论次数清零''4、发布评论且审核通过后计算当前的有效评论数，根据当前的有效评论数展示不同的“评论等级称谓”''5、该规则从2020年4月23日起开始执行，在此之前进行的评论不予计算，仅计算该日期以后进行的有效评论''以下是评论次数对应的评论等级称谓''评论等级称谓''评论次数区间''潜水''0次''码哥''1-3次''码农''4-7次''码工''8-15次''码皇''16-31次''码神''32-63次''爱码士''64次以上''Markdown帮助''# 欢迎使用Markdown编辑器写博客''---------------------------''撤销：Ctrl/Command + Z''重做：Ctrl/Command + Y''加粗：Ctrl/Command + B''斜体：Ctrl/Command + I''标题：Ctrl/Command + Shift + H''无序列表：Ctrl/Command + Shift + U''有序列表：Ctrl/Command + Shift + O''检查列表：Ctrl/Command + Shift + C''插入代码：Ctrl/Command + Shift + K''插入链接：Ctrl/Command + Shift + L''插入图片：Ctrl/Command + Shift + G''标题''---------------------------''# 1级标题''## 2级标题''### 3级标题''#### 四级标题''##### 五级标题''###### 陆级标题''文本样式''---------------------------''*强调文本* _强调文本_''**加粗文本** __加粗文本__''==标记文本==''~~删除文本~~''> 引用文本''H~2~O is是液体。''2^10^ 运算结果是 1024。''列表''---------------------------''- 项目''* 项目''+ 项目''1. 项目1''2. 项目2''3. 项目3''- [ ] 计划任务''- [x] 完成任务''链接''---------------------------''链接: [link](https://mp.csdn.net).''图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg)''带尺寸的图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg =30x30)''代码片''---------------------------''下面展示一些 `内联代码片`。''```''// A code block'""var foo = 'bar';""'```''```javascript''// An highlighted block'""var foo = 'bar';""'```''1. 代码片必须手动声明代码语言类型''2. 目前支持代码类型: `markup`、`html`、`svg`、`xml`、`c`、`clike`、`cpp`、`csharp`、`java`、`vbnet`、`go`、`ruby/rb`、`python/py`、`php`、`sql`、`perl`、`objectivec`、`swift`、`javascript/js`、`css`、`handlebars`、`bash`、`kotlin`''3. 代码片主题''默认主题为：Atom One Dark''可以前往 [**写作中心/博客设置**](https://mp.csdn.net/configure) 在**代码片样式**项进行更改''表格''---------------------------''项目 | Value''-------- | -----''电脑 | $1600''手机 | $12''导管 | $1''| Column 1 | Column 2 |''|:--------:| -------------:|''| centered 文本居中 | right-aligned 文本居右 |''自定义列表''---------------------------''Markdown'': Text-to-HTML conversion tool''Authors'': John'': Luke''注脚''---------------------------''一个具有注脚的文本。[^1]''[^1]: 注脚的解释''注释''---------------------------''Markdown将文本转换为 HTML。''*[HTML]: 超文本标记语言''KaTex 数学公式''---------------------------''Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall''n\\in\\mathbb N$ 是通过 Euler integral''$$''\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.''$$''新的数学公式使用了KaTex，其语法与 LaTex基本一致，但也有一些不同的地方，具体请参考KaTex官方使用文档： [https://katex.org/docs/supported.html](https://katex.org/docs/supported.html)''插入甘特图''---------------------------''```mermaid''gantt''dateFormat YYYY-MM-DD''title Adding GANTT diagram functionality to mermaid''section 现有任务''已完成 :done, des1, 2014-01-06,2014-01-08''进行中 :active, des2, 2014-01-09, 3d''计划中 : des3, after des2, 5d''```''插入UML图''------------''```mermaid''sequenceDiagram''张三 ->> 李四: 你好！李四, 最近怎么样?''李四-->>王五: 你最近怎么样，王五？''李四--x 张三: 我很好，谢谢!''李四-x 王五: 我很好，谢谢!''Note right of 王五: 李四想了很长时间, 文字太长了''不适合放在一行.''李四-->>张三: 打量着王五...''张三->>王五: 很好... 王五, 你怎么样?''```''插入Mermaid流程图''--------''```mermaid''graph LR''A[长方形] -- 链接 --> B((圆))''A --> C(圆角长方形)''B --> D{菱形}''C --> D''```''插入Flowchart流程图''-------''```mermaid''flowchat''st=>start: 开始''e=>end: 结束''op=>operation: 我的操作''cond=>condition: 确认？''st->op->cond''cond(yes)->e''cond(no)->op''```''付费专栏开通规则''付费专栏是博主根据自己想变现的意愿而选择的一项可变现的产品，开通付费专栏事项须知：''付费专栏开通提交前，请认真阅读《CSDN付费专栏写作协议》，知晓双方的权利与义务''专栏文章需为原创文章且不少于15篇，每篇文章字数不得少于5000字（包括代码片段内字符数量）''专栏申请需提交审核，审核时间1-2个工作日''专栏定价，博主可以按照从系统已设定好的价格里选择定价''确保专栏内容无违规、违法、广告等不当内容''专栏一旦设置为收费，审核通过以后，无法取消，请谨慎操作'"
CSDN,https://blog.csdn.net/Dear_Mr/article/details/72871919,Vue项目webpack打包部署到服务器,Dear_Mr,Vue.js,,2017-06-05 22:01:35,"'Vue项目webpack打包部署到服务器''这篇博文主要说的就是我今天遇到的问题，而且在经过我的询问，好多人在打包部署的时候都遇到了一些问题，下面就来说下，如何将Vue项目放置在服务器上，这里以Tomcat为例。''必须要配置的就是/config/index.js''在vue-cli webpack的模板下的''/config/index.js''，我们可以看到''assetsPublicPath''这个键，并且这个东西还出现了''两次''，我第一次打包的时候，只是修改了最下面的''assetsPublicPath''，将它从'""'/'""'变为了''./''，然后我就执行了''npm run build''，打包成功之后，可以看到项目中会多出来一个文件夹，就是''dist''，里面有一个''static''文件夹和''index.html''，然后我就将''dist''目录下的文件拷贝到Tomcat服务器下，会发现访问到的是一个空白页面，但是当我把它放在''..\\webapps\\ROOT''目录下，它就可以访问了''Tomcat下面的目录结构：''但是这肯定是不行的，然后我就开始寻找答案，也根据别人的一些步骤做了下来，后来发现还是有一些问题的，没有办法访问到主页面，虽然吧，一直都没成功，但是我也没放弃，然后就综合了一下问答里面别人说的，进行了几次尝试，最后成功了。（给大家一个小建议：别放弃就好）。''下面的就是我的''config/index.js''的配置：''// see http://vuejs-templates.github.io/webpack for documentation.''var''path =''require''('""'path'""')\n\nmodule.exports = {\n  build: {\n    env:''require''('""'./prod.env'""'),\n    index: path.resolve(__dirname,'""'../dist/index.html'""'),\n    assetsRoot: path.resolve(__dirname,'""'../dist'""'),\n    assetsSubDirectory:'""'static'""',\n    assetsPublicPath:'""'./'""',\n    productionSourceMap:''true'',''// Gzip off by default as many popular static hosts such as''// Surge or Netlify already gzip all static assets for you.''// Before setting to `true`, make sure to:''// npm install --save-dev compression-webpack-plugin''productionGzip:''false'',\n    productionGzipExtensions: ['""'js'""','""'css'""'],''// Run the build command with an extra argument to''// View the bundle analyzer report after build finishes:''// `npm run build --report`''// Set to `true` or `false` to always turn it on or off''bundleAnalyzerReport: process.env.npm_config_report\n  },\n  dev: {\n    env:''require''('""'./dev.env'""'),\n    port:''8080'',\n    autoOpenBrowser:''true'',\n    assetsSubDirectory:'""'static'""',\n    assetsPublicPath:'""'./'""',\n    proxyTable: {},''// CSS Sourcemaps off by default because relative paths are ""buggy""''// with this option, according to the CSS-Loader README''// (https://github.com/webpack/css-loader#sourcemaps)''// In our experience, they generally work as expected,''// just be aware of this issue when enabling this option.''cssSourceMap:''false''}\n}''可以发现，我就改了两处，就是assetsPublicPath所对应的值，我这里用的是''./''，我也用webapps下的命的项目名试过，只是没得到我想要的结果，后来我还是改成了''./''使用vue-router的情况''当你在项目中使用''vue-router''的时候，就需要给''src/router/index.js''添点东西，如下面：''export''default''new''Router({\n  mode :'""'history'""',\n  base:'""'/ttms/'""',''//添加的地方''...\n }''然后执行''npm run dev''，将打包后的文件放在Tomcat的目录下的WebApps下的ttms中，然后，就可以访问到了：''http://localhost:8080/ttms/'"
CSDN,https://blog.csdn.net/dichi4045/article/details/102444427,mysql 授权命令,dichi4045,数据库,,2018-07-15 22:17:00,"'MySQL清空数据库的操作：truncate table tablename;''MySQL\xa0赋予用户权限命令的简单格式可概括为：grant\xa0权限\xa0on\xa0数据库对象\xa0to\xa0用户''一、grant\xa0普通数据用户，查询、插入、更新、删除\xa0数据库中所有表数据的权利。'""1 grant select on testdb.* to common_user@'%'  grant insert on testdb.* to common_user@'%'  grant update on testdb.* to common_user@'%'  grant delete on testdb.* to common_user@'%'  \n2 或者，用一条 MySQL 命令来替代： \n3 grant select, insert, update, delete on testdb.* to common_user@'%'""'二、grant\xa0数据库开发人员，创建表、索引、视图、存储过程、函数。。。等权限。''grant\xa0创建、修改、删除\xa0MySQL\xa0数据表结构权限'""1 grant create on testdb.* to developer@'192.168.0.%' ; \n2 grant alter  on testdb.* to developer@'192.168.0.%' ; \n3 grant drop   on testdb.* to developer@'192.168.0.%' ;""'grant\xa0操作\xa0MySQL\xa0外键权限'""grant references on testdb.* to developer@'192.168.0.%' ;""'grant\xa0操作\xa0MySQL\xa0临时表权限'""grant create temporary tables on testdb.* to developer@'192.168.0.%' ;""'grant\xa0操作\xa0MySQL\xa0索引权限'""grant index on  testdb.* to developer@'192.168.0.%' ;""'grant\xa0操作\xa0MySQL\xa0视图、查看视图源代码权限'""grant create view on testdb.* to developer@'192.168.0.%' ; \ngrant show   view on testdb.* to developer@'192.168.0.%' ;""'grant\xa0操作\xa0MySQL\xa0存储过程、函数权限'""1 grant create routine on testdb.* to developer@'192.168.0.%' ;  -- now, can show procedure status \n2 grant alter  routine on testdb.* to developer@'192.168.0.%' ;  -- now, you can drop a procedure \n3 grant execute        on testdb.* to developer@'192.168.0.%' ;""'三、grant\xa0普通\xa0DBA\xa0管理某个\xa0MySQL\xa0数据库的权限'""grant all privileges on testdb to dba@'localhost'  其中，关键字 “privileges” 可以省略。""'四、grant\xa0高级\xa0DBA\xa0管理\xa0MySQL\xa0中所有数据库的权限'""grant all on *.* to dba@'localhost'""'五、MySQL\xa0grant\xa0权限，分别可以作用在多个层次上''1.\xa0grant\xa0作用在整个\xa0MySQL\xa0服务器上：''grant select on *.* to dba@localhost ; -- dba 可以查询 MySQL 中所有数据库中的表。 \ngrant all    on *.* to dba@localhost ; -- dba 可以管理 MySQL 中的所有数据库''2.\xa0grant\xa0作用在单个数据库上：''grant select on testdb.* to dba@localhost ; -- dba 可以查询 testdb 中的表。''3.\xa0grant\xa0作用在单个数据表上：''grant select, insert, update, delete on testdb.orders to dba@localhost ;''4.\xa0grant\xa0作用在表中的列上：''grant select(id, se, rank) on testdb.apache_log to dba@localhost ;''5.\xa0grant\xa0作用在存储过程、函数上：'""grant execute on procedure testdb.pr_add to 'dba'@'localhost'  \ngrant execute on function  testdb.fn_add to 'dba'@'localhost'""'六、查看\xa0MySQL\xa0用户权限\xa0查看当前用户（自己）权限：\xa0show\xa0grants;''查看其他\xa0MySQL\xa0用户权限：\xa0show\xa0grants\xa0for''dba@localhost'';''七、撤销已经赋予给\xa0MySQL\xa0用户权限的权限''revoke 跟 grant 的语法差不多，只需要把关键字 “to” 换成 “from” 即可： \ngrant  all on *.* to   dba@localhost; \nrevoke all on *.* from dba@localhost;''八、MySQL\xa0grant、revoke\xa0用户权限注意事项''1.\xa0grant,\xa0revoke\xa0用户权限后，该用户只有重新连接\xa0MySQL\xa0数据库，权限才能生效。''2.\xa0如果想让授权的用户，也可以将这些权限\xa0grant\xa0给其他用户，需要选项\xa0“grant\xa0option“''grant\xa0select\xa0on\xa0testdb.*\xa0to''dba@localhost''with\xa0grant\xa0option;\xa0这个特性一般用不到。实际中，数据库权限最好由\xa0DBA\xa0来统一管理。''九 .''FLUSH\xa0\xa0 PRIVILEGES;\xa0 这样权限才会生效\xa0不然要重新连接数据库\xa0或者重启数据库''转载于:https://www.cnblogs.com/zengpeng/p/9315242.html'"
CSDN,https://blog.csdn.net/llew2011/article/details/52822148,Android 源码系列之<十>从源码的角度深入理解AccessibilityService，打造自己的APP小外挂(上),llew2011,Android 源码系列,,2016-10-24 17:55:03,"'转载请注明出处：''http://blog.csdn.net/llew2011/article/details/52822148''说起外挂特别是玩游戏的小伙伴估计对它很熟悉，肯定有部分小伙伴使用过，至于为什么使用它，你懂得(*^__^*) ……我最早接触外挂是在大二的时候，那时候盛行玩QQ农场，早上一睁眼就是打开电脑先把自己的菜收了，收完之后再去偷别人的；后来童靴说非凡软件上有一个偷菜外挂，于是赶紧整了一个，有了外挂之后就告别了体力时代，省时又省力……既然在PC上有外挂，那在智能手机上可以做外挂呢？答案是OK的，今天这篇文章就是讲解一下如何在Android设备上制作自己的小外挂，需要说明的是本文仅仅做技术交流……''产生做外挂的念头是在去年春节时支付宝推的咻一咻咻大奖活动，那时候每到咻一咻的时间点就赶紧打开支付宝进入咻一咻页面然后不停的点击咻一咻按钮，后来我就想与其这样一直重复点击按钮不如花点时间整个咻一咻小外挂，于是花了小半天时间写了一个，经过实践发现效果还挺理想的……其实在Android设备上制作小外挂并不是多么高深的技术，核心就是利用AccessibilityService，如果你对该类已经很熟悉，请跳过本文(*^__^*) ……''AccessibilityService是Google为了方便那些身体不便的用户来使用Android设备而提供的一种无障碍服务，该服务可以帮助那些身体不便的用户更加简单的使用和操作Android设备，这些操作包括文字转语音，触觉反馈，收拾操作，轨迹球和手柄操作等。AccessibilityService提供的这种服务就是用来监听指定的应用的，例如监听指定应用页面内容的边界，页面的跳转，焦点的变化等等。因此我们可以利用该服务做我们想做的小外挂，比如自动安装APP，抢红包外挂还有我之前写的咻一咻外挂，今天我们就讲解一下如何利用AccessibilityService来实现自动安装APP的小外挂。''AccessibilityService是Service的子类，但是它的声明周期是由系统来管理的，那也就是说我们要想启动该服务就不能够像平时那样直接startService()了而是需要在Android设备的辅助功能列表中手动开启该服务，当开启该服务后其生命周期就交由系统来管理和维护了。需要注意的是虽然不需要通过startService()等方式来启动AccessibilityService服务，但是AccessibilityService依然是需要在配置文件AndroidManifest.xml中配置。由于AccessibilityService是抽象类不能直接使用，所以需要先自定义一个类来继承AccessibilityService，自定义AutoInstallApkService服务类代码如下：''public class AutoInstallApkService extends AccessibilityService {\n\n    @Override\n    public void onAccessibilityEvent(AccessibilityEvent event) {\n        // 事件入口处\n    }\n\n    @Override\n    public void onInterrupt() {\n    }\n}''AutoInstallApkService重写了AccessibilityServiced的俩抽象方法，onAccessibilityEvent()方法表示该服务接收系统传递进来的辅助事件(该事件可能是当前窗口内容发生变化触发的，也可能是当前窗口焦点发生变化触发的，还有可能是系统弹出Notification触发的等等)，该方法为事件入口，每当监听的指定应用触发了指定事件的时候都会回调此方法。而onInterrupt()方法表示服务中断发生的回调，服务中断意味着不能接收回调了，但是可以在方法中做些相关业务等操作。''定义完了我们的AutoInstallApkService服务后，接下就是在AndroidManifest.xml文件中配置该服务了，根据官方文档，配置文件如下：''<?xml version=""1.0"" encoding=""utf-8""?>\n<manifest xmlns:android=""http://schemas.android.com/apk/res/android""\n    package=""com.llew.wb.project.service.accessibility.installapk"">\n\n    <application\n        android:allowBackup=""true""\n        android:icon=""@mipmap/ic_launcher""\n        android:label=""@string/app_name""\n        android:supportsRtl=""true""\n        android:theme=""@style/AppTheme"">\n        <activity android:name="".ui.activity.MainActivity"">\n            <intent-filter>\n                <action android:name=""android.intent.action.MAIN"" />\n\n                <category android:name=""android.intent.category.LAUNCHER"" />\n            </intent-filter>\n        </activity>\n\n        <service\n            android:name="".ui.service.AutoInstallApkService""\n            android:label=""@string/app_name""\n            android:permission=""android.permission.BIND_ACCESSIBILITY_SERVICE"">\n            <intent-filter>\n                <action android:name=""android.accessibilityservice.AccessibilityService"" />\n            </intent-filter>\n            <meta-data\n                android:name=""android.accessibilityservice""\n                android:resource=""@xml/accessibility_service_config"" />\n        </service>\n    </application>\n\n</manifest>''在配置文件中配置了我们的AutoInstallApkService服务，配置服务的时候需要注意以下几点：''添加label标签''AutoInstallApkService需要添加''label''标签，标签表示服务的名字，应用安装后会在手机辅助功能的列表中显示，若没定义标签则不显示''添加系统权限''系统权限''android:permission''=''""android.permission.BIND_ACCESSIBILITY_SERVICE""''是一定要添加的，否则该服务会被系统忽略''添加过滤器''一定要添加intent为的''android:name''=''""android.accessibilityservice.AccessibilityService""''过滤器，否则该服务会被系统忽略''meta-data配置文件''meta-data''中''android:name''表示配置的服务名称，值是固定写法不能修改，''android:resource''表示引用的具体配置文件，本例引用的是accessibility_service_config.xml文件【注意：此配置是在4.0版本之后的写法，在低版本中可使用另一种写法，稍后会有讲解】''看完了manifest配置文件后，我们看一下在res目录下的xml文件夹中的accessibility_service_config.xml文件，代码如下：''<?xml version=""1.0"" encoding=""utf-8""?>\n<accessibility-service xmlns:android=""http://schemas.android.com/apk/res/android""\n    android:accessibilityEventTypes=""typeAllMask""\n    android:accessibilityFeedbackType=""feedbackAllMask""\n    android:accessibilityFlags=""flagDefault""\n    android:canRetrieveWindowContent=""true""\n    android:description=""@string/app_name""\n    android:notificationTimeout=""100""\n    android:packageNames=""com.android.packageinstaller"" />''在accessibility_service_config.xml中根元素为''accessibility-service''为，这是固定写法不能更改；各属性值的说明如下：''android:accessibilityEventTypes''该属性表示当前AutoInstallApkService服务接收的事件类型，typeAllMask表示接收所有的事件类型，常见的事件有：typeWindowContentChanged(窗口内容发生变化的事件)，typeWindowStateChanged(窗口焦点发生变化的事件)，typeNotificationStateChanged(弹出Notification的事件)等等，如果想了解更多的辅助事件可参阅官方文档''android:accessibilityFeedbackType''该属性表示设置反馈给用户的方式，常见的有语音播报，手机振动等''android:canRetrieveWindowContent''该属性表示是否可以获取当前窗口内容，true表示可以获取否则不可以获取''android:description''表示对当前辅助功能的描述，该值会在Android设置的辅助列表中显示''android:notificationTimeout''表示响应时间，目前设置为100毫秒''android:packageNames''表示当前辅助服务需要监听的应用包名，目前我们是实现自动安装外挂，而安装应用是调用系统的Installer应用，该应用的包名为com.android.packageinstaller，如果想要监听多个应用，中间加逗号。''好了，配置完了我们的AutoInstallApkService服务后，接下来是实现具体的安装APK的逻辑了。我们知道在Android设备上安装应用的时候会弹出一个安装确认页面，只有确认后安装才会继续执行……这其实是调用系统默认的PackageInstaller安装器(需要指出的是这个APK是第三方的应用，系统应用的安装可以不通过PackageInstaller来安装)。在PackageInstaller安装界面的操作流程一般是：是否允许安装 → 正在进行安装 → 安装完成确认；这三个安装流程的界面是不一样的，拿中国移动的APK来举个栗子，如下图所示：''上图分别展示了在Android手机上安装APP应用时调用系统安装器PackageInstaller不同状态时的样式，我们的自动安装应用小外挂就是当出现了这以上页面中的任一个时我们该外观都能自动来执行安装流程，既然是自动安装也就是说当出现了这些按钮时我们的外挂能主动的执行按钮的点击操作，这样就省去了人为的手动点击操作，这也是外挂的核心作用。由于PackageInstaller的页面发生了变化都会回调AutoInstallApkService的onAccessibilityEvent()方法，因此我们可以在该方法中来模拟用户的操作，要模拟点击操作就要得到对应的按钮，然后执行按钮的点击事件；那怎么样才能得到目标按钮这个对象呢？在AccessibilityService中提供了一个getRootInActiveWindow()方法，该方法返回一个代表当前活动窗口的根节点AccessibilityNodeInfo实例对象，该对象保存了当前窗口界面的相关信息，比如控件在窗口的位置信息，id信息，文本信息，类型信息，文本信息等等，它和ViewGroup类似，对外提供了诸如findAccessibilityNodeInfosByViewId()，findAccessibilityNodeInfosByText()，performAction()等方法。其中findAccessibilityNodeInfosByViewId()是4.3版本之后的新增方法，表示根据给定控件的ID来获取到对应控件，获取到对应控件后就可以通过performAction()方法来执行点击事件了，那怎么获取到指定控件的ID呢？''在Android的sdk目录中有个tools目录，在该目录下有个uiautomatorviewer工具，该工具很有用，特别是分析apk的页面布局信息，它可以获取到当前手机屏幕上的界面信息，如下图所示：''在上图中我们通过uiautomatorviewer工具展示了安装APP的界面信息。左侧表示截屏信息，当点击界面上的相关控件的时候，右侧就会出现该控件的相关信息，比如id，text，package，class，clickable等，而这个ID就是我们想要的id，又因为在一个页面上id是唯一的，所以只要我们获取到了所有的符合条件的ID后就可以通过该id获取到对应的AccessibilityNodeInfo对象了，然后通过调用该对象的performAction()方法就可以实现自动点击效果了。通过uiautomatorviewer工具找到所有操作按钮的id后，就可以在我们的AutoInstallApkService的onAccessibilityEvent()方法中做操作了，代码如下：''public class AutoInstallApkService extends AccessibilityService {\n\n    private static final String DEFAULT_PACKAGE_NAME = ""com.android.packageinstaller"";\n    \n    private static final String[] IDS = {\n            ""com.android.packageinstaller:id/ok_button"",        // 下一步按钮的ID，注意ID的格式，必须这样写\n            ""com.android.packageinstaller:id/done_button"",      // 完成按钮的ID，注意ID的格式，必须这样写\n            ""com.android.packageinstaller:id/confirm_button""    // 确认按钮的ID，注意ID的格式，必须这样写\n    };\n\n    @Override\n    public void onAccessibilityEvent(AccessibilityEvent event) {\n        if (null == event) return;\n        installApkIfNecessary(event);\n        recycleAccessibilityEvent(event);\n    }\n\n    private void installApkIfNecessary(AccessibilityEvent event) {\n        AccessibilityNodeInfo rootInfo = getRootInActiveWindow();\n        if (null == rootInfo) return;\n        String packageName = rootInfo.getPackageName().toString();\n        if (DEFAULT_PACKAGE_NAME.equals(packageName)) {\n            int length = IDS.length;\n            AccessibilityNodeInfo availableNode = null;\n            for (int i = 0; i < length; i++) {\n                availableNode = findAvailableNodeInfoByViewId(rootInfo, IDS[i]);\n                if (null != availableNode) {\n                    break;\n                }\n            }\n            if (null != availableNode) {\n                performClickWithAccessibilityNode(availableNode);\n            }\n        }\n    }\n\n    private AccessibilityNodeInfo findAvailableNodeInfoByViewId(AccessibilityNodeInfo root, String id) {\n        List<AccessibilityNodeInfo> availableNodes = root.findAccessibilityNodeInfosByViewId(id);\n        if (null == availableNodes || availableNodes.isEmpty()) {\n            return null;\n        }\n        return availableNodes.get(0);\n    }\n\n    private void performClickWithAccessibilityNode(AccessibilityNodeInfo nodeInfo) {\n        if (null != nodeInfo) {\n            if (nodeInfo.isClickable()) {\n                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n            } else {\n                performClickWithAccessibilityNode(nodeInfo.getParent());\n            }\n        }\n    }\n\n    @Override\n    public void onInterrupt() {\n    }\n\n    private void recycleAccessibilityEvent(AccessibilityEvent event) {\n        if (null != event) {\n            event.recycle();\n            event = null;\n        }\n    }\n}''以上就是我们AutoInstallApkService的全部代码，相信小伙伴们都看的懂，DEFAULT_PACKAGE_NAME表示监听应用的包名，IDS表示需要点击的所有的ID控件集合，在onAccessibilityEvent()方法中我们首先判断传递进来的event是否非空，如果非空就执行installApkIfNecessary()方法，在该方法中先获取根节点rootInfo，然后循环IDS通过调用rootInfo的findAccessibilityNodeInfosByViewId()方法找到对应的控件节点，如果找到了对应节点就调用performClickWithAccessibilityNode()方法来执行点击动作，需要注意的是在performClickWithAccessibilityNode()方法中如果当前控件不可点击我们就递归调用找其父控件来执行点击事件，只所以这么做是为了避免为了扩大点击面积我们往往在当前控件外嵌套一个父布局然后使父布局来响应点击事件的情况存在(因为之前在做抢红包外挂时碰见这种情况)。''好了，现在我们的自动安装APP的外挂已经完成，接下来运行在手机上后要在手机的辅助功能列表中开启该服务，否则该服务不起作用，操作截图如下：''开启了AutoInstallApkService服务后，就可以在手机上尝试安装一个APP看看效果了。因为我们的AutoInstallApkService是监听的系统的PackageInstaller应用，所以只要我们点击了已经下载过的APP后都是可以调用此应用的，直接点击一个应用，效果如下：''根据截图效果来看，安装APP时的操作流程都可以自动完成，运行结果也达到了我们的预期，这就是在手机上做的一个小外挂，是不是很简单？(*^__^*) ……其实外挂听起来很高大上，但只要了解了它的核心思想，做一个小外挂出来还是很容易的(就像当时我写了一个咻一咻外挂)，现在想想当年的偷菜外挂猜测应该也是借助了系统的辅助功能来实现的吧。''好了，到这里有关自动安装APP的小外挂实验已经结果了，在下篇文章''Android 源码系列之<十一>从源码的角度深入理解AccessibilityService，打造自己的APP小外挂(下)''中，我将带领小伙伴们们从源码出发深入理解一下AccessibilityService的执行原理，敬请期待！！！最后感谢观看(*^__^*) ……'"
CSDN,https://blog.csdn.net/jett2357/article/details/84965870,AccessibilityService用法,chengyuan9160,android,,2018-12-12 10:51:33,"'AccessibilityService用法''如何启动第三方的Demo程序，并模拟点击“ONE”按钮？''做法是在当前的App中通过包名启动第三方Demo程序，并配置AccessibilityService服务，通过AccessibilityService监听窗口变化，使用findAccessibilityNodeInfosByText找到要点击的按钮，调用performClick完成点击操作；比如早些年的红包插件、微信自动回复插件、自动点赞插件等都是这么实现的。''1.首先定义access_srv_config''packageNames指定需要监控的App的包名，可以是多个。""com.ricky.demo""就是当前第三方demo的包名；''// @xml/access_srv_config''<?xml version=""1.0"" encoding=""utf-8""?>''<''accessibility-service''xmlns:''android''=''""''http://schemas.android.com/apk/res/android''""''android:''description''=''""''@string/app_name''""''android:''accessibilityEventTypes''=''""''typeWindowStateChanged|typeWindowContentChanged''""''android:''accessibilityFeedbackType''=''""''feedbackAllMask''""''android:''packageNames''=''""''com.ricky.demo''""''android:''notificationTimeout''=''""''10''""''android:''accessibilityFlags''=''""''""''android:''canRetrieveWindowContent''=''""''true''""''/>''2.在manifest.xml中配置service''<''service android'':''exported''=''""false""''android'':''label''=''""自动点击Demo""''android'':''name''=''"".AccessClickSrv""''android'':''permission''=''""android.permission.BIND_ACCESSIBILITY_SERVICE""''>''<''intent''-''filter''>''<''action android'':''name''=''""android.accessibilityservice.AccessibilityService""''/''>''<''/''intent''-''filter''>''<''meta''-''data\n          android'':''name''=''""android.accessibilityservice""''android'':''resource''=''""@xml/access_srv_config""''/''>''<''/''service''>''3.AccessClickSrv实现''public''class''AccessClickSrv''extends''AccessibilityService''{''private''static''final''String TAG''=''""GK""'';''@Override''protected''void''onServiceConnected''('')''{''super''.''onServiceConnected''('')'';''}''@Override''public''void''onAccessibilityEvent''(''AccessibilityEvent event'')''{''try''{''AccessibilityNodeInfo rootInfo''=''getRootInActiveWindow''('')'';''if''(''rootInfo''==''null'')''{''return'';''}''List''<''AccessibilityNodeInfo''>''list''=''rootInfo''.''findAccessibilityNodeInfosByText''(''""ONE""'')'';''performClick''(''list''.''get''(''0'')'')'';''}''catch''(''Exception''e'')''{''}''}''@Override''public''void''onInterrupt''('')''{''}''private''void''performClick''(''AccessibilityNodeInfo targetInfo'')''{''targetInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_CLICK'')'';''}''}''//启动服务''Intent intent''=''new''Intent''(''this'',''AccessClickSrv''.''class'')'';''startService''(''intent'')'';''需要手动进入辅助功能，将“自动点击demo”权限授予当前App，如下：'"
CSDN,https://blog.csdn.net/jett2357/article/details/84965870,AccessibilityService用法,chengyuan9160,android,,2018-12-12 10:51:33,"'AccessibilityService用法''如何启动第三方的Demo程序，并模拟点击“ONE”按钮？''做法是在当前的App中通过包名启动第三方Demo程序，并配置AccessibilityService服务，通过AccessibilityService监听窗口变化，使用findAccessibilityNodeInfosByText找到要点击的按钮，调用performClick完成点击操作；比如早些年的红包插件、微信自动回复插件、自动点赞插件等都是这么实现的。''1.首先定义access_srv_config''packageNames指定需要监控的App的包名，可以是多个。""com.ricky.demo""就是当前第三方demo的包名；''// @xml/access_srv_config''<?xml version=""1.0"" encoding=""utf-8""?>''<''accessibility-service''xmlns:''android''=''""''http://schemas.android.com/apk/res/android''""''android:''description''=''""''@string/app_name''""''android:''accessibilityEventTypes''=''""''typeWindowStateChanged|typeWindowContentChanged''""''android:''accessibilityFeedbackType''=''""''feedbackAllMask''""''android:''packageNames''=''""''com.ricky.demo''""''android:''notificationTimeout''=''""''10''""''android:''accessibilityFlags''=''""''""''android:''canRetrieveWindowContent''=''""''true''""''/>''2.在manifest.xml中配置service''<''service android'':''exported''=''""false""''android'':''label''=''""自动点击Demo""''android'':''name''=''"".AccessClickSrv""''android'':''permission''=''""android.permission.BIND_ACCESSIBILITY_SERVICE""''>''<''intent''-''filter''>''<''action android'':''name''=''""android.accessibilityservice.AccessibilityService""''/''>''<''/''intent''-''filter''>''<''meta''-''data\n          android'':''name''=''""android.accessibilityservice""''android'':''resource''=''""@xml/access_srv_config""''/''>''<''/''service''>''3.AccessClickSrv实现''public''class''AccessClickSrv''extends''AccessibilityService''{''private''static''final''String TAG''=''""GK""'';''@Override''protected''void''onServiceConnected''('')''{''super''.''onServiceConnected''('')'';''}''@Override''public''void''onAccessibilityEvent''(''AccessibilityEvent event'')''{''try''{''AccessibilityNodeInfo rootInfo''=''getRootInActiveWindow''('')'';''if''(''rootInfo''==''null'')''{''return'';''}''List''<''AccessibilityNodeInfo''>''list''=''rootInfo''.''findAccessibilityNodeInfosByText''(''""ONE""'')'';''performClick''(''list''.''get''(''0'')'')'';''}''catch''(''Exception''e'')''{''}''}''@Override''public''void''onInterrupt''('')''{''}''private''void''performClick''(''AccessibilityNodeInfo targetInfo'')''{''targetInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_CLICK'')'';''}''}''//启动服务''Intent intent''=''new''Intent''(''this'',''AccessClickSrv''.''class'')'';''startService''(''intent'')'';''需要手动进入辅助功能，将“自动点击demo”权限授予当前App，如下：'"
CSDN,https://blog.csdn.net/llew2011/article/details/52822148,Android 源码系列之<十>从源码的角度深入理解AccessibilityService，打造自己的APP小外挂(上),llew2011,Android 源码系列,,2016-10-24 17:55:03,"'转载请注明出处：''http://blog.csdn.net/llew2011/article/details/52822148''说起外挂特别是玩游戏的小伙伴估计对它很熟悉，肯定有部分小伙伴使用过，至于为什么使用它，你懂得(*^__^*) ……我最早接触外挂是在大二的时候，那时候盛行玩QQ农场，早上一睁眼就是打开电脑先把自己的菜收了，收完之后再去偷别人的；后来童靴说非凡软件上有一个偷菜外挂，于是赶紧整了一个，有了外挂之后就告别了体力时代，省时又省力……既然在PC上有外挂，那在智能手机上可以做外挂呢？答案是OK的，今天这篇文章就是讲解一下如何在Android设备上制作自己的小外挂，需要说明的是本文仅仅做技术交流……''产生做外挂的念头是在去年春节时支付宝推的咻一咻咻大奖活动，那时候每到咻一咻的时间点就赶紧打开支付宝进入咻一咻页面然后不停的点击咻一咻按钮，后来我就想与其这样一直重复点击按钮不如花点时间整个咻一咻小外挂，于是花了小半天时间写了一个，经过实践发现效果还挺理想的……其实在Android设备上制作小外挂并不是多么高深的技术，核心就是利用AccessibilityService，如果你对该类已经很熟悉，请跳过本文(*^__^*) ……''AccessibilityService是Google为了方便那些身体不便的用户来使用Android设备而提供的一种无障碍服务，该服务可以帮助那些身体不便的用户更加简单的使用和操作Android设备，这些操作包括文字转语音，触觉反馈，收拾操作，轨迹球和手柄操作等。AccessibilityService提供的这种服务就是用来监听指定的应用的，例如监听指定应用页面内容的边界，页面的跳转，焦点的变化等等。因此我们可以利用该服务做我们想做的小外挂，比如自动安装APP，抢红包外挂还有我之前写的咻一咻外挂，今天我们就讲解一下如何利用AccessibilityService来实现自动安装APP的小外挂。''AccessibilityService是Service的子类，但是它的声明周期是由系统来管理的，那也就是说我们要想启动该服务就不能够像平时那样直接startService()了而是需要在Android设备的辅助功能列表中手动开启该服务，当开启该服务后其生命周期就交由系统来管理和维护了。需要注意的是虽然不需要通过startService()等方式来启动AccessibilityService服务，但是AccessibilityService依然是需要在配置文件AndroidManifest.xml中配置。由于AccessibilityService是抽象类不能直接使用，所以需要先自定义一个类来继承AccessibilityService，自定义AutoInstallApkService服务类代码如下：''public class AutoInstallApkService extends AccessibilityService {\n\n    @Override\n    public void onAccessibilityEvent(AccessibilityEvent event) {\n        // 事件入口处\n    }\n\n    @Override\n    public void onInterrupt() {\n    }\n}''AutoInstallApkService重写了AccessibilityServiced的俩抽象方法，onAccessibilityEvent()方法表示该服务接收系统传递进来的辅助事件(该事件可能是当前窗口内容发生变化触发的，也可能是当前窗口焦点发生变化触发的，还有可能是系统弹出Notification触发的等等)，该方法为事件入口，每当监听的指定应用触发了指定事件的时候都会回调此方法。而onInterrupt()方法表示服务中断发生的回调，服务中断意味着不能接收回调了，但是可以在方法中做些相关业务等操作。''定义完了我们的AutoInstallApkService服务后，接下就是在AndroidManifest.xml文件中配置该服务了，根据官方文档，配置文件如下：''<?xml version=""1.0"" encoding=""utf-8""?>\n<manifest xmlns:android=""http://schemas.android.com/apk/res/android""\n    package=""com.llew.wb.project.service.accessibility.installapk"">\n\n    <application\n        android:allowBackup=""true""\n        android:icon=""@mipmap/ic_launcher""\n        android:label=""@string/app_name""\n        android:supportsRtl=""true""\n        android:theme=""@style/AppTheme"">\n        <activity android:name="".ui.activity.MainActivity"">\n            <intent-filter>\n                <action android:name=""android.intent.action.MAIN"" />\n\n                <category android:name=""android.intent.category.LAUNCHER"" />\n            </intent-filter>\n        </activity>\n\n        <service\n            android:name="".ui.service.AutoInstallApkService""\n            android:label=""@string/app_name""\n            android:permission=""android.permission.BIND_ACCESSIBILITY_SERVICE"">\n            <intent-filter>\n                <action android:name=""android.accessibilityservice.AccessibilityService"" />\n            </intent-filter>\n            <meta-data\n                android:name=""android.accessibilityservice""\n                android:resource=""@xml/accessibility_service_config"" />\n        </service>\n    </application>\n\n</manifest>''在配置文件中配置了我们的AutoInstallApkService服务，配置服务的时候需要注意以下几点：''添加label标签''AutoInstallApkService需要添加''label''标签，标签表示服务的名字，应用安装后会在手机辅助功能的列表中显示，若没定义标签则不显示''添加系统权限''系统权限''android:permission''=''""android.permission.BIND_ACCESSIBILITY_SERVICE""''是一定要添加的，否则该服务会被系统忽略''添加过滤器''一定要添加intent为的''android:name''=''""android.accessibilityservice.AccessibilityService""''过滤器，否则该服务会被系统忽略''meta-data配置文件''meta-data''中''android:name''表示配置的服务名称，值是固定写法不能修改，''android:resource''表示引用的具体配置文件，本例引用的是accessibility_service_config.xml文件【注意：此配置是在4.0版本之后的写法，在低版本中可使用另一种写法，稍后会有讲解】''看完了manifest配置文件后，我们看一下在res目录下的xml文件夹中的accessibility_service_config.xml文件，代码如下：''<?xml version=""1.0"" encoding=""utf-8""?>\n<accessibility-service xmlns:android=""http://schemas.android.com/apk/res/android""\n    android:accessibilityEventTypes=""typeAllMask""\n    android:accessibilityFeedbackType=""feedbackAllMask""\n    android:accessibilityFlags=""flagDefault""\n    android:canRetrieveWindowContent=""true""\n    android:description=""@string/app_name""\n    android:notificationTimeout=""100""\n    android:packageNames=""com.android.packageinstaller"" />''在accessibility_service_config.xml中根元素为''accessibility-service''为，这是固定写法不能更改；各属性值的说明如下：''android:accessibilityEventTypes''该属性表示当前AutoInstallApkService服务接收的事件类型，typeAllMask表示接收所有的事件类型，常见的事件有：typeWindowContentChanged(窗口内容发生变化的事件)，typeWindowStateChanged(窗口焦点发生变化的事件)，typeNotificationStateChanged(弹出Notification的事件)等等，如果想了解更多的辅助事件可参阅官方文档''android:accessibilityFeedbackType''该属性表示设置反馈给用户的方式，常见的有语音播报，手机振动等''android:canRetrieveWindowContent''该属性表示是否可以获取当前窗口内容，true表示可以获取否则不可以获取''android:description''表示对当前辅助功能的描述，该值会在Android设置的辅助列表中显示''android:notificationTimeout''表示响应时间，目前设置为100毫秒''android:packageNames''表示当前辅助服务需要监听的应用包名，目前我们是实现自动安装外挂，而安装应用是调用系统的Installer应用，该应用的包名为com.android.packageinstaller，如果想要监听多个应用，中间加逗号。''好了，配置完了我们的AutoInstallApkService服务后，接下来是实现具体的安装APK的逻辑了。我们知道在Android设备上安装应用的时候会弹出一个安装确认页面，只有确认后安装才会继续执行……这其实是调用系统默认的PackageInstaller安装器(需要指出的是这个APK是第三方的应用，系统应用的安装可以不通过PackageInstaller来安装)。在PackageInstaller安装界面的操作流程一般是：是否允许安装 → 正在进行安装 → 安装完成确认；这三个安装流程的界面是不一样的，拿中国移动的APK来举个栗子，如下图所示：''上图分别展示了在Android手机上安装APP应用时调用系统安装器PackageInstaller不同状态时的样式，我们的自动安装应用小外挂就是当出现了这以上页面中的任一个时我们该外观都能自动来执行安装流程，既然是自动安装也就是说当出现了这些按钮时我们的外挂能主动的执行按钮的点击操作，这样就省去了人为的手动点击操作，这也是外挂的核心作用。由于PackageInstaller的页面发生了变化都会回调AutoInstallApkService的onAccessibilityEvent()方法，因此我们可以在该方法中来模拟用户的操作，要模拟点击操作就要得到对应的按钮，然后执行按钮的点击事件；那怎么样才能得到目标按钮这个对象呢？在AccessibilityService中提供了一个getRootInActiveWindow()方法，该方法返回一个代表当前活动窗口的根节点AccessibilityNodeInfo实例对象，该对象保存了当前窗口界面的相关信息，比如控件在窗口的位置信息，id信息，文本信息，类型信息，文本信息等等，它和ViewGroup类似，对外提供了诸如findAccessibilityNodeInfosByViewId()，findAccessibilityNodeInfosByText()，performAction()等方法。其中findAccessibilityNodeInfosByViewId()是4.3版本之后的新增方法，表示根据给定控件的ID来获取到对应控件，获取到对应控件后就可以通过performAction()方法来执行点击事件了，那怎么获取到指定控件的ID呢？''在Android的sdk目录中有个tools目录，在该目录下有个uiautomatorviewer工具，该工具很有用，特别是分析apk的页面布局信息，它可以获取到当前手机屏幕上的界面信息，如下图所示：''在上图中我们通过uiautomatorviewer工具展示了安装APP的界面信息。左侧表示截屏信息，当点击界面上的相关控件的时候，右侧就会出现该控件的相关信息，比如id，text，package，class，clickable等，而这个ID就是我们想要的id，又因为在一个页面上id是唯一的，所以只要我们获取到了所有的符合条件的ID后就可以通过该id获取到对应的AccessibilityNodeInfo对象了，然后通过调用该对象的performAction()方法就可以实现自动点击效果了。通过uiautomatorviewer工具找到所有操作按钮的id后，就可以在我们的AutoInstallApkService的onAccessibilityEvent()方法中做操作了，代码如下：''public class AutoInstallApkService extends AccessibilityService {\n\n    private static final String DEFAULT_PACKAGE_NAME = ""com.android.packageinstaller"";\n    \n    private static final String[] IDS = {\n            ""com.android.packageinstaller:id/ok_button"",        // 下一步按钮的ID，注意ID的格式，必须这样写\n            ""com.android.packageinstaller:id/done_button"",      // 完成按钮的ID，注意ID的格式，必须这样写\n            ""com.android.packageinstaller:id/confirm_button""    // 确认按钮的ID，注意ID的格式，必须这样写\n    };\n\n    @Override\n    public void onAccessibilityEvent(AccessibilityEvent event) {\n        if (null == event) return;\n        installApkIfNecessary(event);\n        recycleAccessibilityEvent(event);\n    }\n\n    private void installApkIfNecessary(AccessibilityEvent event) {\n        AccessibilityNodeInfo rootInfo = getRootInActiveWindow();\n        if (null == rootInfo) return;\n        String packageName = rootInfo.getPackageName().toString();\n        if (DEFAULT_PACKAGE_NAME.equals(packageName)) {\n            int length = IDS.length;\n            AccessibilityNodeInfo availableNode = null;\n            for (int i = 0; i < length; i++) {\n                availableNode = findAvailableNodeInfoByViewId(rootInfo, IDS[i]);\n                if (null != availableNode) {\n                    break;\n                }\n            }\n            if (null != availableNode) {\n                performClickWithAccessibilityNode(availableNode);\n            }\n        }\n    }\n\n    private AccessibilityNodeInfo findAvailableNodeInfoByViewId(AccessibilityNodeInfo root, String id) {\n        List<AccessibilityNodeInfo> availableNodes = root.findAccessibilityNodeInfosByViewId(id);\n        if (null == availableNodes || availableNodes.isEmpty()) {\n            return null;\n        }\n        return availableNodes.get(0);\n    }\n\n    private void performClickWithAccessibilityNode(AccessibilityNodeInfo nodeInfo) {\n        if (null != nodeInfo) {\n            if (nodeInfo.isClickable()) {\n                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_CLICK);\n            } else {\n                performClickWithAccessibilityNode(nodeInfo.getParent());\n            }\n        }\n    }\n\n    @Override\n    public void onInterrupt() {\n    }\n\n    private void recycleAccessibilityEvent(AccessibilityEvent event) {\n        if (null != event) {\n            event.recycle();\n            event = null;\n        }\n    }\n}''以上就是我们AutoInstallApkService的全部代码，相信小伙伴们都看的懂，DEFAULT_PACKAGE_NAME表示监听应用的包名，IDS表示需要点击的所有的ID控件集合，在onAccessibilityEvent()方法中我们首先判断传递进来的event是否非空，如果非空就执行installApkIfNecessary()方法，在该方法中先获取根节点rootInfo，然后循环IDS通过调用rootInfo的findAccessibilityNodeInfosByViewId()方法找到对应的控件节点，如果找到了对应节点就调用performClickWithAccessibilityNode()方法来执行点击动作，需要注意的是在performClickWithAccessibilityNode()方法中如果当前控件不可点击我们就递归调用找其父控件来执行点击事件，只所以这么做是为了避免为了扩大点击面积我们往往在当前控件外嵌套一个父布局然后使父布局来响应点击事件的情况存在(因为之前在做抢红包外挂时碰见这种情况)。''好了，现在我们的自动安装APP的外挂已经完成，接下来运行在手机上后要在手机的辅助功能列表中开启该服务，否则该服务不起作用，操作截图如下：''开启了AutoInstallApkService服务后，就可以在手机上尝试安装一个APP看看效果了。因为我们的AutoInstallApkService是监听的系统的PackageInstaller应用，所以只要我们点击了已经下载过的APP后都是可以调用此应用的，直接点击一个应用，效果如下：''根据截图效果来看，安装APP时的操作流程都可以自动完成，运行结果也达到了我们的预期，这就是在手机上做的一个小外挂，是不是很简单？(*^__^*) ……其实外挂听起来很高大上，但只要了解了它的核心思想，做一个小外挂出来还是很容易的(就像当时我写了一个咻一咻外挂)，现在想想当年的偷菜外挂猜测应该也是借助了系统的辅助功能来实现的吧。''好了，到这里有关自动安装APP的小外挂实验已经结果了，在下篇文章''Android 源码系列之<十一>从源码的角度深入理解AccessibilityService，打造自己的APP小外挂(下)''中，我将带领小伙伴们们从源码出发深入理解一下AccessibilityService的执行原理，敬请期待！！！最后感谢观看(*^__^*) ……'"
CSDN,https://blog.csdn.net/dichi4045/article/details/102444432,Spring系列之Spring常用注解总结 转载,dichi4045,java,,2018-12-12 10:06:00,"'传统的Spring做法是使用.xml文件来对bean进行注入或者是配置aop、事物，这么做有两个缺点：''1、如果所有的内容都配置在.xml文件中，那么.xml文件将会十分庞大；如果按需求分开.xml文件，那么.xml文件又会非常多。总之这将导致配置文件的可读性与可维护性变得很低。''2、在开发中在.java文件和.xml文件之间不断切换，是一件麻烦的事，同时这种思维上的不连贯也会降低开发的效率。''为了解决这两个问题，Spring引入了注解，通过""@XXX""的方式，让注解与Java Bean紧密结合，既大大减少了配置文件的体积，又增加了Java Bean的可读性与内聚性。''不使用注解：''先看一个不使用注解的Spring示例，在这个示例的基础上，改成注解版本的，这样也能看出使用与不使用注解之间的区别，先定义一个老虎：''package com.spring.model;\n\npublic class Tiger {\n    \n    private String tigerName=""TigerKing"";\n    \n    public String toString(){\n        return ""TigerName:""+tigerName;\n    }\n}''再定义一个猴子：''package com.spring.model;\n\npublic class Monkey {\n    \n    private String monkeyName = ""MonkeyKing"";\n    \n    public String toString(){\n        return ""MonkeyName:"" + monkeyName;\n    }\n\n}''定义一个动物园：''package com.spring.model;\n\npublic class Zoo {\n    private Tiger tiger;\n    private Monkey monkey;\n    \n    public Tiger getTiger() {\n        return tiger;\n    }\n    public void setTiger(Tiger tiger) {\n        this.tiger = tiger;\n    }\n    public Monkey getMonkey() {\n        return monkey;\n    }\n    public void setMonkey(Monkey monkey) {\n        this.monkey = monkey;\n    }\n    \n    public String toString(){\n        return tiger + ""\\n"" + monkey;\n    }\n    \n}''spring的配置文件这么写：''<?xml version=""1.0"" encoding=""UTF-8""?>\n<beans\n    xmlns=""http://www.springframework.org/schema/beans""\n    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""\n    xmlns:p=""http://www.springframework.org/schema/p""\n    xmlns:context=""http://www.springframework.org/schema/context""\n    xsi:schemaLocation=""http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\n    "">\n    \n     <bean id=""zoo"" class=""com.spring.model.Zoo"" >\n        <property name=""tiger"" ref=""tiger"" />\n        <property name=""monkey"" ref=""monkey"" />\n    </bean>\n    \n    <bean id=""tiger"" class=""com.spring.model.Tiger"" />\n    <bean id=""monkey"" class=""com.spring.model.Monkey"" />\n\n</beans>''测试方法：''public class TestAnnotation {\n    /**\n     * 不使用注解\n     */\n    @Test\n    public void test(){\n        //读取配置文件\n        ApplicationContext ctx=new ClassPathXmlApplicationContext(""applicationContext2.xml"");\n        Zoo zoo=(Zoo) ctx.getBean(""zoo"");\n        System.out.println(zoo.toString());\n    }\n}''都很熟悉，权当复习一遍了。''1、@Autowired''@Autowired顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。''@Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当''有且仅有一个匹配的Bean''时，Spring将其注入@Autowired标注的变量中。''因此，引入@Autowired注解，先看一下spring配置文件怎么写：''1 <?xml version=""1.0"" encoding=""UTF-8""?>\n 2 <beans\n 3     xmlns=""http://www.springframework.org/schema/beans""\n 4     xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""\n 5     xmlns:p=""http://www.springframework.org/schema/p""\n 6     xmlns:context=""http://www.springframework.org/schema/context""\n 7     xsi:schemaLocation=""http://www.springframework.org/schema/beans\n 8     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n 9     http://www.springframework.org/schema/context\n10     http://www.springframework.org/schema/context/spring-context-3.0.xsd\n11     "">\n12     \n13     <context:component-scan base-package=""com.spring"" />\n14     \n15     <bean id=""zoo"" class=""com.spring.model.Zoo"" />\n16     <bean id=""tiger"" class=""com.spring.model.Tiger"" />\n17     <bean id=""monkey"" class=""com.spring.model.Monkey"" />\n18 \n19 </beans>''注意第13行，使用必须告诉spring一下我要使用注解了，告诉的方式有很多，<context:component-scan base-package=""xxx"" />是一种最简单的，spring会自动扫描xxx路径下的注解。''看到第15行，原来zoo里面应当注入两个属性tiger、monkey，现在不需要注入了。再看下，Zoo.java也很方便，把getter/setter都可以去掉：''package com.spring.model;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class Zoo {\n    \n    @Autowired\n    private Tiger tiger;\n    \n    @Autowired\n    private Monkey monkey;\n    \n    public String toString(){\n        return tiger + ""\\n"" + monkey;\n    }\n    \n}''这里@Autowired注解的意思就是，当Spring发现@Autowired注解时，将自动在代码上下文中找到和其匹配（默认是类型匹配）的Bean，并自动注入到相应的地方去。''有一个细节性的问题是，假如bean里面有两个property，Zoo.java里面又去掉了属性的getter/setter并使用@Autowired注解标注这两个属性那会怎么样？答案是Spring会按照xml优先的原则去Zoo.java中寻找这两个属性的getter/setter，导致的结果就是初始化bean报错。''OK，假设此时我把.xml文件的16行、17行两行给去掉，再运行，会抛出异常：'""org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'zoo': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.spring.model.Tiger com.spring.model.Zoo.tiger; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No matching bean of type [com.spring.model.Tiger] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:285)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1074)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:517)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291)\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:580)\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:139)\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:83)\n    at com.spring.test.TestAnnotation.test(TestAnnotation.java:16)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:45)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\nCaused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.spring.model.Tiger com.spring.model.Zoo.tiger; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No matching bean of type [com.spring.model.Tiger] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:502)\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:84)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:282)\n    ... 36 more\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No matching bean of type [com.spring.model.Tiger] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoSuchBeanDefinitionException(DefaultListableBeanFactory.java:920)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:789)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:703)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:474)\n    ... 38 more""'因为，@Autowired注解要去寻找的是一个Bean，Tiger和Monkey的Bean定义都给去掉了，自然就不是一个Bean了，Spring容器找不到也很好理解。那么，如果属性找不到我不想让Spring容器抛出异常，而就是显示null，可以吗？可以的，其实异常信息里面也给出了提示了，就是将@Autowired注解的required属性设置为false即可：''package com.spring.model;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic class Zoo {\n    \n    @Autowired(required=false)\n    private Tiger tiger;\n    \n    @Autowired(required=false)\n    private Monkey monkey;\n    \n    public String toString(){\n        return tiger + ""\\n"" + monkey;\n    }\n    \n}''此时，找不到tiger、monkey两个属性，Spring容器不再抛出异常而是认为这两个属性为null。''2、Qualifier（指定注入Bean的名称）''如果容器中有一个以上匹配的Bean，则可以通过@Qualifier注解限定Bean的名称，看下面的例子：''定义一个Car接口：''package com.spring.service;\n\npublic interface ICar {\n    \n    public String getCarName();\n}''两个实现类BMWCar和BenzCar：''package com.spring.service.impl;\n\nimport com.spring.service.ICar;\n\npublic class BMWCar implements ICar{\n    \n    public String getCarName(){\n        return ""BMW car"";\n    }\n}''package com.spring.service.impl;\n\nimport com.spring.service.ICar;\n\npublic class BenzCar implements ICar{\n    \n    public String getCarName(){\n        return ""Benz car"";\n    }\n}''再写一个CarFactory，引用car（这里先不用@Qualifier注解）：''package com.spring.model;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport com.spring.service.ICar;\n\npublic class CarFactory {\n    \n    @Autowired\n    private ICar car;\n    \n    public String toString(){\n        return car.getCarName();\n    }\n    \n}''配置文件：''<?xml version=""1.0"" encoding=""UTF-8""?>\n<beans\n    xmlns=""http://www.springframework.org/schema/beans""\n    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""\n    xmlns:p=""http://www.springframework.org/schema/p""\n    xmlns:context=""http://www.springframework.org/schema/context""\n    xsi:schemaLocation=""http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\n    "">\n    \n    <context:component-scan base-package=""com.spring"" />\n    \n    <!-- Autowired注解配合Qualifier注解 -->\n    <bean id=""carFactory"" class=""com.spring.model.CarFactory"" />\n    <bean id=""bmwCar"" class=""com.spring.service.impl.BMWCar"" />\n    <bean id=""benz"" class=""com.spring.service.impl.BenzCar"" />\n    \n</beans>''测试方法：''/**\n * Autowired注解配合Qualifier注解\n */\n@Test\npublic void test1(){\n    //读取配置文件\n    ApplicationContext ctx=new ClassPathXmlApplicationContext(""applicationContext2.xml"");\n    CarFactory carFactory=(CarFactory) ctx.getBean(""carFactory"");\n    System.out.println(carFactory.toString());\n}''运行一下，不用说，一定是报错的，Car接口有两个实现类，Spring并不知道应当引用哪个实现类。'""org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'carFactory': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException:""'Could not autowire field: private com.spring.service.ICar com.spring.model.CarFactory.car; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException:''No unique bean of type [com.spring.service.ICar] is defined: expected single matching bean but found 2: [bmwCar, benz]\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:285)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1074)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:517)\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291)\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:580)\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:139)\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:83)\n    at com.spring.test.TestAnnotation.test1(TestAnnotation.java:25)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:45)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\nCaused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.spring.service.ICar com.spring.model.CarFactory.car; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.spring.service.ICar] is defined: expected single matching bean but found 2: [bmwCar, benz]\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:502)\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:84)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:282)\n    ... 36 more\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.spring.service.ICar] is defined: expected single matching bean but found 2: [bmwCar, benz]\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:796)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:703)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:474)\n    ... 38 more''出现这种情况通常有两种解决办法：''(1)、在配置文件中删除其中一个实现类，Spring会自动去base-package下寻找Car接口的实现类，发现Car接口只有一个实现类，便会直接引用这个实现类。''(2)、实现类就是有多个该怎么办？此时可以使用@Qualifier注解来指定Bean的名称：''package com.spring.model;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\n\nimport com.spring.service.ICar;\n\npublic class CarFactory {\n    \n    @Autowired\n    @Qualifier(""bmwCar"")\n    private ICar car;\n    \n    public String toString(){\n        return car.getCarName();\n    }\n    \n}''此处会注入名为""bmwCar""的Bean。''3、Resource''@Resource注解与@Autowired注解作用非常相似，这个就简单说了，看例子：''package com.spring.model;\n\nimport javax.annotation.Resource;\n\npublic class Zoo1 {\n    \n    @Resource(name=""tiger"")\n    private Tiger tiger;\n    \n    @Resource(type=Monkey.class)\n    private Monkey monkey;\n    \n    public String toString(){\n        return tiger + ""\\n"" + monkey;\n    }\n}''这是详细一些的用法，说一下@Resource的装配顺序：''(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配''(2)、指定了name或者type则根据指定的类型去匹配bean''(3)、指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错''然后，区分一下@Autowired和@Resource两个注解的区别：''(1)、@Autowired默认按照byType方式进行bean匹配，@Resource默认按照byName方式进行bean匹配''(2)、@Autowired是Spring的注解，@Resource是J2EE的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了''Spring属于第三方的，J2EE是Java自己的东西，因此，建议使用@Resource注解，以减少代码和Spring之间的耦合。''4、Service''上面这个例子，还可以继续简化，因为spring的配置文件里面还有15行~17行三个bean，下一步的简化是把这三个bean也给去掉，使得spring配置文件里面只有一个自动扫描的标签，增强Java代码的内聚性并进一步减少配置文件。''要继续简化，可以使用@Service。先看一下配置文件，当然是全部删除了：''<?xml version=""1.0"" encoding=""UTF-8""?>\n<beans\n    xmlns=""http://www.springframework.org/schema/beans""\n    xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""\n    xmlns:p=""http://www.springframework.org/schema/p""\n    xmlns:context=""http://www.springframework.org/schema/context""\n    xsi:schemaLocation=""http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\n    "">\n    \n    <context:component-scan base-package=""com.spring"" />\n    \n</beans>''是不是感觉很爽？起码我觉得是的。OK，下面以Zoo.java为例，其余的Monkey.java和Tiger.java都一样：''package com.spring.model;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class Zoo {\n    \n    @Autowired\n    private Tiger tiger;\n    \n    @Autowired\n    private Monkey monkey;\n    \n    public String toString(){\n        return tiger + ""\\n"" + monkey;\n    }\n    \n}''这样，Zoo.java在Spring容器中存在的形式就是""zoo""，即可以通过ApplicationContext的getBean(""zoo"")方法来得到Zoo.java。@Service注解，其实做了两件事情：''(1)、声明Zoo.java是一个bean，这点很重要，因为Zoo.java是一个bean，其他的类才可以使用@Autowired将Zoo作为一个成员变量自动注入。''(2)、Zoo.java在bean中的id是""zoo""，即类名且首字母小写。''如果，我不想用这种形式怎么办，就想让Zoo.java在Spring容器中的名字叫做""Zoo""，可以的：''package com.spring.model;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\n@Service(""Zoo"")\n@Scope(""prototype"")\npublic class Zoo {\n    \n    @Autowired\n    private Tiger tiger;\n    \n    @Autowired\n    private Monkey monkey;\n    \n    public String toString(){\n        return tiger + ""\\n"" + monkey;\n    }\n    \n}''这样，就可以通过ApplicationContext的getBean(""Zoo"")方法来得到Zoo.java了。''这里我还多加了一个@Scope注解，应该很好理解。因为Spring默认产生的bean是单例的，假如我不想使用单例怎么办，xml文件里面可以在bean里面配置scope属性。注解也是一样，配置@Scope即可，默认是""singleton""即单例，""prototype""表示原型即每次都会new一个新的出来。''――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――''使用注解来构造IoC容器''用注解来向Spring容器注册Bean。需要在applicationContext.xml中注册<context:component-scan base-package=”pagkage1[,pagkage2,…,pagkageN]”/>。''如：在base-package指明一个包''<context:component-scan base-package=""cn.gacl.java""/>''表明cn.gacl.java包及其子包中，如果某个类的头上带有特定的注解【@Component/@Repository/@Service/@Controller】，就会将这个对象作为Bean注册进Spring容器。也可以在<context:component-scan base-package=” ”/>中指定多个包，如：''<context:component-scan base-package=""cn.gacl.dao.impl,cn.gacl.service.impl,cn.gacl.action""/>''多个包逗号隔开。''1、@Component''@Component是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。''2、@Controller''@Controller对应表现层的Bean，也就是Action，例如：''@Controller\n@Scope(""prototype"")\npublic class UserAction extends BaseAction<User>{\n ……\n}''使用''@Controller''注解标识''UserAction''之后，就表示要把''UserAction''交给''Spring''容器管理，''在''Spring''容器中会存在一个名字为''""userAction""''的''action''，这个名字是根据''UserAction''类名来取的。''注意：如果''@Controller''不指定其''value【@Controller】，''则默认的''bean''名字为这个类的类名首字母小写''，''如果指定''value【@Controller(value=""UserAction"")】''或者''【@Controller(""UserAction"")】，''则使用''value''作为''bean''的名字''。''这里的UserAction还使用了@Scope注解，@Scope(""prototype"")表示将Action的范围声明为原型，''可以利用容器的''scope=""prototype""''来保证每一个请求有一个单独的''Action''来处理，避免''struts''中''Action''的线程安全问题。''spring''默认''scope''是单例模式''(scope=""singleton"")''，这样只会创建一个''Action''对象，每次访问都是同一''Action''对象，数据不安全，''struts2''是要求''每次次访问''都对应不同的''Action''，''scope=""prototype""''可以保证''当有请求的时候''都创建一个''Action''对象。''3、@Service''@Service对应的是业务层Bean，例如：''@Service(""userService"")\npublic class UserServiceImpl implements UserService {\n………\n}''@Service(""userService"")注解是告诉Spring，当Spring要创建UserServiceImpl的的实例时，bean的名字必须叫做""userService""，这样当Action需要使用UserServiceImpl的的实例时,就可以由Spring创建好的""userService""，然后注入给Action：在Action只需要声明一个名字叫""userService""的变量来接收由Spring注入的""userService""即可，具体代码如下：''// 注入userService\n@Resource(name = ""userService"")\nprivate UserService userService;''注意：在Action声明的""userService""变量的类型必须是""UserServiceImpl""或者是其父类""UserService""，否则由于类型不一致而无法注入，由于Action中的声明的""userService""变量使用了@Resource注解去标注，并且指明了其name = ""userService""，这就等于告诉Spring，说我Action要实例化一个""userService""，你Spring快点帮我实例化好，然后给我，当Spring看到userService变量上的@Resource的注解时，根据其指明的name属性可以知道，Action中需要用到一个UserServiceImpl的实例，此时Spring就会把自己创建好的名字叫做""userService""的UserServiceImpl的实例注入给Action中的""userService""变量，帮助Action完成userService的实例化，这样在Action中就不用通过""UserService userService = new UserServiceImpl();""这种最原始的方式去实例化userService了。如果没有Spring，那么当Action需要使用UserServiceImpl时，必须通过""UserService userService = new UserServiceImpl();""主动去创建实例对象，但使用了Spring之后，Action要使用UserServiceImpl时，就不用主动去创建UserServiceImpl的实例了，创建UserServiceImpl实例已经交给Spring来做了，Spring把创建好的UserServiceImpl实例给Action，Action拿到就可以直接用了。Action由原来的主动创建UserServiceImpl实例后就可以马上使用，变成了被动等待由Spring创建好UserServiceImpl实例之后再注入给Action，Action才能够使用。这说明Action对""UserServiceImpl""类的“控制权”已经被“反转”了，原来主动权在自己手上，自己要使用""UserServiceImpl""类的实例，自己主动去new一个出来马上就可以使用了，但现在自己不能主动去new ""UserServiceImpl""类的实例，new ""UserServiceImpl""类的实例的权力已经被Spring拿走了，只有Spring才能够new ""UserServiceImpl""类的实例，而Action只能等Spring创建好""UserServiceImpl""类的实例后，再“恳求”Spring把创建好的""UserServiceImpl""类的实例给他，这样他才能够使用""UserServiceImpl""，这就是Spring核心思想“控制反转”，也叫“依赖注入”，“依赖注入”也很好理解，Action需要使用UserServiceImpl干活，那么就是对UserServiceImpl产生了依赖，Spring把Acion需要依赖的UserServiceImpl注入(也就是“给”)给Action，这就是所谓的“依赖注入”。对Action而言，Action依赖什么东西，就请求Spring注入给他，对Spring而言，Action需要什么，Spring就主动注入给他。''4、@ Repository''@Repository对应数据访问层Bean ，例如：''@Repository(value=""userDao"")\npublic class UserDaoImpl extends BaseDaoImpl<User> {\n………\n}''@Repository(value=""userDao"")注解是告诉Spring，让Spring创建一个名字叫""userDao""的UserDaoImpl实例。''当Service需要使用Spring创建的名字叫""userDao""的UserDaoImpl实例时，就可以使用@Resource(name = ""userDao"")注解告诉Spring，Spring把创建好的userDao注入给Service即可。''// 注入userDao，从数据库中根据用户Id取出指定用户时需要用到\n@Resource(name = ""userDao"")\nprivate BaseDao<User> userDao;''―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――''Spring常用注解汇总''本文汇总了Spring的常用注解，以方便大家查询和使用，具体如下：''使用注解之前要开启自动扫描功能，其中base-package为需要扫描的包(含子包)。''<context:component-scan base-package=""cn.test""/>''@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。''@Scope注解 作用域''@Lazy(true) 表示延迟初始化''@Service用于标注业务层组件、''@Controller用于标注控制层组件（如struts中的action）''@Repository用于标注数据访问组件，即DAO组件。''@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。''@Scope用于指定scope作用域的（用在类上）''@PostConstruct用于指定初始化方法（用在方法上）''@PreDestory用于指定销毁方法（用在方法上）''@DependsOn：定义Bean初始化及销毁时的顺序''@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常''@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：''@Autowired @Qualifier(""personDaoBean"") 存在多个实例配合使用''@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。''@PostConstruct 初始化注解''@PreDestroy 摧毁注解 默认 单例\xa0 启动就加载''@Async异步方法调用''转载于:https://www.cnblogs.com/zengpeng/p/10106808.html'"
CSDN,https://blog.csdn.net/dichi4045/article/details/102444405,mssqlservers数据嗅探,dichi4045,数据库,,2018-07-30 15:17:00,"'文章来自：https://yq.aliyun.com/articles/61767''先说我的问题，最近某个存储过程，暂定名字：sp_a 总是执行超时，sp_a带有一个参数，暂定名为 para1 varchar(50)，刚开始以为 是 sp_a 的语句优化得不够好，毕竟当时写的时候都是能用就成。''然后啪啪啪优化存储过程，写完了一测试，速度蛮快的，秒出结果。然后上线之。。。我写存储过程的时候，是直接定义一个参数，然后在里面写代码，没有创建存储过程去执行存储过程，大概意思是在查询分析器里面像下面这样写，写完了F5测试，速度快就感觉可以。''declare @para1 varchar(50)'""set @para1='11111'""'select * from xxxx''left join''inner join''上线后因为这个功能是很不常用没注意，今天用到了，还是经常性超时。我第一反映是，上次优化的不够吗？然后就去在sql 查询分析器里面用 \xa0sp_a ‘11111’ 这样去执行，结果很久不出结果。''然后我就觉得奇怪，就去把 sp_a 的代码全部扣出来，然后写死一个参数去执行这个sql段，结果秒出。''感觉问题好奇怪，明明语句效率不会低，但是存储过程却不出结果。''去dba的一个交流群丢出问题，别人给我的方向是参数嗅探这块，但是按这篇文章各种操作后，还是一样没有用，我就差没重启数据库服务器了''按道理来说，如果是参数嗅探，它老早缓存了执行计划的话，我新建了一个存储过程名为 sp_aNew 参数和代码一样，应该不会卡才对，结果还是卡了。。。。''然后我按我最笨的办法，一步步修改存储过程，把里面的left join inner join 等操作一个个去掉，发现去到两个 left join 的时候就秒出结果了，那么问题就出在了这两个jeft join''然后那两个left join 的作用是 判断数据是否存在于某个表，所以我改为i了 where not exists 也可以有类似效果，然后存储过程就秒出结果了。。。。''神奇的还在后头，后来我想要复现一下，把代码恢复到原来的，奶奶的竟然不会了。。。。。''所以疑问一堆：一，假设是我的存储过程代码效率 不够，那么为什么我写死参数后直接执行秒出结果？''二，假设是参数嗅探，为什么新建一个存储过程后，还是依然超时？不是说参数嗅探是因为这个存储过程的执行计划被缓存吗？那我新建过一个按道理不会才对啊。。。。。''三、我改完了那个 where 条件后，感觉应该是重建了执行计划，为什么我新的存储过程也不会卡了。。。。也就是说 sp_a存储过程和 sp_aNew 这个存储过程有关联吗？''感觉是不是它不针对存储过程名，而是针对表？''有知道的人，希望回复我，解答一下我的疑惑，谢谢。''问题虽然暂时解决，但是这个问题没有得到合理的解释，总感觉悬着，先记录一下，万一以后碰到类似的还能先找到临时的解决办法。。。。。''title: SQL Server - 最佳实践 - 参数嗅探问题''author: 风移''摘要''MSSQL Server参数嗅探既是一个涉及知识面非常广泛，又是一个比较难于解决的课题，即使对于数据库老手也是一个比较头痛的问题。这篇文章从参数嗅探是什么，如何产生，表象是什么，会带来哪些问题，如何解决这五个方面来探讨参数嗅探的来龙去脉，期望能够将SQL Server参数嗅探问题理清楚，道明白。''什么参数嗅探''当SQL Server第一次执查询语句或存储过程（或者查询语句与存储过程被强制重新编译）的时候，SQL Server会有一个进程来评估传入的参数，并根据传入的参数生成对应的执行计划缓存，然后参数的值会伴随查询语句或存储过程执行计划一并保存在执行计划缓存里。这个评估的过程就叫着参数嗅探。''参数嗅探是如何产生的''SQL Server对查询语句编译和缓存机制是SQL语句执行过程中非常重要的环节，也是SQLOS内存管理非常重要的一环。理由是SQL Server对查询语句编译过程是非常消耗系统性能，代价昂贵的。因为它需要从成百上千条执行路径中选择一条最优的执行计划方案。所以，查询语句可以重用执行计划的缓存，避免重复编译，以此来节约系统开销。这种编译查询语句，选择最优执行方案，缓存执行计划的机制就是参数嗅探问题产生的理论基础。''参数嗅探的表象''以上是比较枯燥的理论解释，这里我们来看看两个实际的例子。在此，我们以AdventureWorks2008R2数据库中的Sales.SalesOrderDetail表做为我们测试的数据源，我们挑选其中三个典型的产品，ProductID分别为897，945和870，分别对应的订单总数为2，257和4688。''挑选的方法如下：''use AdventureWorks2008R2''GO\n\n;WITH DATA\nAS(''select ProductID,''COUNT(''1)''as order_count,''rowid = ROW_NUMBER()''OVER(''ORDER''BY''COUNT(''1)''asc)''from Sales.SalesOrderDetail''with(nolock)''group''by ProductID )''SELECT *''FROM''DATA''WHERE''rowid''in (''1,''266,''133)''得到如下结果：''查询语句的参数嗅探表象''接下来，我们看三个非常相似的查询语句（仅传入的参数值不同）的执行计划有什么差异。''三个查询语句：''use AdventureWorks2008R2''GO''SELECT SalesOrderDetailID, OrderQty''FROM Sales.SalesOrderDetail''WITH(NOLOCK)''WHERE ProductID =''897;''SELECT SalesOrderDetailID, OrderQty''FROM Sales.SalesOrderDetail''WITH(NOLOCK)''WHERE ProductID =''945;''SELECT SalesOrderDetailID, OrderQty''FROM Sales.SalesOrderDetail''WITH(NOLOCK)''WHERE ProductID =''870;''分别的执行计划：''从这个执行计划对比来看，ProductID为945和897的两条语句执行计划一致，因为满足条件的记录数非常少，分别为257条和2条，所以SQL Server均选择走最优执行计划Index Seek + Key Lookup。但是与ProductID为870的查询语句执行计划完全不同，这条语句SQL Server选择走的是Clustered Index Scan，几乎等价于Table Scan的性能消耗。这是因为，SQL Server认为满足条件ProductID = 870的记录数太多，达到了4688条记录，与其走Index Seek + Key Lookup，还不如走Clustered Index Scan顺序IO的效率高。从这里可以看出，SQL Server会因为传入参数值的不同而选择走不同的执行计划，执行效率也大不相同。确切的说，这个就是属于查询语句的参数嗅探问题范畴。''存储过程的参数嗅探表象''上一小节，我们看了查询语句的参数嗅探表象，这一小节我们来看看存储过程参数嗅探的表象又是如何的呢？''首先，我们创建如下存储过程:''USE AdventureWorks2008R2''GO''CREATE''PROCEDURE UP_GetOrderIDAndOrderQtyByProductID(\n@ProductID''INT )''AS''BEGIN''SET NOCOUNT''ON''SELECT SalesOrderDetailID , OrderQty''FROM Sales.SalesOrderDetail''WITH(NOLOCK)''WHERE ProductID = @ProductID;''END''GO''接下来，我们执行两次这个存储过程，传入不同的参数：''EXEC dbo.UP_GetOrderIDAndOrderQtyByProductID 870\nEXEC dbo.UP_GetOrderIDAndOrderQtyByProductID 945''从这个执行计划来看，ProductID为870和945走的相同的执行计划Clustered Index Scan，这个和上一小节得到的结果是不一样的。上一节中ProductID = 945的查询语句执行计划走的是Index Seek + Key Lookup。''当我们选择第二个执行计划的Clustered Index Scan的时候，我们观察Properties中的Estimated Number of Rows，这里显示的是4668，但实际上正确得行数应该是257。如下如所示：''这到底是为什么呢？从另外一个角度来讲，这个不正确的统计估值甚至会导致SQL Server走到一个不是最优的执行计划上来（根据上一小节，ProductID = 945的最优执行计划其实是Index Seek + Key Lookup）。''答案其实就是存储过程的参数嗅探问题。这是因为，我们在首次执行这个存储过程的时候，传入的参数ProductID = 870对应的订单总数为4668，SQL Server在编译，缓存执行计划的时候，连同这个值一起记录到执行计划缓存中了。从而影响到存储过程的第二次及以后的执行计划方案，进而影响到存储过程的执行效率。''我们可以通过如下方法来查看执行计划中传入参数的值，右键 => Show Execution Plan XML => 搜索 ParameterCompiledValue''在此例中，我们很清楚的发现传入参数值是870，同时也很清楚得看到了参数嗅探对于执行计划的影响：''...\n<ColumnReference Column=""@ProductID"" ParameterCompiledValue=""(870)"" ParameterRuntimeValue=""(870)"" />\n...''至此，我们分别从查询语句和存储过程两个方便看到了参数嗅探的表象。''参数嗅探导致的问题''从参数嗅探的表象这一章节，我们可以对此参数嗅探的问题窥探一二。但是，参数嗅探可能会导致哪些常见的问题呢？根据我们的经验，如果你遭遇了MSSQL Server以下奇怪问题，你可能就遇到参数嗅探这个“大魔头”了。''ALTER PROCEDURE解决性能问题''某些传入参数导致存储过程执行非常缓慢，但是ALTER PROCDURE（所有代码没做任何改动）后，性能恢复正常。这个场景是我们之前经常遇到的，原因是当你ALTER PROCEDURE后，MSSQL Server会主动清除对应的存储过程执行计划缓存，然后再次执行该存储过程的时候，系统会重新编译并缓存该存储过程执行计划。''相同的存储过程，相同的传入参数，执行时快时慢''这个听起来非常奇怪吧，当我们执行相同的存储过程，传入相同的参数值，但是执行效率时快时慢，请注意下面例子中的注释部分。''USE AdventureWorks2008R2''GO''--SQL Server 创建执行计划，优化ProductID = 870对应的大量订单量，运行时间500毫秒\nEXEC dbo.UP_GetOrderIDAndOrderQtyByProductID''870''--SQL Server直接获取缓存中的执行计划，对于小量订单来说可能不是最好的执行计划，不过没关系，执行时间450毫秒 EXEC dbo.UP_GetOrderIDAndOrderQtyByProductID''945''现在我们清空了执行计划缓存，为了方便，我直接清除所有的执行计划缓存。''DBCC FREEPROCCACHE''再次执行存储过程，这次我们交换了执行顺序，先执行ProductID 945，然后执行ProductID 870。''USE AdventureWorks2008R2''GO''--SQL Server 创建执行计划，优化ProductID = 945，对应于小量订单的最优执行计划，运行时间100毫秒\nEXEC dbo.UP_GetOrderIDAndOrderQtyByProductID''945''--SQL Server直接获取缓存中的执行计划，对于大量订单的ProductID 870来说，可能是很差的执行计划，执行时间60秒 EXEC dbo.UP_GetOrderIDAndOrderQtyByProductID''870''从这两个批次执行的时间对比来看，ProductID 945和870执行时间有比较大的差异，特别是ProductID = 870。这种相同的存储过程，相同的传入参数，执行时快时慢的问题，也是由于参数嗅探导致的。''注意：这里只是为了描述这种现象，由于表数据量本来不大的原因，可能实际上执行时间可能没有那么大的差异。''查询语句放在存储过程中和单独执行效率差异大''某一个查询语句，放在存储过程中执行和拿出来单独执行，时间消耗差异大，一般情况是拿出来单独执行的语句很快，放到存储过程中执行很慢。这个情况也是我们在产品环境常见的一种典型参数嗅探导致的问题。''参数嗅探的解决方法''上一节，我们探讨了参数嗅探可能会导致的问题。当发现这些问题的时候，我们来看看两类人的不同解决方法。请允许我将这两类人分别命名为菜鸟和老鸟，没有任何歧视，只是一个名字代号而已。''菜鸟的解决方法''菜鸟的理论很简单粗暴，既然参数嗅探是因为查询语句或者存储过程的执行计划缓存导致，那么我只需要清空内存就可以解决这个问题了嘛。嗯，来看看菜鸟很傻很天真的做法吧。''方法一：重启Windows OS。果然很黄很暴力，重启Windows操作系统，彻底清空Windows所有内存内容。''方法二：重启SQL Server Service。稍微温柔一点点啦，重启SQL Server Service，彻底清空SQL Server占用的所有内存，当然执行计划缓存也被清空了。''方法三：DBCC命令清空SQL Server执行计划缓存。又温柔了不少吧，彻底清空了SQL Server所有的执行计划缓存，包含有问题的和没有问题的缓存。''DBCC FREEPROCCACHE''老鸟的解决方法''当菜鸟还在为自己的解决方法解决了参数嗅探问题而沾沾自喜的时候，老鸟的思维已经走得很远很远了，老鸟就是老鸟，是菜鸟所望尘莫及的。老鸟的思维逻辑其实也很简单，既然是某个或者某些查询语句或存储过程的执行计划缓存有问题，那么，我们只需要重新编译缓存这些害群之马就好了。''方法一：创建存储过程使用WITH RECOMPILE''USE AdventureWorks2008R2''GO''ALTER''PROCEDURE dbo.UP_GetOrderIDAndOrderQtyByProductID(\n@ProductID''INT )''WITH RECOMPILE''AS''BEGIN''SET NOCOUNT''ON''SELECT SalesOrderDetailID , OrderQty''FROM Sales.SalesOrderDetail''WITH(NOLOCK)''WHERE ProductID = @ProductID;''END''GO''再重新执行两次存储过程，传入不同的参数值，我们可以看到均走到最优的执行计划上来了，说明参数嗅探的问题已经解决。这个方法带来的一个问题就是每次执行这个存储过程系统都会重新编译，无法使用执行计划缓存。但是相对来说，重新编译的系统开销要远远小于参数嗅探导致的系统性能消耗，所以，两害取其轻。''方法二：查询语句使用Query Hits''如果我们知道ProductID对应的订单总数分布，认为ProductID = 945为最好的执行计划，那么我们可以强制SQL Server按照参数输入945来执行存储过程，我们可以添加Query Hits来实现。这种方法的难点在于对表中数据分布有着精细的认识，可操作性不强，因为表中数据分布是随时在改变的。''USE AdventureWorks2008R2''GO''ALTER''PROCEDURE dbo.UP_GetOrderIDAndOrderQtyByProductID(\n@ProductID''INT )''AS''BEGIN''SET NOCOUNT''ON''SELECT SalesOrderDetailID , OrderQty''FROM Sales.SalesOrderDetail''WITH(NOLOCK)''WHERE ProductID = @ProductID''--OPTION (RECOMPILE);''OPTION (''OPTIMIZE''FOR (@ProductID=''945));''--OPTION (OPTIMIZE FOR (@ProductID UNKNOWN));''END''GO''方法三：DBCC清除特定语句或存储过程缓存''当清除执行计划缓存后，SQL Server再次执行会重新编译对应语句或者存储过程，以获得最好的执行计划。在此以清除特定存储过程执行计划缓存为例。''USE AdventureWorks2008R2''GO''declare\n      @plan_id varbinary(''64)\n;''SELECT TOP''1 @plan_id = cache.plan_handle''FROM sys.dm_exec_cached_plans''cache''CROSS''APPLY sys.dm_exec_query_plan(cache.plan_handle)''AS pla''CROSS''APPLY sys.dm_exec_sql_text(cache.plan_handle)''AS txt''WHERE pla.objectid = object_id(N'""'UP_GetOrderIDAndOrderQtyByProductID',""""'P')""'and txt.objectid = object_id(N'""'UP_GetOrderIDAndOrderQtyByProductID',""""'P') DBCC FREEPROCCACHE (@plan_id); GO""'方法四：更新表对象统计信息''表统计信息过时导致执行计划评估不准确，进而影响查询语句执行效率。这个也是导致参数嗅探问题另一个重要原因。这种情况，我们只需要手动更新表统计信息。这个解决方法的难点在于找到有问题的查询语句和对应有问题的表。统计信息更新方法如下，如果发现StatsUpdated时间太过久远就应该是被怀疑的对象：''USE AdventureWorks2008R2''GO''UPDATE''STATISTICS Sales.SalesOrderDetail''WITH FULLSCAN;''SELECT''name''AS index_name , STATS_DATE(OBJECT_ID, index_id)''AS StatsUpdated''FROM sys.indexes''WHERE OBJECT_ID = OBJECT_ID('""'Sales.SalesOrderDetail')""'GO''方法五：重整表对象索引''另外一个导致执行计划评估不准确的重要原因是索引碎片过高（超过30%），这个也会导致参数嗅探问题的重要原因。这种情况我们需要手动重整索引碎片，方法如下：''USE AdventureWorks2008R2''GO''select \n        DB_NAME = DB_NAME(database_id)\n        ,SCHEMA_NAME = SCHEMA_NAME(schema_id)\n        ,OBJECT_NAME = tb.name\n        ,ix.name\n        ,avg_fragmentation_in_percent''from sys.dm_db_index_physical_stats(db_id(),object_id('""'Sales.SalesOrderDetail',""""'U'),""'NULL,''NULL,'""'LIMITED')""'AS fra''CROSS''APPLY sys.indexes''AS ix''WITH (NOLOCK)''INNER''JOIN sys.tables''as tb''WITH(NOLOCK)''ON ix.object_id = tb.object_id''WHERE ix.object_id = fra.object_id''and ix.index_id = fra.index_id''USE AdventureWorks2008R2''GO''ALTER''INDEX PK_SalesOrderDetail_SalesOrderID_SalesOrderDetailID''ON Sales.SalesOrderDetail''REBUILD;''方法六：创建缺失的索引''还有一个重要的导致执行计划评估不准确的因素是表缺失索引，这个也是会导致参数嗅探的问题。查找缺失索引的方法如下：''USE AdventureWorks2008R2''GO''SELECT TOP''10\n    database_name = db_name(details.database_id)\n    , schema_name = SCHEMA_NAME(tb.schema_id)\n    , object_name = tb.name\n    , avg_estimated_impact = dm_migs.avg_user_impact*(dm_migs.user_seeks+dm_migs.user_scans)\n    , last_user_seek = dm_migs.last_user_seek\n    , create_index ='""'CREATE INDEX [IX_' + OBJECT_NAME(details.OBJECT_ID,details.database_id) +""""'_' +""'REPLACE(''REPLACE(''REPLACE(''ISNULL(details.equality_columns,'""''),""""', ',""""'_'),""""'[',""""''),""""']',""""'') +""'CASE''WHEN details.equality_columns''IS''NOT''NULL''AND details.inequality_columns''IS''NOT''NULL''THEN'""'_'""'ELSE'""''""'END +''REPLACE(''REPLACE(''REPLACE(''ISNULL(details.inequality_columns,'""''),""""', ',""""'_'),""""'[',""""''),""""']',""""'') +""""']' +""""' ON ' + details.statement +""""' (' +""'ISNULL (details.equality_columns,'""'') +""'CASE''WHEN details.equality_columns''IS''NOT''NULL''AND details.inequality_columns''IS''NOT''NULL''THEN'""','""'ELSE'""''""'END +''ISNULL (details.inequality_columns,'""'') +""""')' +""'ISNULL ('""' INCLUDE (' + details.included_columns +""""')',""""'')""'FROM sys.dm_db_missing_index_groups''AS dm_mig''WITH(NOLOCK)''INNER''JOIN sys.dm_db_missing_index_group_stats''AS dm_migs''WITH(NOLOCK)''ON dm_migs.group_handle = dm_mig.index_group_handle''INNER''JOIN sys.dm_db_missing_index_details''AS details''WITH(NOLOCK)''ON dm_mig.index_handle = details.index_handle''INNER''JOIN sys.tables''AS tb''WITH(NOLOCK)''ON details.object_id = tb.object_id''WHERE details.database_ID = DB_ID()''ORDER''BY Avg_Estimated_Impact''DESC''GO''方法七：使用本地变量''这是一个非常奇怪的解决方法，使用这种方法的原因是，对于本地变量SQL Server使用统计密度来代替统计直方图，它会认为所有的本地变量均拥有相同的统计密度，即对应于相同的记录数。这样可以避免因为数据分布不均匀导致的参数嗅探问题。''USE AdventureWorks2008R2''GO''ALTER''PROCEDURE dbo.UP_GetOrderIDAndOrderQtyByProductID(\n@ProductID''INT )''AS''BEGIN''SET NOCOUNT''ON''DECLARE @Local_ProductID''INT ;''SET @Local_ProductID = @ProductID ;''SELECT SalesOrderDetailID , OrderQty''FROM Sales.SalesOrderDetail''WITH(NOLOCK)''WHERE ProductID = @Local_ProductID''END''GO''至此结束，本节分享了菜鸟和老鸟关于参数嗅探问题的解决方法，我相信大家应该可以轻松的做出正确选择适合自己的解决方法。''转载于:https://www.cnblogs.com/zengpeng/p/9390703.html'"
CSDN,https://blog.csdn.net/weixin_44742328/article/details/115309694,在 Idea 中配置 Maven,vid。,java框架,,2021-03-29 21:26:20,"'1、在 Idea 中配置 Maven''Idea 中也自带 Maven 插件，而且我们也可以给自带的 Maven 插件进行配置，所以我们可以使用自带的 Maven，也可以使用我们安装的 Maven 核心程序''1.配置我们自己安装的 Maven''2.设置 Maven 自动导包''2、 配置本地仓库和阿里云镜像及JDK版本''2.1配置本地仓库''1.Maven 的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插''件来完成。Maven 核心程序会到本地仓库中查找插件。如果本地仓库中''没有就会从远程中央仓库下载。此时如果不能上网则无法执行 Maven 的''具体功能。为了解决这个问题，我们可以将 Maven 的本地仓库指向一个''在联网情况下下载好的目录。''2.Maven 默认的本地仓库：~.m2\\repository 目录。''Tips：~表示当前用户的家目录。''3.找到 Maven 的核心配置文件 settings.xml 文件：''解压目录 D:\\apache-maven-3.6.3\\conf\\settings.xml''4.设置方式''本地仓库的路径''2.2配置阿里云镜像''为了下载 jar 包方便，在 Maven 的核心配置文件 settings.xml 文件的''标签里面配置以下标签：''<''mirror''>''<''id''>''nexus-aliyun''</''id''>''<''mirrorOf''>''central''</''mirrorOf''>''<''name''>''Nexus aliyun''</''name''>''<''url''>''http://maven.aliyun.com/nexus/content/groups/public''</''url''>''</''mirror''>''默认的 JDK 的编译版本是 1.5，在 Maven 的核心配置文''件 settings.xml 文件中添加以下配置将编译版本改为 1.8''<''profile''>''<''id''>''jdk''-''1.8''<''/''id''>''<''activation''>''<''activeByDefault''>''true''<''/''activeByDefault''>''<''jdk''>''1.8''<''/''jdk''>''<''/''activation''>''<''properties''>''<''project''.''build''.''sourceEncoding''>''UTF''-''8''<''/''project''.''build''.''sourceEncoding''>''<''maven''.''compiler''.''source''>''1.8''<''/''maven''.''compiler''.''source''>''<''maven''.''compiler''.''target''>''1.8''<''/''maven''.''compiler''.''target''>''<''maven''.''compiler''.''compilerVersion''>''1.8''<''/''maven''.''compiler''.''compilerVersion''>''<''/''properties''>''<''/''profile''>''3、在 Idea 中创建 Maven 项目''① 点击 File→New→Module…（如果之前没有 Project 选 Project）→Maven''② 点击 Next、坐标（GAV）、路径。不同的 Idea 版本可能有所差别。''③ 配置要继承的模块及其名字''④ 点击 Finish 即可创建成功''⑤ 配置 Maven 的核心配置文件 pom.xml''<?xml version=""1.0"" encoding=""UTF-8""?>''<''project''xmlns''=''""''http://maven.apache.org/POM/4.0.0''""''xmlns:''xsi''=''""''http://www.w3.org/2001/XMLSchema-instance''""''xsi:''schemaLocation''=''""''http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd''""''>''<''modelVersion''>''4.0.0''</''modelVersion''>''<''groupId''>''com.acoffee.maven''</''groupId''>''<''artifactId''>''Hello''</''artifactId''>''<''version''>''1.0-SNAPSHOT''</''version''>''<''dependencies''>''<''dependency''>''<''groupId''>''junit''</''groupId''>''<''artifactId''>''junit''</''artifactId''>''<''version''>''4.11''</''version''>''<''scope''>''test''</''scope''>''</''dependency''>''</''dependencies''>''</''project''>''⑥ 编写主代码''在 src/main/java 目录下创建包并创建 Hello.java 文件''package''com''.''acoffee''.''maven'';''/**\n * @author acoffee\n * @create 2021-03-29 20:42\n */''public''class''Hello''{''public''String''sayHello''(''String name'')''{''return''""Hello""''+''name''+''""!""'';''}''}''⑦ 编写测试代码''在/src/test/java 目录下创建包并创建 HelloTest.java 文件''package''com''.''acoffee''.''maven'';''import''org''.''junit''.''Test'';''/**\n * @author acoffee\n * @create 2021-03-29 20:45\n */''public''class''HelloTest''{''@Test''public''void''testHello''('')''{''Hello hello''=''new''Hello''('')'';''String maven''=''hello''.''sayHello''(''""Maven""'')'';''System''.''out''.''println''(''maven'')'';''}''}''执行结果：''⑨ 使用 Maven 的方式运行 Maven 工程''4、创建 Web 工程（了解）''1.创建简单的 Maven 工程，打包方式为 war 包''<''groupId''>''com''.''acoffee''.''maven''<''/''groupId''>''<''artifactId''>''MavenWeb''<''/''artifactId''>''<''version''>''1.0''-''SNAPSHOT''<''/''version''>''<''!''--''Web工程的打包方式war''--''>''<''packaging''>''war''<''/''packaging''>''2.点击 Project Structure''3.选择对应的 Module，设置 Web 目录''4.弹出提示框，选择版本后点击 OK''5.生成 web.xml 文件''6.设置存放 web 页面文件的目录后点击 OK''7.点击 OK''8.发现项目中多了一个 web 目录，而且目录上有一个蓝点''9. 在 web 目录下创建 index.jsp 页面''10.部署到 Tomcat 上运行''5.在 Idea 中导入 Maven 项目''点击 Project Structure''选中import Moudule单击''找到项目所在的位置''选择 Import module from external model（从外部模型导入模块）→Maven''点击next''然后点击finish''然后即导入完成'"
CSDN,https://blog.csdn.net/weixin_44742328/article/details/115309694,在 Idea 中配置 Maven,vid。,java框架,,2021-03-29 21:26:20,"'1、在 Idea 中配置 Maven''Idea 中也自带 Maven 插件，而且我们也可以给自带的 Maven 插件进行配置，所以我们可以使用自带的 Maven，也可以使用我们安装的 Maven 核心程序''1.配置我们自己安装的 Maven''2.设置 Maven 自动导包''2、 配置本地仓库和阿里云镜像及JDK版本''2.1配置本地仓库''1.Maven 的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插''件来完成。Maven 核心程序会到本地仓库中查找插件。如果本地仓库中''没有就会从远程中央仓库下载。此时如果不能上网则无法执行 Maven 的''具体功能。为了解决这个问题，我们可以将 Maven 的本地仓库指向一个''在联网情况下下载好的目录。''2.Maven 默认的本地仓库：~.m2\\repository 目录。''Tips：~表示当前用户的家目录。''3.找到 Maven 的核心配置文件 settings.xml 文件：''解压目录 D:\\apache-maven-3.6.3\\conf\\settings.xml''4.设置方式''本地仓库的路径''2.2配置阿里云镜像''为了下载 jar 包方便，在 Maven 的核心配置文件 settings.xml 文件的''标签里面配置以下标签：''<''mirror''>''<''id''>''nexus-aliyun''</''id''>''<''mirrorOf''>''central''</''mirrorOf''>''<''name''>''Nexus aliyun''</''name''>''<''url''>''http://maven.aliyun.com/nexus/content/groups/public''</''url''>''</''mirror''>''默认的 JDK 的编译版本是 1.5，在 Maven 的核心配置文''件 settings.xml 文件中添加以下配置将编译版本改为 1.8''<''profile''>''<''id''>''jdk''-''1.8''<''/''id''>''<''activation''>''<''activeByDefault''>''true''<''/''activeByDefault''>''<''jdk''>''1.8''<''/''jdk''>''<''/''activation''>''<''properties''>''<''project''.''build''.''sourceEncoding''>''UTF''-''8''<''/''project''.''build''.''sourceEncoding''>''<''maven''.''compiler''.''source''>''1.8''<''/''maven''.''compiler''.''source''>''<''maven''.''compiler''.''target''>''1.8''<''/''maven''.''compiler''.''target''>''<''maven''.''compiler''.''compilerVersion''>''1.8''<''/''maven''.''compiler''.''compilerVersion''>''<''/''properties''>''<''/''profile''>''3、在 Idea 中创建 Maven 项目''① 点击 File→New→Module…（如果之前没有 Project 选 Project）→Maven''② 点击 Next、坐标（GAV）、路径。不同的 Idea 版本可能有所差别。''③ 配置要继承的模块及其名字''④ 点击 Finish 即可创建成功''⑤ 配置 Maven 的核心配置文件 pom.xml''<?xml version=""1.0"" encoding=""UTF-8""?>''<''project''xmlns''=''""''http://maven.apache.org/POM/4.0.0''""''xmlns:''xsi''=''""''http://www.w3.org/2001/XMLSchema-instance''""''xsi:''schemaLocation''=''""''http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd''""''>''<''modelVersion''>''4.0.0''</''modelVersion''>''<''groupId''>''com.acoffee.maven''</''groupId''>''<''artifactId''>''Hello''</''artifactId''>''<''version''>''1.0-SNAPSHOT''</''version''>''<''dependencies''>''<''dependency''>''<''groupId''>''junit''</''groupId''>''<''artifactId''>''junit''</''artifactId''>''<''version''>''4.11''</''version''>''<''scope''>''test''</''scope''>''</''dependency''>''</''dependencies''>''</''project''>''⑥ 编写主代码''在 src/main/java 目录下创建包并创建 Hello.java 文件''package''com''.''acoffee''.''maven'';''/**\n * @author acoffee\n * @create 2021-03-29 20:42\n */''public''class''Hello''{''public''String''sayHello''(''String name'')''{''return''""Hello""''+''name''+''""!""'';''}''}''⑦ 编写测试代码''在/src/test/java 目录下创建包并创建 HelloTest.java 文件''package''com''.''acoffee''.''maven'';''import''org''.''junit''.''Test'';''/**\n * @author acoffee\n * @create 2021-03-29 20:45\n */''public''class''HelloTest''{''@Test''public''void''testHello''('')''{''Hello hello''=''new''Hello''('')'';''String maven''=''hello''.''sayHello''(''""Maven""'')'';''System''.''out''.''println''(''maven'')'';''}''}''执行结果：''⑨ 使用 Maven 的方式运行 Maven 工程''4、创建 Web 工程（了解）''1.创建简单的 Maven 工程，打包方式为 war 包''<''groupId''>''com''.''acoffee''.''maven''<''/''groupId''>''<''artifactId''>''MavenWeb''<''/''artifactId''>''<''version''>''1.0''-''SNAPSHOT''<''/''version''>''<''!''--''Web工程的打包方式war''--''>''<''packaging''>''war''<''/''packaging''>''2.点击 Project Structure''3.选择对应的 Module，设置 Web 目录''4.弹出提示框，选择版本后点击 OK''5.生成 web.xml 文件''6.设置存放 web 页面文件的目录后点击 OK''7.点击 OK''8.发现项目中多了一个 web 目录，而且目录上有一个蓝点''9. 在 web 目录下创建 index.jsp 页面''10.部署到 Tomcat 上运行''5.在 Idea 中导入 Maven 项目''点击 Project Structure''选中import Moudule单击''找到项目所在的位置''选择 Import module from external model（从外部模型导入模块）→Maven''点击next''然后点击finish''然后即导入完成'"
CSDN,https://blog.csdn.net/JiunNian/article/details/115443848,使用IDEA配置Maven的方法,久念。JN,Maven,,2021-04-05 16:26:28,'- **IDEA配置Maven的详细过程**''新建项目命名''设置Maven版本、以及Maven仓库''步骤如下：''1.应用jdk''2.命名项目''3.新建项目''4.''5.''5-1 修改maven home directory为maven安装路径''5-2 勾选“Override”将setting文件位置及仓库位置改为自配，修改setting文件位置为 maven安装路径\\conf\\setting.xml''5-3 修改仓库位置为 maven安装路径\\repository''完成。红框即为所需，按顺序操作。'
CSDN,https://blog.csdn.net/dichi4045/article/details/102444421,LINUX替换字符串的几种方法,dichi4045,操作系统,,2019-07-10 18:49:00,"'1. 基本替换'':s/str1/str2/ 替换当前行第一个str1为str2'':s/str1/str2/g 替换当前行所有str1为str2'':n,$s/str1/str2/ 替换第 n 行开始到最后一行中每一行的第一个str1为str2'':n,$s/str1/str2/g 替换第 n 行开始到最后一行中每一行所有str1为str2''（n 为数字，若 n 为 .，表示从当前行开始到最后一行）'':%s/str1/str2/（等同于 :g/str1/s//str2/） 替换每一行的第一个str1为str2'':%s/str1/str2/g（等同于 :g/str1/s//str2/g） 替换每一行中所有str1为str2''2. 可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符'':s#str1/#str2/# 替换当前行第一个str1/ 为str2/'':%s+/str11/str12/+/str21/str22+ （使用+ 来 替换 / ）： /str11/str12/替换成/str21/str22/''3. 文件中删除^M''问题描述：对于换行，Windows下用回车换行（0A0D）来表示，Linux下是回车（0A）来表示。这样，将window上的文件拷到Unix上用时，总会有个^M，请写个用在Unix下的过滤Windows文件的换行符（0D）的shell或c程序。有两种方法可以完成此目的：''(1)使用命令：cat oldfilename | tr -d “^V^M” > newfilename''(2)使用命令：sed -e “s/^V^M//” oldfilename > newfilename''需要注意的是在1、2两种方法中，^V和^M指的是Ctrl+V和Ctrl+M。你必须要手工进行输入，而不是粘贴。''在vim中处理：首先使用vim打开文件，然后按ESC键，接着输入命令：'':%s/^V^M//'':%s/^M$//g''如果上述方法无用，则正确的解决办法是：''(1) tr -d ""\\r"" < old_file_name > new_file_name 或者 cat oldfilename | tr -d ""\\r"" > new_file_name''(2) tr -d ""\\015"" < old_file_name > new_file_name或者 cat oldfilename | tr -d ""\\015"" > new_file_name''strings A>B''4. 其它技巧''利用 :s 命令可以实现字符串的替换。具体的用法包括：'':s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1'':s/str1/str2/g 用字符串 str2 替换行中所有出现的字符串 str1'':.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1'':1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1'':g/str1/s//str2/g 功能同上''从上述替换命令可以看到：g 放在命令末尾，表示对搜索字符串的每次出现进行替换；不加 g，表示只对搜索字符串的首次出现进行替换；g 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作。''（2）sed命令替换字符串''sed替换的基本语法为:''代码如下:''sed'""'s/原字符串/替换字符串/'""'单引号里面,s表示替换,三根斜线中间是替换的样式,''特殊字符''需要使用反斜线”\\”进行转义,但是单引号”‘”是没有办法用反斜线”\\”转义的,这时候只要把命令中的单引号改为双引号就行了,例如:''代码如下:''sed ""s/原字符串包含\'/替换字符串包含\'/""''//要处理的字符包含单引号''命令中的三根斜线分隔符可以换成别的符号,这在要替换的内容有较多斜线是较为方便,只需要紧跟s定义即可,例如换成问号”?”:''代码如下:'""sed 's?原字符串?替换字符串?'""'//自定义分隔符为问号''可以在末尾加g替换每一个匹配的关键字,否则只替换每行的第一个,例如:''代码如下:'""sed 's/原字符串/替换字符串/'""'//替换所有匹配关键字''上箭头”^”表示行首,美元”$”符号如果在引号中表示行尾,但是在引号外却表示末行(最后一行),这里犯二了,搜了半天哪个符号表示首行,半天才想起来,首行就是数字”1″啊.那么在行首和行尾添加字符串就是把行尾和行首替换,例如:''代码如下:'""sed 's/^/添加的头部&/g' //在所有行首添加""'sed'""'s/$/&添加的尾部/g' //在所有行末添加""""sed '2s/原字符串/替换字符串/g' //替换第2行""'sed'""'$s/原字符串/替换字符串/g' //替换最后一行""""sed '2,5s/原字符串/替换字符串/g' //替换2到5行""'sed'""'2,$s/原字符串/替换字符串/g' //替换2到最后一行""'替换样式可以多个在同一条命令中执行,用分号”;”分隔,例如:''代码如下:'""sed 's/^/添加的头部&/g；s/$/&添加的尾部/g'""'//同时执行两个替换规则''sed处理过的输出是直接输出到屏幕上的,要保存可以将输出重定向,或者使用参数”i”直接在文件中替换:''代码如下:'""sed -i 's/原字符串/替换字符串/g' filename""'//替换文件中的所有匹配项''转载于:https://www.cnblogs.com/zengpeng/p/11165840.html'"
CSDN,https://blog.csdn.net/blogdevteam/article/details/103478461,博客帮助文档,CSDN官方博客,帮助文档,,2019-12-11 14:46:59,"'目录''博客积分规则''博客等级''C币规则（试运营）''博客VIP文章说明''博客专家''如何成为博客专家？''企业博客''如何开通企业博客''博客勋章''分类专栏''博客搬家''自定义百度统计''CSDN博客用户准则''总则：''博客注册''博客行为规则''被投诉侵权用户处理规则''附则''博客评论活跃等级规则（试运营）''Markdown帮助''付费专栏开通规则''博客积分规则''博客积分是CSDN对用户努力的认可和奖励，也是衡量博客水平的重要标准。博客等级也将由博客积分唯一决定。积分规则具体如下：''1、每发布一篇原创或者翻译文章：可获得10分；''2、每发布一篇转载文章：可获得2分；''3、博主的文章每被评论一次：可获得1分；''4、每发表一次评论：可获得1分（自己给自己评论、博主回复评论不获得积分）；''5、博文阅读次数每超过100次：可获得1分，阅读加分最高加到100分，即文章点击上万次截止；''6、文章被管理员或博主本人删除，相应减去博主基于该篇博文所获得的分数；''7、评论被管理员或博主删除，相应减去发评论者和博主基于该评论各自获得的分数（博主应减积分不会动态实时去掉，是每周固定时间清理一次）；''8、另外会开设相应的抄袭举报功能，一旦举报证实某篇原创文章抄袭，将扣除博主该篇文章相应的得分。''博客等级''图标''等级''所需积分''L1''0''L2''100''L3''400''L4''800''L5''1600''L6''4500''L7''9000''L8''25000''L9''50000''L10''100000''L11''200000''L12''300000''L13''500000''L14''800000''L15''1000000''C币规则（试运营）''什么是C币''查看详细C币规则''博客VIP文章说明''博主专享福利,发付费文章后可获得返利。''VIP文章即读者购买VIP付费后才可解锁阅读的文章，拥有VIP文章发表权限的作者可以发表VIP文章。''发VIP文章,根据文章购买转化数据返利(详见收益中心:''https://order.csdn.net/myorder/revenue''）''如何取消VIP可读：进入该篇文章的编辑页面，在“发布形式”模块取消选择“VIP可见”重新发布''博客专家''“博客专家”是CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定。''成为博客专家后会得到什么：''用户头像上显示“专家”勋章；''发布博客时可以直接引用CSDN站外的图片；''有机会免费参加CSDN举办的各种会议；''有机会成为CSDN学院讲师、CSDN博乐、CSDN问答导师等；''有更多演讲机会，CSDN会推荐给厂商或者各种IT技术大会作为演讲嘉宾；''享有月度原创奖励，C币、图书或定制礼品；''享有自定义模块、自定义域名、全站免广告等权益；''文章获得更多的推荐机会：博客专家所发的文章都会进入文章预选库，我们有专门的编辑负责从中筛选优质内容，并推荐到CSDN首页或其他内容频道。''注意情况：''所有博客专家（包括荣誉专家）均为实名制；''CSDN博客专家在三个月内如果没有发布任何原创或翻译博文，其博客专家身份将自动取消，转为博客频道荣誉专家，不能继续享有博客专家的福利；''CSDN博客专家不是CSDN博客的全职或兼职管理人员，不具备CSDN博客的管理权力，其观点及行为仅代表个人，不代表CSDN官方立场；''CSDN博客专家如有违反CSDN网站规则的行为，如大量发布广告或软文，对CSDN网站造成不良影响等，将永久取消其CSDN博客专家身份；希望恢复博客专家身份可重新申请，''点击这里申请博客专家''。''如何成为博客专家？''申请CSDN博客专家应具备的条件：''在CSDN坚持写作三年及以上；''原创技术文章总数超过100篇，并且最近6个月内有一定的活跃度；''博客文章总浏览量超过20万次以上，同时参考点赞、评论、收藏等交互数据；''原创文章占比80%以上，且文章内容有一定深度；''企业、团队等非个人开设的博客，需要原创技术文章总数超过150篇，并且最近一个月内发布了新的原创技术文章，博文总浏览量超30万次才能申请博客专家；''其他情况：''在CSDN学院成功发布过课程的博主可适当放宽要求；''如果已经在某IT领域具有较大影响力，但是尚没有达到上述申请条件的用户，可以通过现有博客专家或者CSDN编辑部的推荐，暂时成为“特约专家”，待达到上述条件之后，再转为正式的博客专家（申请用户自成为“特约专家”后六个月内如仍未达到CSDN博客专家应具备的条件，则“特约专家”身份取消）。''CSDN已开通博客专家在线申请功能，''点击这里申请博客专家''。''企业博客''CSDN企业博客旨在利用CSDN站内流量、内容、用户等资源，为技术型企业提供营销推广平台''企业博客免费版主要功能如下：''1、优质企业博文可提高推荐权重；''2、支持设置自定义主题图，方便更换企业品牌形象及广告图；''3、企业博客内无联盟广告展示；''4、企业博客有专属身份标识；''5、企业博客内的相关推荐内容为该企业自己的博文；''6、支持设置自定义背景色，支持添加自定义链接导航（目前最多可添加五个）；''7、支持百度关键词查询；''8、搜索专区。''如何开通企业博客''企业博客已经开通在线申请功能，''点击这里开通企业博客''CSDN管理员在收到您的申请后，会在2个工作日内开通服务。如有问题可以直接发信至tobblog@csdn.net咨询。''博客勋章''博客专家''CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定。成为博客专家后会得到我们一系列的服务，如在头像上加象征荣誉的专家勋章、有专人对接提供服务、文章获得更多的推荐机会、不定时获得CSDN的礼品、优先获得CSDN举办的各种会议的的门票等。''博客之星''授予在“CSDN年度博客之星评选”中获得“博客之星”称号的用户。为了鼓励专业、乐于分享的广大CSDN博客用户。每年12月的CSDN博客之星评选中，综合专家评审和大众投票的结果，评选出“CSDN年度博客之星”。''1024勋章''#1024程序员节#活动勋章，当日发布原创博客即可获得''1024超级勋章''授予原创文章总数达到1024篇的博主，感谢你对CSDN社区的贡献，CSDN与你一起成长。''勤写标兵Lv1''授予每个自然周发布1篇到3篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv2''授予每个自然周发布4篇到6篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv3''授予每个自然周发布7篇到8篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv4''授予每个自然周发布9篇以上（包括9篇）原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''分类专栏''分类专栏是把相同标签属性的技术博文聚集起来，集中展示，系统全面，更具目标性。CSDN鼓励每位博主撰写专属自己的专栏博文，构建自己的知识体系。''发布分类专栏建议：''1. 每个专栏至少发布10篇原创技术博文。''2. 博文紧扣专栏主题，技术定位清晰，内容扎实详尽。''CSDN博客频道编辑定期会把精华分类专栏荐给相应的受众群体。''博客搬家''CSDN是IT技术网站，欢迎大家发布原创或翻译IT技术类博客，非IT技术类博客将不提供搬家服务。博主可以''点击这里''申请博客搬家。''CSDN推出博客搬家功能，目前支持以下站点的博客搬迁：''博客园，微信公众号，简书，51CTO.com,新浪，开源中国，chinaUnix,个人博客，掘金，GitHub,知乎，segmentfault''。''温馨提示：''原创技术文章不能少于10篇方可申请。''原博客数据不会丢失，仍然保留。''如果检测到恶意导入，您的博客使用将会受到影响。''审核通过的搬家申请，会持续与搬家源进行内容同步（个人博客和github同步历史文章）。''审核时间一般为1个工作日，审核结果将通过站内信等方式告知。''同一个站点只允许进行1次搬家申请，如申请失败则需要重新申请。''对博客搬家有任何问题或建议请向博客客服邮箱发邮件咨询：webmaster@csdn.net。''声明：CSDN用户要完成博客搬家需要承诺搬迁的博客为用户本人博客，如搬迁非用户本人博客所产生的后果由用户本人承担。''自定义百度统计''申请方式''百度统计账号查询方式如下图所示''1）登录百度统计账号链接：''https://tongji.baidu.com/sc-web/home/site/getjs''2）路径是：管理/代码管理/代码获取''CSDN博客用户准则''总则：''第1条 CSDN博客隶属于CSDN（包括CSDN网站与相应客户端、自媒体平台、主运营网站等），是为中国的软件开发者、IT从业者及其他人员提供以交流IT技术为主的网络社区。''第2条 为保障CSDN博客健康发展，维护用户正当权益，规范信息发布行为，依据国家有关法律、法规、政策及CSDN相关规定，制定本博客用户准则（以下称“本准则”）。''第3条 CSDN经营者（即北京创新乐知网络技术有限公司及其他相关联的公司）无法对用户传播内容的权属、合法性、真实性、科学性、完整性等问题进行实质审查，博客用户须对自己发布的内容独立承担责任，CSDN经营者不承担因此产生的任何法律责任。''第4条 为保障CSDN博客的专业性与集成性，博客用户的交流不得涉及任何政治话题，CSDN博客用户须严格按照本准则的规定行使权利和履行义务。''博客注册''第1条 拟注册用户在CSDN博客进行注册时，需要按照提示填写详尽的用户信息（包括但不限于姓名或名称、身份证号码、邮箱、联系方式等），并对提供信息的真实性负责。在用户信息发生变动时，用户有责任及时更新、修改信息。如果博客用户提供的信息资料不准确，CSDN经营者保留终止用户使用CSDN博客提供的相关网络服务的权利。''第2条 CSDN博客用户因提供用户信息不真实、不准确等而发生纠纷或需要帮助时，因不能确认用户身份及其帐号的使用权利，无法向用户提供相应的帮助所带来的一切后果由用户自己承担。''第3条 CSDN经营者尊重用户隐私，未经用户合法授权，不会公开或透露其注册资料。''第4条 用户注册并激活成功后，便成为CSDN博客的正式用户，正式博客用户拥有CSDN博客规定用户所应享有的一切权限。用户将获得一个用户名和密码，用户对自己的用户名、密码及帐号安全性负全部责任。用户同意，若发现任何非法使用帐号、密码或存在安全漏洞等其它有损用户利益的情况，应立即通知CSDN经营者。每个用户都应对以其用户名进行的所有活动和事件负全部责任。''博客行为规则''第1条 CSDN博客用户享有言论自由的权利，但不得违反法律法规及政策规定，不得违反诚实信用原则及公序良俗，不得损害国家、CSDN经营者及第三方权利及利益，不得违反CSDN用户协议及相关规则。严禁发表含有下列内容的信息：''1.违反宪法确定的基本原则的；''2.危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；''3.损害国家荣誉和利益的；''4.煽动民族仇恨、民族歧视，破坏民族团结的；''5.破坏国家宗教政策，宣扬邪教和封建迷信的；''6.散布谣言，扰乱社会秩序，破坏社会稳定的；''7.散布淫秽、色情、赌博、暴力、恐怖或者教唆犯罪的；''8.侮辱或者诽谤他人，侵害他人合法权益的；''9.煽动非法集会、结社、游行、示威、聚众扰乱社会秩序的；''10.以非法民间组织名义活动的；''11.可能教唆他人犯罪的；''12.可能损害CSDN经营者名誉或商誉等权益的；''13.其他违反中华人民共和国法律、法规、政策，违反诚实信用及公序良俗，或CSDN经营者认为不当及不宜传播的信息。 CSDN博客用户违反上述规定的，CSDN经营者有权在不通知用户的情况下，根据其独立判断，采取删除已发表言论，暂停账户使用，直至取消用户资格等措施。''第2条 CSDN博客用户发表的文章、言论或其他信息仅代表其自身观点与立场，CSDN经营者不对用户发表内容的准确性、合法性、完整性负责。博客用户须承担一切因自己的行为而直接或间接导致的民事、行政或刑事法律责任。在任何情况下，CSDN经营者不承担因用户发表内容而引起的任何损失、损害的法律责任。''第3条 CSDN博客用户不得发布非IT技术内容。''第4条 未经CSDN经营者同意，禁止在博客发布与CSDN提供服务无关的广告。博客管理规则''第1条 CSDN博客的管理权限由博客管理员享有，博客管理员由CSDN经营者正式全职员工担任，并由其按照相关法律、法规、政策以及CSDN规则行使本博客全部站务管理职责和权利，管理员代表本博客官方立场，除管理员之外的任何用户及网友言论或行为，由相关人员自行承担，均与本博客无关。''第2条 用户恶意破坏CSDN博客版块正常秩序（包含但不限于恶意投票、刷流量、刷评论、利用自定义栏目传播病毒、垃圾广告、非法信息等）的，CSDN经营者有权视情节轻重给予警告、删帖、暂停账号使用、注销帐号等处理，并依法追究民事责任及其他法律责任。''被投诉侵权用户处理规则''第一次：封杀，解封时要求文章改为转载并注明出处''第二次：封杀一个月，给予严重警告，解封时要求文章改为转载并注明出处''第三次：不予解封''附则''第1条 CSDN提示博客用户，在用户与通过博客相识的其他用户进行交往时，应遵循谨慎原则。对于博客用户之间相识、交往所发生或可能发生的任何心理、身体上的伤害和经济上的损失与纠纷，由相关用户自行承担一切法律责任，CSDN经营者不承担任何法律责任。''第2条 本准则如存在与国家法律、法规或司法解释、政策等有冲突的条款，以届时有效的国家法律、法规或司法解释、政策等为准。本准则的其余条款仍然有效并具有约束力。''第3条 CSDN经营者有权对本准则进行修改，相关条款修改后，CSDN经营者将在相关页面公布修改的内容，修改后的条款一经公布即有效的代替原条款。用户如不同意相关条款的修改，可立即停止访问或使用CSDN博客或取消已经获得的服务；如用户选择在本准则修改后继续访问或使用CSDN博客，则视为用户已接受相关条款的修改。''第4条 用户接受本准则的内容，并不能完全涵盖用户使用CSDN博客所产生的权利和义务，CSDN经营者公布的其他声明、规则等均视为本准则之补充条款，为本准则不可分割的组成部分，与本准则具有同等法律效力。''第5条 本准则自发布之日起生效。''第6条 本准则最终解释权归北京创新乐知网络技术有限公司所有。''博客评论活跃等级规则（试运营）''评论活跃等级是CSDN对用户在博客评论区活跃程度的辨别标准，旨在鼓励读者和博主互动交流，提高用户活跃度。活跃等级规则具体如下（该规则适用于所有用户）：''1、所有用户初始评论次数均为零''2、活跃等级用评论次数衡量，评论次数越多，等级越高''3、超过10天没有进行任何评论，等级称谓变成“潜水”，初始评论次数清零''4、发布评论且审核通过后计算当前的有效评论数，根据当前的有效评论数展示不同的“评论等级称谓”''5、该规则从2020年4月23日起开始执行，在此之前进行的评论不予计算，仅计算该日期以后进行的有效评论''以下是评论次数对应的评论等级称谓''评论等级称谓''评论次数区间''潜水''0次''码哥''1-3次''码农''4-7次''码工''8-15次''码皇''16-31次''码神''32-63次''爱码士''64次以上''Markdown帮助''# 欢迎使用Markdown编辑器写博客''---------------------------''撤销：Ctrl/Command + Z''重做：Ctrl/Command + Y''加粗：Ctrl/Command + B''斜体：Ctrl/Command + I''标题：Ctrl/Command + Shift + H''无序列表：Ctrl/Command + Shift + U''有序列表：Ctrl/Command + Shift + O''检查列表：Ctrl/Command + Shift + C''插入代码：Ctrl/Command + Shift + K''插入链接：Ctrl/Command + Shift + L''插入图片：Ctrl/Command + Shift + G''标题''---------------------------''# 1级标题''## 2级标题''### 3级标题''#### 四级标题''##### 五级标题''###### 陆级标题''文本样式''---------------------------''*强调文本* _强调文本_''**加粗文本** __加粗文本__''==标记文本==''~~删除文本~~''> 引用文本''H~2~O is是液体。''2^10^ 运算结果是 1024。''列表''---------------------------''- 项目''* 项目''+ 项目''1. 项目1''2. 项目2''3. 项目3''- [ ] 计划任务''- [x] 完成任务''链接''---------------------------''链接: [link](https://mp.csdn.net).''图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg)''带尺寸的图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg =30x30)''代码片''---------------------------''下面展示一些 `内联代码片`。''```''// A code block'""var foo = 'bar';""'```''```javascript''// An highlighted block'""var foo = 'bar';""'```''1. 代码片必须手动声明代码语言类型''2. 目前支持代码类型: `markup`、`html`、`svg`、`xml`、`c`、`clike`、`cpp`、`csharp`、`java`、`vbnet`、`go`、`ruby/rb`、`python/py`、`php`、`sql`、`perl`、`objectivec`、`swift`、`javascript/js`、`css`、`handlebars`、`bash`、`kotlin`''3. 代码片主题''默认主题为：Atom One Dark''可以前往 [**写作中心/博客设置**](https://mp.csdn.net/configure) 在**代码片样式**项进行更改''表格''---------------------------''项目 | Value''-------- | -----''电脑 | $1600''手机 | $12''导管 | $1''| Column 1 | Column 2 |''|:--------:| -------------:|''| centered 文本居中 | right-aligned 文本居右 |''自定义列表''---------------------------''Markdown'': Text-to-HTML conversion tool''Authors'': John'': Luke''注脚''---------------------------''一个具有注脚的文本。[^1]''[^1]: 注脚的解释''注释''---------------------------''Markdown将文本转换为 HTML。''*[HTML]: 超文本标记语言''KaTex 数学公式''---------------------------''Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall''n\\in\\mathbb N$ 是通过 Euler integral''$$''\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.''$$''新的数学公式使用了KaTex，其语法与 LaTex基本一致，但也有一些不同的地方，具体请参考KaTex官方使用文档： [https://katex.org/docs/supported.html](https://katex.org/docs/supported.html)''插入甘特图''---------------------------''```mermaid''gantt''dateFormat YYYY-MM-DD''title Adding GANTT diagram functionality to mermaid''section 现有任务''已完成 :done, des1, 2014-01-06,2014-01-08''进行中 :active, des2, 2014-01-09, 3d''计划中 : des3, after des2, 5d''```''插入UML图''------------''```mermaid''sequenceDiagram''张三 ->> 李四: 你好！李四, 最近怎么样?''李四-->>王五: 你最近怎么样，王五？''李四--x 张三: 我很好，谢谢!''李四-x 王五: 我很好，谢谢!''Note right of 王五: 李四想了很长时间, 文字太长了''不适合放在一行.''李四-->>张三: 打量着王五...''张三->>王五: 很好... 王五, 你怎么样?''```''插入Mermaid流程图''--------''```mermaid''graph LR''A[长方形] -- 链接 --> B((圆))''A --> C(圆角长方形)''B --> D{菱形}''C --> D''```''插入Flowchart流程图''-------''```mermaid''flowchat''st=>start: 开始''e=>end: 结束''op=>operation: 我的操作''cond=>condition: 确认？''st->op->cond''cond(yes)->e''cond(no)->op''```''付费专栏开通规则''付费专栏是博主根据自己想变现的意愿而选择的一项可变现的产品，开通付费专栏事项须知：''付费专栏开通提交前，请认真阅读《CSDN付费专栏写作协议》，知晓双方的权利与义务''专栏文章需为原创文章且不少于15篇，每篇文章字数不得少于5000字（包括代码片段内字符数量）''专栏申请需提交审核，审核时间1-2个工作日''专栏定价，博主可以按照从系统已设定好的价格里选择定价''确保专栏内容无违规、违法、广告等不当内容''专栏一旦设置为收费，审核通过以后，无法取消，请谨慎操作'"
CSDN,https://blog.csdn.net/westos_linux/article/details/78968012,如何使用IntelliJ IDEA 配置Maven,西部开源教育,idea,,2018-01-04 10:17:24,"'IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的Java开发工具之一, IDEA是JetBrains公司的产品,现在有逐步取代老牌Java开发工具Eclipse的趋势.那本人也是从Eclipse 转到IDEA.那刚转换过来时,确实很不适应,不过好在坚持使用了几天后,确实感觉IntelliJ IDEA比Eclipse更加智能.''Maven项目对象模型(POM)，是一个项目管理工具可以通过一小段描述信息来管理项目的构建，报告和文档的软件。那我们想要在IDEA中使用Maven得进行一些配置,那接下来''我们具体看一下是如何配置使用的?''一、''首先我们得去''Maven的官网去下载Maven''网址'':''http://maven.apache.org/download.cgi''二、''进入''Maven官网后如下图点击下载''三、''解压此''Maven的压缩包,注意不要解压到中文路径下,切记!!!\xa0如图''四、''解压完后'',Maven这个工具就算安装好了,但是我们还需要配置一下Maven的环境变量''五、此电脑――右键――属性――高级系统设置――环境变量――系统变量――新建――变量名和变量值''六、''在系统变量''PATH中引入你配置的变量名: \xa0MAVAEN_HOME%MAVEN_HOME%\\bin;''七、''下面我们配置一下''Maven''的本地仓库路径'',首先找到解压Maven的目录''找到''conf-――settings.xml这个配置文件打开''打开''settings.xml''配置文件''选一个本地的目录作为''Maven本地仓库将配置好''<localRepository>D:\\my_maven_local_repository</localRepository>''八、''至此我们的''Maven''工具就算安装并配置好了''.''九、''接下来我们看下''Maven''如何在''Intellij\xa0IDEA''中设置''?首先打开IDEA''选择''File――Settings''十、我们还可以在勾选一些其他选项''十一、''我们可以更新一下本地仓库和远程仓库'',这个样在pom.xml文件中添加依赖jia包的坐标时就可以很好的提示出来.''好了到此'',我们在IDEA也就配置好Maven,''那下次我们看一下如何在''IDEA中创建Maven工程.'"
CSDN,https://blog.csdn.net/westos_linux/article/details/78850564,揭秘：Python为什么这么火，高中生都要学？,西部开源教育,程序员,,2017-12-20 10:44:38,'近日连高中生即将在《信息技术》课程中加入''python了！！！已经被写死的第一批90后深刻感叹：真的快成废柴了。90后危机意识都陡增了，而大人们却还在一起pia pia打脸，真不知是唱得哪出戏。''我们都在主导人生的路上摸爬滚打，每天体会着丧，受着质疑，干着雾霾，每天上班，月底成为信用卡的''“老赖”，''难道晚上在夜里的炒面摊上都要对月饮杯鸡血，''“我很努力，明天加油”。喝鸡汤，已经思考不了人生了。Piapia 打脸已经唤不起“狼性”了，人生苦短，重塑狼性，整点Python吧。''Python狼的重要地位''根据''TIOBE最新排名，Python已经超越C#，与Java、C、C++一起成为全球4大流行语言。Python的设计理念是无所不用其极地适合人的直觉，所以获得了“可执行的伪代码”美誉，这让Python学习者的注意力无需过多纠缠于语法等细节，而可以更多地集中在“程序设计思维”，这是初学编程最重要的东西。''python狼有啥好？''Python可以从小让你就开始培养严谨的编程习惯，养成用计算机来解决问题的习惯。国内近十年来也慢慢注意到这个问题，认识到了中小学生学习编程的重要性和开设有关课程的必要性，很多教育工作者们慢慢发现VB并不适合高中信息技术课程的教学（其实现在很多大学也已经取消了VB编程的课程），对大学的学习也没有什么太大帮助，无法快速解决相关领域的问题，难以适应信息技术飞速发展的趋势。浙江、北京等多个省市比较有眼光、有远见的一部分教育工作者和有关领导在几年前就开始寻找和反复论证更适合中学生认知特点的编程语言，并最终确定了Python。''Python是一门开源的编程语言，有大量狂热的爱好者在分享自己的代码和劳动成果，而分享也是Python精神之一。中学生学习Python，在更大程度上有利于养成分享和合作的良好习惯，而这对于以后的科研生涯和日常生活毫无疑问是非常重要的。''Python狼真的有这么复杂吗？''Python一向以简单易学而著称，其语法简洁并且功能强大，编程模式符合人类思维习惯，非常适合描述和表达我们的思想，可以说是简单到可怕。''新手学习几个月就可以快速实现特定领域的算法并解决相关领域的实际问题，例如数据库应用、网站开发、软件逆向工程、网络爬虫、游戏开发、数字图像处理、人工智能、大数据处理、深度学习等等，大幅度降低了学习和应用的成本，正所谓''“人生苦短，我用Python”。''其他语言需要几十甚至上百行代码才能解决的问题，在''Python中只需要短短几行代码，使用Python入门学习编程可以极大促进学生的兴趣。''Python成为真正的职场“狼”''Python的应用特别广，中国现在人才缺口超过100万，在国内，豆瓣、搜狐、金山、盛大、网易、百度、阿里、红帽等企业中涉及Linux运维、web开发、大数据、人工智能都在广泛应用。'
CSDN,https://blog.csdn.net/JiunNian/article/details/115443848,使用IDEA配置Maven的方法,久念。JN,Maven,,2021-04-05 16:26:28,'- **IDEA配置Maven的详细过程**''新建项目命名''设置Maven版本、以及Maven仓库''步骤如下：''1.应用jdk''2.命名项目''3.新建项目''4.''5.''5-1 修改maven home directory为maven安装路径''5-2 勾选“Override”将setting文件位置及仓库位置改为自配，修改setting文件位置为 maven安装路径\\conf\\setting.xml''5-3 修改仓库位置为 maven安装路径\\repository''完成。红框即为所需，按顺序操作。'
CSDN,https://blog.csdn.net/westos_linux/article/details/79103526,Openstack云计算平台部署――环境篇,西部开源教育,openstack,,2018-01-19 10:16:19,"'刚考完红帽''RHCA''云计算课''-EX210 (openstack V10)''，对''openstack''云计算平台有了更深的认识，回来后又心血来潮从头搞了一遍，把部署过程给大家整理出来，帮助''openstack''的初学者少踩坑，老鸟可以跳过了。''红帽''EX210''的考试环境是''i7cpu + 32G''内存''+ 500G SATA''（''256G SSD''更好），回来就没有那么高的配置了，看来过年该给自己升级下装备了，其实自己搭个''Openstack''实验环境满足以下最小需求即可：''控制节点：''1 处理器, 4 GB 内存, 及5 GB 存储''计算节点：''1 处理器, 2 GB 内存, 及10 GB 存储''具体可以参考官方文档：''https://docs.openstack.org/mitaka/zh_CN/install-guide-rdo/''，当前官方最新版是Pike''，推荐大家从''Mitaka''版开始，因为这个版本文档官方翻译了中文，哈哈！''实验环境如下：''物理机配置：i5 cpu + 8G''内存''+ 256G SSD''（勉强够用，''cpu''和内存都要升级）''KVM''虚拟机配置：控制节点''1vcpu + 4G''内存''+ 10G''存储''+ RHEL7.3''最小化安装''计算节点''1vcpu + 2G''内存''+ 10G''存储''+ RHEL7.3''最小化安装''存储节点可选''所有节点禁用''Selinux''和''firewalld''服务，''selinux''是个坑。需要具备一定的红帽''Linux''操作系统能力，毕竟''openstack''是部署在''Linux''系统平台上的，生产环境部署强烈推荐使用红帽企业版''Linux''系统，''ubuntu''系统是个坑哦。''控制节点配置：''网络配置：''RHEL7''引入了新的命名规则，网卡命名类似这样：''ifcfg-enp0s8''，如果还是喜欢''RHEL6''的方式，可以''在''启动''虚拟机''时传递''“net.ifnames=0”的内核参数''从而修改''RHEL7''系统对网卡接口的命名方式，写入''/boot/grub2/grub.cfg''文件可以永久保存。''[root@controller network-scripts]# cat ifcfg-eth0''TYPE=Ethernet''BOOTPROTO=static''IPADDR=172.25.0.11''PREFIX=24''GATEWAY=172.25.0.250''DNS1=114.114.114.114''UUID=8f9d8331-384a-4d56-ab74-91ac001e1aa8''DEVICE=eth0''ONBOOT=yes''[root@controller network-scripts]# cat ifcfg-eth1''TYPE=Ethernet''BOOTPROTO=none''DEVICE=eth1''ONBOOT=yes''所有节点主机名需要解析：''127.0.0.1 \xa0\xa0localhost''172.25.0.11 \xa0\xa0\xa0controller''172.25.0.12 \xa0\xa0\xa0compute1''启用''NTP''服务：''# yum install chrony -y''# vim /etc/chrony.conf''server time1.aliyun.com iburst #''阿里云''ntp''服务器''time1-7.aliyun.com''allow 192.168.0.0/24''# systemctl enable chronyd''# systemctl restart chronyd''所有''openstack''节点的时间都必须一致，不然会导致无法启动虚拟机。''Openstack''安装源''：''# rpm -ivh rdo-release-mitaka-6.noarch.rpm''# yum upgrade #''系统更新，如果更新了内核需要重启。''# yum install openstack-selinux #''系统启动''selinux''的话需要安装，''自动管理''OpenStack 服务的安全策略''（也不是绝对可以解决，踩过坑）''# yum install python-openstackclient -y # openstack''的客户端''# yum install mariadb mariadb-server python2-PyMySQL -y''# vim /etc/my.cnf.d/openstack.cnf''[mysqld]''bind-address = 172.25.0.11 #''控制节点的管理网络''IP地址''default-storage-engine = innodb''innodb_file_per_table #''独享表空间''max_connections = 4096 #''最大连接数，默认''1024''collation-server = utf8_general_ci''character-set-server = utf8''# systemctl enable mariadb.service''# systemctl start mariadb.service''# mysql_secure_installation''创建数据库并授权：''MariaDB [(none)]> CREATE DATABASE keystone;''Query OK, 1 row affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON keystone.* TO 'keystone'@'localhost' IDENTIFIED BY 'keystone';""'Query OK, 0 rows affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON keystone.* TO 'keystone'@'%' IDENTIFIED BY 'keystone';""'Query OK, 0 rows affected (0.00 sec)''MariaDB [(none)]> CREATE DATABASE glance;''Query OK, 1 row affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'localhost' IDENTIFIED BY 'glance';""'Query OK, 0 rows affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'%' IDENTIFIED BY 'glance';""'Query OK, 0 rows affected (0.00 sec)''MariaDB [(none)]> CREATE DATABASE nova_api;''Query OK, 1 row affected (0.00 sec)''MariaDB [(none)]> CREATE DATABASE nova;''Query OK, 1 row affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'localhost' IDENTIFIED BY 'nova';""'Query OK, 0 rows affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'%'\xa0IDENTIFIED BY 'nova';""'Query OK, 0 rows affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'localhost'\xa0IDENTIFIED BY 'nova';""'Query OK, 0 rows affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'%' IDENTIFIED BY 'nova';""'Query OK, 0 rows affected (0.00 sec)''MariaDB [(none)]> CREATE DATABASE neutron;''Query OK, 1 row affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'localhost' IDENTIFIED BY 'neutron';""'Query OK, 0 rows affected (0.00 sec)'""MariaDB [(none)]> GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'%'\xa0IDENTIFIED BY 'neutron';""'消息队列''RabbiMQ''：''[root@controller ~]# yum install rabbitmq-server -y''[root@controller ~]# systemctl enable rabbitmq-server.service''[root@controller ~]# systemctl start rabbitmq-server.service''[root@controller ~]# netstat -antlp |grep :5672''tcp6 \xa0\xa0\xa0\xa0\xa0\xa00 \xa0\xa0\xa0\xa0\xa00 :::5672 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0:::* \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0LISTEN \xa0\xa0\xa0\xa0\xa0873/beam''添加''openstack''用户，密码''openstack''：''[root@controller ~]# rabbitmqctl add_user openstack openstack''Creating user ""openstack"" ...''给''openstack''用户授权：''[root@controller ~]# rabbitmqctl set_permissions openstack "".*"" "".*"" "".*""''Setting permissions for user ""openstack"" in vhost ""/"" ...''列出可用插件：''[root@controller\xa0~]# rabbitmq-plugins list''Configured: E = explicitly enabled; e = implicitly enabled''| Status: \xa0\xa0* = running on rabbit@controller''|/''[ \xa0] amqp_client \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] cowboy \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01.0.3''[ \xa0] cowlib \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01.0.1''[ \xa0] mochiweb \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02.13.1''[ \xa0] rabbitmq_amqp1_0 \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_auth_backend_ldap \xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_auth_mechanism_ssl \xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_consistent_hash_exchange 3.6.5''[ \xa0] rabbitmq_event_exchange \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_federation \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_federation_management \xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_jms_topic_exchange \xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_management \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_management_agent \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_management_visualiser \xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_mqtt \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_recent_history_exchange \xa01.2.1''[ \xa0] rabbitmq_sharding \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa00.1.0''[ \xa0] rabbitmq_shovel \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] ra6bbitmq_shovel_management \xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_stomp \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_top \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_tracing \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_trust_store \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_web_dispatch \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_web_stomp \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] rabbitmq_web_stomp_examples \xa0\xa0\xa0\xa0\xa0\xa03.6.5''[ \xa0] sockjs \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa00.3.4''[ \xa0] webmachine \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa01.10.3''启动插件：''[root@controller\xa0~]# rabbitmq-plugins enable rabbitmq_management''The following plugins have been enabled:''mochiweb''webmachine''rabbitmq_web_dispatch''amqp_client''rabbitmq_management_agent''rabbitmq_management''Applying plugin configuration to rabbit@controller... started 6 plugins.''默认管理插件监听端口是15672''：''配置''memcached''服务：''认证服务认证缓存使用''Memcached缓存令牌。缓存服务memecached运行在控制节点。在生产部署中，我们推荐联合启用防火墙、认证和加密保证它的安全。''# yum install -y memcached python-memcached''rhel7''下''memcached''默认监听''127.0.0.1:11211''，配置监听本机所有接口：''# vim /etc/sysconfig/memcached''PORT=""11211""''USER=""memcached""''MAXCONN=""1024""''CACHESIZE=""64""''#OPTIONS=""-l 127.0.0.1,::1""''OPTIONS=""""''# systemctl enable memcached.service''# systemctl start memcached.service'"
CSDN,https://blog.csdn.net/weixin_30872789/article/details/95792320,Linux平台下快速搭建FTP服务器,weixin_30872789,操作系统,,2016-09-19 11:56:00,'FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。''一般在各种linux的发行版中，默认带有的ftp软件是vsftp，从各个linux发行版对vsftp的认可可以看出，vsftp应该是一款不错的ftp软件。''1、检查安装vsftpd软件''使用如下命令#''rpm -qa''|grep vsftpd''可以检测出是否安装了vsftpd软件，如果没有安装，使用YUM命令进行安装''yum''install''vsftpd -y''2、启动服务''使用vsftpd软件，主要包括如下几个命令：''启动ftp命令''#service vsftpd start''停止ftp命令''#service vsftpd stop''重启ftp命''#service vsftpd restart''3、vsftpd的配置''ftp的配置文件主要有三个，位于/etc/vsftpd/目录下，分别是：''ftpusers 该文件用来指定那些用户不能访问ftp服务器。''user_list 该文件用来指示的默认账户在默认情况下也不能访问ftp''vsftpd.conf vsftpd的主配置文件''4、以匿名用户登录''我们去掉配置文件vsftpd.conf 里面以下''anon_upload_enable=''YES''anon_mkdir_write_enable=''YES''两项前面的#号，就可以完成匿名用户的配置，此时匿名用户既可以登录上传、下载文件。记得修改配置文件后需要重启服务。''5、非匿名账户的创建与使用''vsftpd服务与系统用户是相互关联的，例如我们创建一个名为testwww''#useradd testwww''#passwd testwww''6、登录方式（非vsftp机器）''浏览器打开 ：''浏览器上输入''ftp:''//vsftp所在机器ip/''文件打开 ：''文件夹输入''ftp:''//vsftp所在机器ip/ ；''右键可以选择登录''cmd ：''dos中输入''ftp''vsftp所在机器ip  \n 输入用户名，密码''xftp登录：''小细节''默认sftp可以登录，但是ftp不能登录；需要在''vsftpd.conf加入ftp的默认端口(sftp 默认端口22)。''listen_port''=''21''转载于:https://www.cnblogs.com/itrena/p/5927115.html'
CSDN,https://blog.csdn.net/yanmh007/article/details/116132424,创建react项目附带typescript模板命令,闫 先生,React,,2021-04-25 16:32:38,'创建react项目附带typescript模板命令''npx create-react-app my-app --template typescript'
CSDN,https://blog.csdn.net/yanmh007/article/details/107310146,Linux搭建ftp服务器,闫 先生,技术提升,,2020-07-13 09:50:04,'Linux搭建ftp服务器''安装''vsftpd''# yum -y install vsftpd''进入到安装目录下进行配置''# cd /etc/vsftpd''你会看到以下的文件''其中 FtpResources文件夹是自己手动创建的，后面会告诉你这个文件夹怎么创建，这里可以忽略。''ftpusers和user_list是配置哪些用户可以登陆到ftp服务器；''vsftpd.conf是主要配置；''如过你现在不做任何配置的修改，你现在就可以访问ftp服务，当然这是匿名访问，没有任何的用户登陆限制，这就说明可能任何人都可以在你的这台ftp服务器上操作上传和下载，也就没有文件的保密性。''一般来说我们会将某些特定的账户进行ftp登陆的访问、上传、下载等操作，所以我们接下来就将配置以下我们某些特定的用户来进行访问，限制匿名访问我们的ftp服务资源。''首先在当前目录下创建用户访问的资源文件夹''FtpResources''，编辑配置文件：''# vi vsftpd.conf''修改几项配置参数：\n    1: anonymous_enable=NO # 这是不可匿名访问\n    2: anon_root=/etc/vsftpd/FtpResources # 这是匿名时资源文件访问的主目录\n    3：local_root=/etc/vsftpd/FtpResources # 这是非匿名时资源文件访问的主目录\n    4: userlist_enable=YES # 在/etc/vsftpd/user_list 文件中列出用户不能访问FTP 服务器\n    5: userlist_deny=NO # 当userlist_enable=YES时配置生效，user_list文件才会被使用，当其为NO时，无论userlist_deny项为何值都是无效的，本地全体用户（除去ftpusers中的用户）都可以登入FTP\n   \n## 当userlist_enable=YES时，userlist_deny=YES时：user_list是一个黑名单，即：所有出现在名单中的 用户都会被拒绝登入；\n## 当userlist_enable=YES时，userlist_deny=NO时：user_list是一个白名单，即：只有出现在名单中的用 户才会被准许登入''如果你想了解其他的配置信息，自行搜索哈哈哈哈哈哈哈其什么意思。''创建可以登陆访问ftp的用户''# useradd ftpuser -s /sbin/nologin # 创建ftpuser用户不允许登陆ssh\n# passwd ftpuser # 修改ftpuser的密码''将刚创建好的用户添加到 /etc/vsftpd/''重启vsftpd服务''service vsftpd restart''访问会提示你登陆用户名密码，输入正确如果进不到主目录文件夹下，修改以下配置''进入/etc/pam.d将vsftpd文件中的pam_shells.so改为pam_nologin.so，然后systemctl restart vsftpd重启服务，连接ftp成功''centos下vsftpd不能显示文件，不能创建文件及文件夹''centos下vsftpd登录正常，但不能显示文件，不能创建文件及文件夹 这是由于selinux的机制''通过命令 [root@localhost\xa0www]#\xa0getsebool\xa0-a|grep\xa0ftp \xa0可以看到如下信息\n\n\n\nallow_ftpd_anon_write --> off\nallow_ftpd_full_access --> off//创建文件及文件夹 \xa0\nallow_ftpd_use_cifs --> off\nallow_ftpd_use_nfs --> off\nftp_home_dir --> off\xa0//显示文件夹及文件 \xa0\nftpd_connect_db --> off\nftpd_use_fusefs --> off\nftpd_use_passive_mode --> off\nhttpd_enable_ftp_server --> off\ntftp_anon_write --> off\ntftp_use_cifs --> off\ntftp_use_nfs --> off''用如下命令把以上信息设为ON''[root@localhost\xa0www]#\xa0setsebool\xa0allow_ftpd_full_access=1 \xa0\n\n之后再用命令\xa0getsebool\xa0-a|grep\xa0ftp 查看\n\nallow_ftpd_anon_write --> off\nallow_ftpd_full_access --> on//创建文件及文件夹\nallow_ftpd_use_cifs --> off\nallow_ftpd_use_nfs --> off\nftp_home_dir --> off\nftpd_connect_db --> off\nftpd_use_fusefs --> off\nftpd_use_passive_mode --> off\nhttpd_enable_ftp_server --> off\ntftp_anon_write --> off\ntftp_use_cifs --> off\ntftp_use_nfs --> off''这个时候刷新下ftp，就发现目录都显示出来了，再试试添加目录，添加文件操作都可以进行了，问题解决。'
CSDN,https://blog.csdn.net/weixin_33857679/article/details/90353038,【vue】webpack打包vue项目并且运行在Tomcat里面,weixin_33857679,java,,2017-09-09 20:43:39,"'在package.json里面是script加入脚本''""publish"": "" webpack --config webpack.publish.config.js  -p""''编写webpack.publish.config.js''const webpack=require(""webpack"");\nconst path = require(\'path\');\nconst node_modules = path.resolve(__dirname, \'node_modules\');\nconst UglifyJsPlugin = webpack.optimize.UglifyJsPlugin;\nconst ExtractTextPlugin = require(""extract-text-webpack-plugin"");\nconst HtmlwebpackPlugin=require(""html-webpack-plugin"");\nconst CleanWebpackPlugin = require(\'clean-webpack-plugin\');\nmodule.exports = {\n    entry: {\n            app:path.resolve(__dirname,\'src/main.js\'),\n            vendors:[\'vue\']     \n        },\n    output: {\n        path: path.resolve(__dirname, \'dist/app\'),\n        filename: \'static/js/[name].js\',\n    },\n    module: {\n        loaders: [ \n           {\n                test:/\\.vue$/,\n                loader:\'vue-loader\'\n            },\n            {\n                test: /\\.css$/,\n                use: ExtractTextPlugin.extract({\n                    use: \'css-loader\',\n                    fallback: \'style-loader\'\n                })\n            },\n            {\n                test:/\\.js$/,\n                loader:\'babel-loader\',\n                exclude:/node_modules/,\n                query: {\n                    presets: [\'es2015\']\n                 }  \n            },\n            {\n                test:/\\.less$/,\n                loader:\'style-loader!css-loader!autoprefixer-loader!less-loader\'\n            },\n            {\n                test:/\\.scss$/,\n                loader:\'style-loader!css-loader!autoprefixer-loader!sass-loader\'\n            },\n            {\n                 test: /\\.(png|jpg|gif)$/,\n                 loader:\'url-loader?limit=8192&name=./static/img/[name].[ext]\'      \n            },\n            {\n                 test: /\\.(ttf|woff|svg|eot|woff2)$/,\n                 loader:\'url-loader?limit=8192&name=./static/font/[name].[ext]\'     \n            } \n \n        ]\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({ \n            name: \'vendor\', \n            filename: \'vendor.bundle.js\', \n            minChunks: Infinity \n        }),\n        new UglifyJsPlugin({\n            compress:{\n                warnings:false\n            }\n        }),\n        new ExtractTextPlugin(""static/css/styles.css""),\n        new HtmlwebpackPlugin({\n            title: \'index\',  //生成的页面标题\n            filename: \'index.html\', //生成的文件名称\n            template: \'index.html\' //根据index1.html这个模板来生成\n            \n        }),\n        new webpack.ProvidePlugin({  \n            $:""jquery"",  \n            jQuery:""jquery"",  \n            ""windows.jQuery"":""jquery""  \n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \'manifest\' //But since there are no more common modules between them we end up with just the runtime code included in the manifest file\n        }),\n        new CleanWebpackPlugin(\n            [\'dist/app/main.*.js\',\'dist/app/manifest.*.js\',],\u3000 //匹配删除的文件\n            {\n                root: __dirname,       \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000//根目录\n                verbose:  true,        \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000//开启在控制台输出信息\n                dry:      false        \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000//启用删除文件\n        })\n    ]\n}''执行打包命令''npm run publish''准备一个javaWeb项目''index.html放入web-inf文件夹中''static目录放在webapp中''写一个转发的方法转发到index.html''private static final String Index = ""index"";\n \n@RequestMapping(value = {"""",""index""},method = RequestMethod.GET)\npublic ModelAndView toIndex(){\n    ModelAndView view = new ModelAndView(Index );\n    return view;\n \n}''个人菜逼，大牛勿喷'"
CSDN,https://blog.csdn.net/weixin_33857679/article/details/90353038,【vue】webpack打包vue项目并且运行在Tomcat里面,weixin_33857679,java,,2017-09-09 20:43:39,"'在package.json里面是script加入脚本''""publish"": "" webpack --config webpack.publish.config.js  -p""''编写webpack.publish.config.js''const webpack=require(""webpack"");\nconst path = require(\'path\');\nconst node_modules = path.resolve(__dirname, \'node_modules\');\nconst UglifyJsPlugin = webpack.optimize.UglifyJsPlugin;\nconst ExtractTextPlugin = require(""extract-text-webpack-plugin"");\nconst HtmlwebpackPlugin=require(""html-webpack-plugin"");\nconst CleanWebpackPlugin = require(\'clean-webpack-plugin\');\nmodule.exports = {\n    entry: {\n            app:path.resolve(__dirname,\'src/main.js\'),\n            vendors:[\'vue\']     \n        },\n    output: {\n        path: path.resolve(__dirname, \'dist/app\'),\n        filename: \'static/js/[name].js\',\n    },\n    module: {\n        loaders: [ \n           {\n                test:/\\.vue$/,\n                loader:\'vue-loader\'\n            },\n            {\n                test: /\\.css$/,\n                use: ExtractTextPlugin.extract({\n                    use: \'css-loader\',\n                    fallback: \'style-loader\'\n                })\n            },\n            {\n                test:/\\.js$/,\n                loader:\'babel-loader\',\n                exclude:/node_modules/,\n                query: {\n                    presets: [\'es2015\']\n                 }  \n            },\n            {\n                test:/\\.less$/,\n                loader:\'style-loader!css-loader!autoprefixer-loader!less-loader\'\n            },\n            {\n                test:/\\.scss$/,\n                loader:\'style-loader!css-loader!autoprefixer-loader!sass-loader\'\n            },\n            {\n                 test: /\\.(png|jpg|gif)$/,\n                 loader:\'url-loader?limit=8192&name=./static/img/[name].[ext]\'      \n            },\n            {\n                 test: /\\.(ttf|woff|svg|eot|woff2)$/,\n                 loader:\'url-loader?limit=8192&name=./static/font/[name].[ext]\'     \n            } \n \n        ]\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({ \n            name: \'vendor\', \n            filename: \'vendor.bundle.js\', \n            minChunks: Infinity \n        }),\n        new UglifyJsPlugin({\n            compress:{\n                warnings:false\n            }\n        }),\n        new ExtractTextPlugin(""static/css/styles.css""),\n        new HtmlwebpackPlugin({\n            title: \'index\',  //生成的页面标题\n            filename: \'index.html\', //生成的文件名称\n            template: \'index.html\' //根据index1.html这个模板来生成\n            \n        }),\n        new webpack.ProvidePlugin({  \n            $:""jquery"",  \n            jQuery:""jquery"",  \n            ""windows.jQuery"":""jquery""  \n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \'manifest\' //But since there are no more common modules between them we end up with just the runtime code included in the manifest file\n        }),\n        new CleanWebpackPlugin(\n            [\'dist/app/main.*.js\',\'dist/app/manifest.*.js\',],\u3000 //匹配删除的文件\n            {\n                root: __dirname,       \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000//根目录\n                verbose:  true,        \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000//开启在控制台输出信息\n                dry:      false        \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000//启用删除文件\n        })\n    ]\n}''执行打包命令''npm run publish''准备一个javaWeb项目''index.html放入web-inf文件夹中''static目录放在webapp中''写一个转发的方法转发到index.html''private static final String Index = ""index"";\n \n@RequestMapping(value = {"""",""index""},method = RequestMethod.GET)\npublic ModelAndView toIndex(){\n    ModelAndView view = new ModelAndView(Index );\n    return view;\n \n}''个人菜逼，大牛勿喷'"
CSDN,https://blog.csdn.net/woshimeihuo/article/details/85772751,tomcat + vue打包部署，图片访问绝对路径设置,魅惑青花瓷,前端,,2019-01-04 13:55:50,'vue vsCode打包 路径设置''1.部署tomcat，打包vue项目，将打包好后的项目放在tomcat的webapps下''2.设置图片访问路径，tomcat的conf的server.xml中，添加这一句''3.图片的保存路径是''4.图片的访问是''5.vue设置打包路径是在config目录下的index.js中'
CSDN,https://blog.csdn.net/woshimeihuo/article/details/85772751,tomcat + vue打包部署，图片访问绝对路径设置,魅惑青花瓷,前端,,2019-01-04 13:55:50,'vue vsCode打包 路径设置''1.部署tomcat，打包vue项目，将打包好后的项目放在tomcat的webapps下''2.设置图片访问路径，tomcat的conf的server.xml中，添加这一句''3.图片的保存路径是''4.图片的访问是''5.vue设置打包路径是在config目录下的index.js中'
CSDN,https://blog.csdn.net/weixin_30872789/article/details/95792320,Linux平台下快速搭建FTP服务器,weixin_30872789,操作系统,,2016-09-19 11:56:00,'FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。''一般在各种linux的发行版中，默认带有的ftp软件是vsftp，从各个linux发行版对vsftp的认可可以看出，vsftp应该是一款不错的ftp软件。''1、检查安装vsftpd软件''使用如下命令#''rpm -qa''|grep vsftpd''可以检测出是否安装了vsftpd软件，如果没有安装，使用YUM命令进行安装''yum''install''vsftpd -y''2、启动服务''使用vsftpd软件，主要包括如下几个命令：''启动ftp命令''#service vsftpd start''停止ftp命令''#service vsftpd stop''重启ftp命''#service vsftpd restart''3、vsftpd的配置''ftp的配置文件主要有三个，位于/etc/vsftpd/目录下，分别是：''ftpusers 该文件用来指定那些用户不能访问ftp服务器。''user_list 该文件用来指示的默认账户在默认情况下也不能访问ftp''vsftpd.conf vsftpd的主配置文件''4、以匿名用户登录''我们去掉配置文件vsftpd.conf 里面以下''anon_upload_enable=''YES''anon_mkdir_write_enable=''YES''两项前面的#号，就可以完成匿名用户的配置，此时匿名用户既可以登录上传、下载文件。记得修改配置文件后需要重启服务。''5、非匿名账户的创建与使用''vsftpd服务与系统用户是相互关联的，例如我们创建一个名为testwww''#useradd testwww''#passwd testwww''6、登录方式（非vsftp机器）''浏览器打开 ：''浏览器上输入''ftp:''//vsftp所在机器ip/''文件打开 ：''文件夹输入''ftp:''//vsftp所在机器ip/ ；''右键可以选择登录''cmd ：''dos中输入''ftp''vsftp所在机器ip  \n 输入用户名，密码''xftp登录：''小细节''默认sftp可以登录，但是ftp不能登录；需要在''vsftpd.conf加入ftp的默认端口(sftp 默认端口22)。''listen_port''=''21''转载于:https://www.cnblogs.com/itrena/p/5927115.html'
CSDN,https://blog.csdn.net/one__tiger/article/details/107781464,关于IDEA配置maven环境,one__tiger,maven,,2020-08-04 10:51:45,'由于IDEA创建maven项目时从国外的默认下载源下载所需文件时速度极其缓慢，所以我们可以采用下载maven至本地并把下载源设置成国内的方式来提升下载速度。''1、下载maven''大家可以通过这个地址来下载maven到本地磁盘。''http://maven.apache.org/download.cgi''大家也可以通过其他方式找到对应的版本，我的是3.6.1版本，写这篇文章的时候官网只有3.5.*跟3.6.3的下载了，所以本文章还是继续以3.6.1版本来配置。''2、配置环境变量''1）配置MAVEN_HOME''2）配置MAVEN_OPTS（这个的目的是为了使maven的编码方式设置成UTF-8，默认为电脑的编码格式）''值为：-Xms256m -Xmx512m -Dfile.encoding=UTF-8''3）在Path里添加%MAVEN_HOME%\\bin''3、设置本地仓库''1）新建本地仓库，我把仓库建在安装路径外面，不想破坏原本目录的结构''2）在apache-maven-3.6.1\\conf\\setting.xml中配置本地仓库的路径''<''localRepository''>''D://ProgramData//maven//local_repository''</''localRepository''>''4、设置国内的下载源''<''mirror''>''<''id''>''aliyunmaven''</''id''>''<''mirrorOf''>''central''</''mirrorOf''>''<''name''>''阿里云公共仓库''</''name''>''<''url''>''https://maven.aliyun.com/repository/public''</''url''>''</''mirror''>''具体放置的位置如下''5、检查配置完成''我们可以在cmd窗口中输入mvn -v或者mvn -version来查看maven版本及相关信息''6、在IDEA中添加本地的maven''现在我们来到了最后一步，在IDEA中设置本地的maven''1）打开IDEA的设置''2）找到Maven选项后，对下面红框框出来的三个目录进行配置，配置那个setting文件的时候需要勾选Override才可以设置，仓库地址的话会自动识别setting里设置的路径，没有的话再自己选''以上就是在IDEA配置本地maven的全部内容，谢谢观看'
CSDN,https://blog.csdn.net/qq_38684504/article/details/89069987,Linux中搭建FTP服务器，FTP安全部署（匿名、本地、虚拟用户的管理）,橘子女侠,Linux,,2019-04-07 15:18:22,'1. 实验环境：''Linux rhel6.5 作为vsftp服务器，IP地址为：202.100.10.3，网络连接――VMnet8；''Win7 虚拟机作为客户机，IP地址为：202.100.10.30，网络连接――VMnet8；''2. 实验步骤：''（1）前期测试''1.1> 首先在服务器上安装vsftp服务，并启动；''1.2> 配置服务器端的IP地址，结果如下；''1.3> 禁用selinux服务；''1.4> 查看ftp服务的共享文件的目录，/var/ftp，可以看到pub目录；''1.5> 配置win7虚拟机的IP地址如下所示，使其与vsftp服务器在同一个网段；''1.6> 测试是否可以ping通vsftp服务器；''1.7> 在客户机上查看vsftp服务器的文件；可以看到成功访问；''1.8> 在客户机的命令行界面尝试连接ftp服务，以匿名身份访问，可以成功访问到pub目录；由下图可以看出，匿名用户访问ftp服务，默认的根目录就是ftp服务器共享文件的目录/var/ftp/，不能轻易访问服务器的其他目录；''1.9> 匿名用户不能访问服务器的其他目录，那么如果是本地用户账户呢？是否可以访问到服务器的其他目录呢？''首先我们在服务器上创建一个本地账户zhangsan，密码123，并在zhangsan的家目录下创建一个文件zhang；尝试用客户机进行远程连接；''1.10> 尝试用客户机进行远程连接；''通过上述示例，可以发现当远程登录本地账户时，除了查看ftp服务器的共享目录的文件外，还可以查看服务器的其他目录，甚至进行其他操作，很容易造成各种风险；所以，针对这种问题，我们可以采取虚拟用户的方式进行解决；''（2）FTP虚拟用户''2.1> 虚拟用户的本地用户映射；''2.2> 建立虚拟用户的数据库文件；''2.3> 虚拟用户身份认证文件；''2.4> 修改配置文件并重启服务；''2.5> 虚拟用户的配置文件如下所示，我们先不做任何配置，可以用建立的虚拟用户进行测试；''2.6> 猜想：用虚拟账户远程登录进去的默认目录为vsftp?''为了将猜想得到验证，所以在vsftp建立一个文件guest，用虚拟用户yaoyao远程连接进行测试，查看是否可以看到新建立的文件；''2.7> 通过下图可以看到，切换到根目录时，依然还是默认的登陆进去的目录，说明虚拟账户建立成功，但是并没有像猜想到的那样看到guest文件，这是由于虚拟用户的权限没有配置；所以看不到guest文件；''2.8> 在如下目录下，配置虚拟用户的权限，Tom用户不做任何配置，rose，yaoyao，cqq用户的配置分别如下所示：''2.9> 分别用四个虚拟账户进行登录，查看各自的权限；''Tom账户登录；默认没有权限；''Rose账户登录；读、写、上传权限；''yaoyao账户登录；读、写、上传、创建文件夹权限；''cqq账户登录；读、写、上传，建文件夹、删除、更名权限；'
CSDN,https://blog.csdn.net/qq_38684504/article/details/89069987,Linux中搭建FTP服务器，FTP安全部署（匿名、本地、虚拟用户的管理）,橘子女侠,Linux,,2019-04-07 15:18:22,'1. 实验环境：''Linux rhel6.5 作为vsftp服务器，IP地址为：202.100.10.3，网络连接――VMnet8；''Win7 虚拟机作为客户机，IP地址为：202.100.10.30，网络连接――VMnet8；''2. 实验步骤：''（1）前期测试''1.1> 首先在服务器上安装vsftp服务，并启动；''1.2> 配置服务器端的IP地址，结果如下；''1.3> 禁用selinux服务；''1.4> 查看ftp服务的共享文件的目录，/var/ftp，可以看到pub目录；''1.5> 配置win7虚拟机的IP地址如下所示，使其与vsftp服务器在同一个网段；''1.6> 测试是否可以ping通vsftp服务器；''1.7> 在客户机上查看vsftp服务器的文件；可以看到成功访问；''1.8> 在客户机的命令行界面尝试连接ftp服务，以匿名身份访问，可以成功访问到pub目录；由下图可以看出，匿名用户访问ftp服务，默认的根目录就是ftp服务器共享文件的目录/var/ftp/，不能轻易访问服务器的其他目录；''1.9> 匿名用户不能访问服务器的其他目录，那么如果是本地用户账户呢？是否可以访问到服务器的其他目录呢？''首先我们在服务器上创建一个本地账户zhangsan，密码123，并在zhangsan的家目录下创建一个文件zhang；尝试用客户机进行远程连接；''1.10> 尝试用客户机进行远程连接；''通过上述示例，可以发现当远程登录本地账户时，除了查看ftp服务器的共享目录的文件外，还可以查看服务器的其他目录，甚至进行其他操作，很容易造成各种风险；所以，针对这种问题，我们可以采取虚拟用户的方式进行解决；''（2）FTP虚拟用户''2.1> 虚拟用户的本地用户映射；''2.2> 建立虚拟用户的数据库文件；''2.3> 虚拟用户身份认证文件；''2.4> 修改配置文件并重启服务；''2.5> 虚拟用户的配置文件如下所示，我们先不做任何配置，可以用建立的虚拟用户进行测试；''2.6> 猜想：用虚拟账户远程登录进去的默认目录为vsftp?''为了将猜想得到验证，所以在vsftp建立一个文件guest，用虚拟用户yaoyao远程连接进行测试，查看是否可以看到新建立的文件；''2.7> 通过下图可以看到，切换到根目录时，依然还是默认的登陆进去的目录，说明虚拟账户建立成功，但是并没有像猜想到的那样看到guest文件，这是由于虚拟用户的权限没有配置；所以看不到guest文件；''2.8> 在如下目录下，配置虚拟用户的权限，Tom用户不做任何配置，rose，yaoyao，cqq用户的配置分别如下所示：''2.9> 分别用四个虚拟账户进行登录，查看各自的权限；''Tom账户登录；默认没有权限；''Rose账户登录；读、写、上传权限；''yaoyao账户登录；读、写、上传、创建文件夹权限；''cqq账户登录；读、写、上传，建文件夹、删除、更名权限；'
CSDN,https://blog.csdn.net/killerabby/article/details/88667418,在Mac下的IntelliJ IDEA配置Maven,killerabby,,,2019-03-19 17:22:24,"'前提：在Tomcat/Java/Idea编译器环境变量都配好的情况下配置''一.在maven官网下载相应的安装包并解压''二.将文件命名为apache-maven并拷贝到/library下，请开启你的终端旅行（含泪提示:我当时拷贝到/usr/local下发现，无论怎么样都测试不成功，后来改成/library就ok了，具体原因我不清楚，排除了编辑文件出错、保存出错）''配置环境变量->vi ~/.bash_profile''按i进入编辑模式''添加->export M2_HOME=/library/apache-maven''export PATH=$PATH:$M2_HOME/bin''按esc退出编辑模式，保存命令为->:wq''如果在退出保存时遇到一下问题，解决的方法有两种：''1.直接输入->:wq!''2.先输入->:set noreadonly->回车->:wq''使编辑后的文件生效->source ~/.bash_profile''测试->mvn -v或mvn -version''如图已成功''三.IntelliJ IDEA配置''1.打开IntelliJ IDEA->preference->Plugins中选择Maven Integration和Maven Integration Extension->Apply''2.Build,Execution,Deployment->Build Tools->Maven->OK''然后maven就算是配置好啦''出现的问题：export M=$PATH:/usr/local/apache-maven-3.6.0/bin-->这就是我当时配置时遇到错误但是修改为-->export M2_HOME=/library/apache-maven就ok了。''这是记录以前第一次去尝试配置，当初有一些小问题我还没想通，到时后期再更新下我解决了的问题。若有言语或者技术性上的错误希望各位及时指出让我可以纠正，知道我遇到的问题也可以留言指点下，十分感激！'"
CSDN,https://blog.csdn.net/killerabby/article/details/88667418,在Mac下的IntelliJ IDEA配置Maven,killerabby,,,2019-03-19 17:22:24,"'前提：在Tomcat/Java/Idea编译器环境变量都配好的情况下配置''一.在maven官网下载相应的安装包并解压''二.将文件命名为apache-maven并拷贝到/library下，请开启你的终端旅行（含泪提示:我当时拷贝到/usr/local下发现，无论怎么样都测试不成功，后来改成/library就ok了，具体原因我不清楚，排除了编辑文件出错、保存出错）''配置环境变量->vi ~/.bash_profile''按i进入编辑模式''添加->export M2_HOME=/library/apache-maven''export PATH=$PATH:$M2_HOME/bin''按esc退出编辑模式，保存命令为->:wq''如果在退出保存时遇到一下问题，解决的方法有两种：''1.直接输入->:wq!''2.先输入->:set noreadonly->回车->:wq''使编辑后的文件生效->source ~/.bash_profile''测试->mvn -v或mvn -version''如图已成功''三.IntelliJ IDEA配置''1.打开IntelliJ IDEA->preference->Plugins中选择Maven Integration和Maven Integration Extension->Apply''2.Build,Execution,Deployment->Build Tools->Maven->OK''然后maven就算是配置好啦''出现的问题：export M=$PATH:/usr/local/apache-maven-3.6.0/bin-->这就是我当时配置时遇到错误但是修改为-->export M2_HOME=/library/apache-maven就ok了。''这是记录以前第一次去尝试配置，当初有一些小问题我还没想通，到时后期再更新下我解决了的问题。若有言语或者技术性上的错误希望各位及时指出让我可以纠正，知道我遇到的问题也可以留言指点下，十分感激！'"
CSDN,https://blog.csdn.net/yanmh007/article/details/107310146,Linux搭建ftp服务器,闫 先生,技术提升,,2020-07-13 09:50:04,'Linux搭建ftp服务器''安装''vsftpd''# yum -y install vsftpd''进入到安装目录下进行配置''# cd /etc/vsftpd''你会看到以下的文件''其中 FtpResources文件夹是自己手动创建的，后面会告诉你这个文件夹怎么创建，这里可以忽略。''ftpusers和user_list是配置哪些用户可以登陆到ftp服务器；''vsftpd.conf是主要配置；''如过你现在不做任何配置的修改，你现在就可以访问ftp服务，当然这是匿名访问，没有任何的用户登陆限制，这就说明可能任何人都可以在你的这台ftp服务器上操作上传和下载，也就没有文件的保密性。''一般来说我们会将某些特定的账户进行ftp登陆的访问、上传、下载等操作，所以我们接下来就将配置以下我们某些特定的用户来进行访问，限制匿名访问我们的ftp服务资源。''首先在当前目录下创建用户访问的资源文件夹''FtpResources''，编辑配置文件：''# vi vsftpd.conf''修改几项配置参数：\n    1: anonymous_enable=NO # 这是不可匿名访问\n    2: anon_root=/etc/vsftpd/FtpResources # 这是匿名时资源文件访问的主目录\n    3：local_root=/etc/vsftpd/FtpResources # 这是非匿名时资源文件访问的主目录\n    4: userlist_enable=YES # 在/etc/vsftpd/user_list 文件中列出用户不能访问FTP 服务器\n    5: userlist_deny=NO # 当userlist_enable=YES时配置生效，user_list文件才会被使用，当其为NO时，无论userlist_deny项为何值都是无效的，本地全体用户（除去ftpusers中的用户）都可以登入FTP\n   \n## 当userlist_enable=YES时，userlist_deny=YES时：user_list是一个黑名单，即：所有出现在名单中的 用户都会被拒绝登入；\n## 当userlist_enable=YES时，userlist_deny=NO时：user_list是一个白名单，即：只有出现在名单中的用 户才会被准许登入''如果你想了解其他的配置信息，自行搜索哈哈哈哈哈哈哈其什么意思。''创建可以登陆访问ftp的用户''# useradd ftpuser -s /sbin/nologin # 创建ftpuser用户不允许登陆ssh\n# passwd ftpuser # 修改ftpuser的密码''将刚创建好的用户添加到 /etc/vsftpd/''重启vsftpd服务''service vsftpd restart''访问会提示你登陆用户名密码，输入正确如果进不到主目录文件夹下，修改以下配置''进入/etc/pam.d将vsftpd文件中的pam_shells.so改为pam_nologin.so，然后systemctl restart vsftpd重启服务，连接ftp成功''centos下vsftpd不能显示文件，不能创建文件及文件夹''centos下vsftpd登录正常，但不能显示文件，不能创建文件及文件夹 这是由于selinux的机制''通过命令 [root@localhost\xa0www]#\xa0getsebool\xa0-a|grep\xa0ftp \xa0可以看到如下信息\n\n\n\nallow_ftpd_anon_write --> off\nallow_ftpd_full_access --> off//创建文件及文件夹 \xa0\nallow_ftpd_use_cifs --> off\nallow_ftpd_use_nfs --> off\nftp_home_dir --> off\xa0//显示文件夹及文件 \xa0\nftpd_connect_db --> off\nftpd_use_fusefs --> off\nftpd_use_passive_mode --> off\nhttpd_enable_ftp_server --> off\ntftp_anon_write --> off\ntftp_use_cifs --> off\ntftp_use_nfs --> off''用如下命令把以上信息设为ON''[root@localhost\xa0www]#\xa0setsebool\xa0allow_ftpd_full_access=1 \xa0\n\n之后再用命令\xa0getsebool\xa0-a|grep\xa0ftp 查看\n\nallow_ftpd_anon_write --> off\nallow_ftpd_full_access --> on//创建文件及文件夹\nallow_ftpd_use_cifs --> off\nallow_ftpd_use_nfs --> off\nftp_home_dir --> off\nftpd_connect_db --> off\nftpd_use_fusefs --> off\nftpd_use_passive_mode --> off\nhttpd_enable_ftp_server --> off\ntftp_anon_write --> off\ntftp_use_cifs --> off\ntftp_use_nfs --> off''这个时候刷新下ftp，就发现目录都显示出来了，再试试添加目录，添加文件操作都可以进行了，问题解决。'
CSDN,https://blog.csdn.net/yanmh007/article/details/116132424,创建react项目附带typescript模板命令,闫 先生,React,,2021-04-25 16:32:38,'创建react项目附带typescript模板命令''npx create-react-app my-app --template typescript'
CSDN,https://blog.csdn.net/one__tiger/article/details/107781464,关于IDEA配置maven环境,one__tiger,maven,,2020-08-04 10:51:45,'由于IDEA创建maven项目时从国外的默认下载源下载所需文件时速度极其缓慢，所以我们可以采用下载maven至本地并把下载源设置成国内的方式来提升下载速度。''1、下载maven''大家可以通过这个地址来下载maven到本地磁盘。''http://maven.apache.org/download.cgi''大家也可以通过其他方式找到对应的版本，我的是3.6.1版本，写这篇文章的时候官网只有3.5.*跟3.6.3的下载了，所以本文章还是继续以3.6.1版本来配置。''2、配置环境变量''1）配置MAVEN_HOME''2）配置MAVEN_OPTS（这个的目的是为了使maven的编码方式设置成UTF-8，默认为电脑的编码格式）''值为：-Xms256m -Xmx512m -Dfile.encoding=UTF-8''3）在Path里添加%MAVEN_HOME%\\bin''3、设置本地仓库''1）新建本地仓库，我把仓库建在安装路径外面，不想破坏原本目录的结构''2）在apache-maven-3.6.1\\conf\\setting.xml中配置本地仓库的路径''<''localRepository''>''D://ProgramData//maven//local_repository''</''localRepository''>''4、设置国内的下载源''<''mirror''>''<''id''>''aliyunmaven''</''id''>''<''mirrorOf''>''central''</''mirrorOf''>''<''name''>''阿里云公共仓库''</''name''>''<''url''>''https://maven.aliyun.com/repository/public''</''url''>''</''mirror''>''具体放置的位置如下''5、检查配置完成''我们可以在cmd窗口中输入mvn -v或者mvn -version来查看maven版本及相关信息''6、在IDEA中添加本地的maven''现在我们来到了最后一步，在IDEA中设置本地的maven''1）打开IDEA的设置''2）找到Maven选项后，对下面红框框出来的三个目录进行配置，配置那个setting文件的时候需要勾选Override才可以设置，仓库地址的话会自动识别setting里设置的路径，没有的话再自己选''以上就是在IDEA配置本地maven的全部内容，谢谢观看'
CSDN,https://blog.csdn.net/laizhichen2280/article/details/86760017,Spring Boot+Vue全栈开发实战――花了一个礼拜读懂了这本书,邓高鹃技术专栏,Vue使用,,2019-02-03 16:40:22,'很幸运能够阅读王松老师的《Spring Boot+Vue全栈开发实战》这本书！之前也看过Spring Boot与Vue的相关知识，自己也会使用了Spring Boot+Vue进行开发项目。 就是没有系统的学习一下！当看到这本书的时候也是有一种相见恨晚的感觉。这本书也是从基础入门，最后到写一个项目的过程。下面我就来说说这本书主要的章节，后面每一章节我都会跟大家详细道来，并且在我学习与网友们学习这本说中遇到的问题以及疑惑做一个总结！''在前言这部分总体意思是这样的，作者接触也是用了Spring Boot几年的时候，当时也出了一些教程，我想应该是写写博客之类的吧，如果是课程的话都是有章节的，但这里作者说他的课程搜都是比较零散。加上使用的Spring Boot版本都比较老。所以王松老师就想系统的整理一下自己写的博客整理成为一本相关的图书。于是在百忙当中抽出时间写下这本书。每一个作者在出书的时候大多都是有工作在身，也许写几书书籍就是为了一种梦想吧！''然后介绍了，传统的Spring项目环境配置复杂臃肿，让我们开发者已苦不堪言，Spring Boot带来的全新自动化配置解决方案已出现就受到了极大的关注，使得Spring Boot在两年成为了Java领域的焦点之一。介绍了本书使用Spring Boot 的版本为2.0.4。我个人觉得如果你是新手你就使用跟王松老师一样的版本，如果你是个老鸟那你随便选个高于王松版本，因为Spring Boot版本都是向后兼容的。''王松老师把这本书分为16章：我们来说一下每一个章节：''1、Spring Boot 入门(我想不管是哪本书在第一章都会这么写吧，但我没有跳过这一章，我不知道大家有没有我一样的习惯，往往我看一本书在前面几张的部分我都会反复的看，随说是入门但是我觉得那些事作者对技术的理解，就好这一章，我们就可以看看作者对Spring Boot的理解，你阅读本章它也许会改变你对Spring Boot的认知)''2、Spring Boot 基础配置''3、Spring Boot 整合视图层技术(我看到本章的时候发现王松老师把目录拆分得很详细)''4、Spring Boot 整合Web技术''5、Spring Boot 整合持久层技术''6、Spring Boot 整合NoSQL''7、构建RESTful服务(这技术之前我没有接触过，所以我在那章节化了时间阅读)''8、开发者工具与单元测试''9、Spring Boot 缓存''10、Spring Boot 安全管理''11、Spring Boot 整合Web Socket''12、消息服务''13、企业开发''14、应用监控''15、构建项目与部署''16、微人事项目实战''可以看出1-15章都是对技术的单一学习，到16章就是把所有技术进行整合，大家可以看到本书是《Spring Boot+Vue全栈开发实战》讲了Spring Boot基础的知识，但是到16章直接使用Vue技术。并没有对Vue技术的基础知识讲解。如果大家没有Vue的基础希望大家去阅读我整理的一本《Vue快速入门》这本书！''最后王松老师对这本书做一个读者的定位：需要用Java Web基础的开发者。''本书的代码下载：下载地址可以联系我或者你可以加入到本群975098348(本群只讨论王松老师写的《Spring Boot+Vue全栈开发实战》学习好本书了自动退群)，但是你能看到我对这本说讲解，你应该已经购买了这本书，自己可以下载的啊！其实就是一个百度云！''技术支持：作者的微信邮箱都有我这里就不写出来给大家！'
CSDN,https://blog.csdn.net/yanmh007/article/details/107065871,vue + springboot 项目实战,闫 先生,vue前端栈,,2020-07-01 16:11:29,'项目前端地址''项目后端地址''直接上效果图：''效果图还不错吧，这是有地图可视化，富文本，图表数据的项目，直接开源，分享给小伙伴，有着简单的API，只是很简单，作者的表达能力不怎么好，只能帮大家到这里，对了这还是动态的菜单加权限哦，了解更多的可以直接和我联系，有什么好的点子可以直接给作者评论，我会尽快回复的。API前端项目比较丰富直接下载运行吧'
CSDN,https://blog.csdn.net/laizhichen2280/article/details/86760017,Spring Boot+Vue全栈开发实战――花了一个礼拜读懂了这本书,邓高鹃技术专栏,Vue使用,,2019-02-03 16:40:22,'很幸运能够阅读王松老师的《Spring Boot+Vue全栈开发实战》这本书！之前也看过Spring Boot与Vue的相关知识，自己也会使用了Spring Boot+Vue进行开发项目。 就是没有系统的学习一下！当看到这本书的时候也是有一种相见恨晚的感觉。这本书也是从基础入门，最后到写一个项目的过程。下面我就来说说这本书主要的章节，后面每一章节我都会跟大家详细道来，并且在我学习与网友们学习这本说中遇到的问题以及疑惑做一个总结！''在前言这部分总体意思是这样的，作者接触也是用了Spring Boot几年的时候，当时也出了一些教程，我想应该是写写博客之类的吧，如果是课程的话都是有章节的，但这里作者说他的课程搜都是比较零散。加上使用的Spring Boot版本都比较老。所以王松老师就想系统的整理一下自己写的博客整理成为一本相关的图书。于是在百忙当中抽出时间写下这本书。每一个作者在出书的时候大多都是有工作在身，也许写几书书籍就是为了一种梦想吧！''然后介绍了，传统的Spring项目环境配置复杂臃肿，让我们开发者已苦不堪言，Spring Boot带来的全新自动化配置解决方案已出现就受到了极大的关注，使得Spring Boot在两年成为了Java领域的焦点之一。介绍了本书使用Spring Boot 的版本为2.0.4。我个人觉得如果你是新手你就使用跟王松老师一样的版本，如果你是个老鸟那你随便选个高于王松版本，因为Spring Boot版本都是向后兼容的。''王松老师把这本书分为16章：我们来说一下每一个章节：''1、Spring Boot 入门(我想不管是哪本书在第一章都会这么写吧，但我没有跳过这一章，我不知道大家有没有我一样的习惯，往往我看一本书在前面几张的部分我都会反复的看，随说是入门但是我觉得那些事作者对技术的理解，就好这一章，我们就可以看看作者对Spring Boot的理解，你阅读本章它也许会改变你对Spring Boot的认知)''2、Spring Boot 基础配置''3、Spring Boot 整合视图层技术(我看到本章的时候发现王松老师把目录拆分得很详细)''4、Spring Boot 整合Web技术''5、Spring Boot 整合持久层技术''6、Spring Boot 整合NoSQL''7、构建RESTful服务(这技术之前我没有接触过，所以我在那章节化了时间阅读)''8、开发者工具与单元测试''9、Spring Boot 缓存''10、Spring Boot 安全管理''11、Spring Boot 整合Web Socket''12、消息服务''13、企业开发''14、应用监控''15、构建项目与部署''16、微人事项目实战''可以看出1-15章都是对技术的单一学习，到16章就是把所有技术进行整合，大家可以看到本书是《Spring Boot+Vue全栈开发实战》讲了Spring Boot基础的知识，但是到16章直接使用Vue技术。并没有对Vue技术的基础知识讲解。如果大家没有Vue的基础希望大家去阅读我整理的一本《Vue快速入门》这本书！''最后王松老师对这本书做一个读者的定位：需要用Java Web基础的开发者。''本书的代码下载：下载地址可以联系我或者你可以加入到本群975098348(本群只讨论王松老师写的《Spring Boot+Vue全栈开发实战》学习好本书了自动退群)，但是你能看到我对这本说讲解，你应该已经购买了这本书，自己可以下载的啊！其实就是一个百度云！''技术支持：作者的微信邮箱都有我这里就不写出来给大家！'
CSDN,https://blog.csdn.net/laizhichen2280/article/details/86760017,Spring Boot+Vue全栈开发实战――花了一个礼拜读懂了这本书,邓高鹃技术专栏,Vue使用,,2019-02-03 16:40:22,'很幸运能够阅读王松老师的《Spring Boot+Vue全栈开发实战》这本书！之前也看过Spring Boot与Vue的相关知识，自己也会使用了Spring Boot+Vue进行开发项目。 就是没有系统的学习一下！当看到这本书的时候也是有一种相见恨晚的感觉。这本书也是从基础入门，最后到写一个项目的过程。下面我就来说说这本书主要的章节，后面每一章节我都会跟大家详细道来，并且在我学习与网友们学习这本说中遇到的问题以及疑惑做一个总结！''在前言这部分总体意思是这样的，作者接触也是用了Spring Boot几年的时候，当时也出了一些教程，我想应该是写写博客之类的吧，如果是课程的话都是有章节的，但这里作者说他的课程搜都是比较零散。加上使用的Spring Boot版本都比较老。所以王松老师就想系统的整理一下自己写的博客整理成为一本相关的图书。于是在百忙当中抽出时间写下这本书。每一个作者在出书的时候大多都是有工作在身，也许写几书书籍就是为了一种梦想吧！''然后介绍了，传统的Spring项目环境配置复杂臃肿，让我们开发者已苦不堪言，Spring Boot带来的全新自动化配置解决方案已出现就受到了极大的关注，使得Spring Boot在两年成为了Java领域的焦点之一。介绍了本书使用Spring Boot 的版本为2.0.4。我个人觉得如果你是新手你就使用跟王松老师一样的版本，如果你是个老鸟那你随便选个高于王松版本，因为Spring Boot版本都是向后兼容的。''王松老师把这本书分为16章：我们来说一下每一个章节：''1、Spring Boot 入门(我想不管是哪本书在第一章都会这么写吧，但我没有跳过这一章，我不知道大家有没有我一样的习惯，往往我看一本书在前面几张的部分我都会反复的看，随说是入门但是我觉得那些事作者对技术的理解，就好这一章，我们就可以看看作者对Spring Boot的理解，你阅读本章它也许会改变你对Spring Boot的认知)''2、Spring Boot 基础配置''3、Spring Boot 整合视图层技术(我看到本章的时候发现王松老师把目录拆分得很详细)''4、Spring Boot 整合Web技术''5、Spring Boot 整合持久层技术''6、Spring Boot 整合NoSQL''7、构建RESTful服务(这技术之前我没有接触过，所以我在那章节化了时间阅读)''8、开发者工具与单元测试''9、Spring Boot 缓存''10、Spring Boot 安全管理''11、Spring Boot 整合Web Socket''12、消息服务''13、企业开发''14、应用监控''15、构建项目与部署''16、微人事项目实战''可以看出1-15章都是对技术的单一学习，到16章就是把所有技术进行整合，大家可以看到本书是《Spring Boot+Vue全栈开发实战》讲了Spring Boot基础的知识，但是到16章直接使用Vue技术。并没有对Vue技术的基础知识讲解。如果大家没有Vue的基础希望大家去阅读我整理的一本《Vue快速入门》这本书！''最后王松老师对这本书做一个读者的定位：需要用Java Web基础的开发者。''本书的代码下载：下载地址可以联系我或者你可以加入到本群975098348(本群只讨论王松老师写的《Spring Boot+Vue全栈开发实战》学习好本书了自动退群)，但是你能看到我对这本说讲解，你应该已经购买了这本书，自己可以下载的啊！其实就是一个百度云！''技术支持：作者的微信邮箱都有我这里就不写出来给大家！'
CSDN,https://blog.csdn.net/weixin_44625302/article/details/107288668,springboot+vue项目大型实战（一）后端开发,Nym_车厘子,springboot,,2020-07-12 16:59:53,"'源码下载地址！！！点我''数据库创建表''SET NAMES utf8mb4'';''SET FOREIGN_KEY_CHECKS''=''0'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Table structure''for''book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''DROP TABLE IF EXISTS `book`'';''CREATE TABLE `book`''(''`id`''int''(''10'')''NOT NULL'',''`name`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`author`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`publish`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`pages`''int''(''10'')''NULL DEFAULT NULL'',''`price`''float''(''10'',''2'')''NULL DEFAULT NULL'',''`bookcaseid`''int''(''10'')''NULL DEFAULT NULL'',''`abled`''int''(''255'')''NULL DEFAULT NULL'',''PRIMARY KEY''(''`id`'')''USING BTREE'')''ENGINE''=''InnoDB CHARACTER SET''=''utf8 COLLATE''=''utf8_general_ci ROW_FORMAT''=''Compact'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Records of book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''INSERT INTO `book` VALUES''(''1'','""'上下五千年'""','""'曹操'""','""'中国人民出版社'""',''999'',''99.99'',''10'',''1'')'';''INSERT INTO `book` VALUES''(''2'','""'SPSS统计'""','""'王五'""','""'SPSS出版社'""',''330'',''26.00'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''3'','""'四级必备词汇'""','""'李四'""','""'清华出版社'""',''150'',''17.30'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''4'','""'六级必备词汇'""','""'张三'""','""'北大出版社'""',''220'',''59.00'',''3'',''1'')'';''INSERT INTO `book` VALUES''(''5'','""'高考必备'""','""'王强'""','""'上海出版公司'""',''300'',''27.30'',''4'',''1'')'';''INSERT INTO `book` VALUES''(''6'','""'考研必备'""','""'郭德纲'""','""'天津出版社'""',''225'',''22.80'',''1'',''1'')'';''SET FOREIGN_KEY_CHECKS''=''1'';''1.创建项目''2.勾选的依赖''3.目录结构''4.配置application.yml''spring'':''datasource'':''url'':''jdbc'':''mysql'':''/''/''localhost'':''3306''/''library''?''useUnicode''=''true''&''characterEncoding''=''UTF''-''8''&''serverTimezone''=''Asia''/''Shanghai\n    username'':''root\n    password'':''123456''driver''-''class''-''name'':''com''.''mysql''.''cj''.''jdbc''.''Driver\n  jpa'':''show''-''sql'':''true''properties'':''hibernate'':''format_sql'':''true''server'':''port'':''8181''5.Book实体类（使用JPA）''package''com''.''xyj''.''entity'';''import''lombok''.''Data'';''import''javax''.''persistence''.''Entity'';''import''javax''.''persistence''.''Id'';''/**\n * @author xyj\n * @date 2020/7/12 -15:30\n */''@Entity''@Data''public''class''Book''{''@Id''private''Integer id'';''private''String name'';''private''String author'';''}''6.BookRepository接口''package''com''.''xyj''.''repository'';''import''com''.''xyj''.''entity''.''Book'';''import''org''.''springframework''.''data''.''jpa''.''repository''.''JpaRepository'';''public''interface''BookRepository''extends''JpaRepository''<''Book'',''Integer''>''{''}''7.BookHandleer（实现查询功能）''package''com''.''xyj''.''controller'';''import''com''.''xyj''.''entity''.''Book'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''GetMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RequestMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RestController'';''import''java''.''util''.''List'';''/**\n * @author xyj\n * @date 2020/7/12 -15:45\n */''@RestController''@RequestMapping''(''""/book""'')''public''class''BookHandleer''{''@Autowired''private''BookRepository bookRepository'';''@GetMapping''(''""/findAll""'')''public''List''<''Book''>''findAll''('')''{''return''bookRepository''.''findAll''('')'';''}''}''8.我们可以在测试类中查询BookSpringbootApplicationTests（控制台显示）''package''com''.''xyj'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''junit''.''jupiter''.''api''.''Test'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''boot''.''test''.''context''.''SpringBootTest'';''@SpringBootTest''class''BookSpringbootApplicationTests''{''@Autowired''private''BookRepository bookRepository'';''@Test''void''contextLoads''('')''{''System''.''out''.''println''(''bookRepository''.''findAll''('')'')'';''}''}''9.直接启动springboot项目，在页面可以显示所有查询的数据（我们只查询三个字段进行测试）''10.接下来我们需要与前端交互数据（创建的vue工程都是自动生成的，自己添加一个Book.vue）''补充CVue-cli 3.x 添加axios插件''11.Book.vue（其中data（）{}中的数据都是测试用的，created中是从后端获取的数据C数据库中）''<''template''>''<''div''>''<''table''>''<''tr''>''<''td''>''编号''<''/''td''>''<''td''>''图书名称''<''/''td''>''<''td''>''作者''<''/''td''>''<''/''tr''>''<''tr v''-''for''=''""item in books""''>''<''td''>''{''{''item''.''id''}''}''<''/''td''>''<''td''>''{''{''item''.''name''}''}''<''/''td''>''<''td''>''{''{''item''.''author''}''}''<''/''td''>''<''/''tr''>''<''/''table''>''<''/''div''>''<''/''template''>''<''script''>''export''default''{''name'':''""Book""'',''data''('')''{''return''{''msg'':'""'hello xyj'""',''books'':''[''{''id'':''1'',''name'':'""'xyj'""',''author'':'""'AAAAAA'""',''}'',''{''id'':''2'',''name'':'""'wangwu'""',''author'':'""'王五'""',''}'']''}''}'',''created''('')''{''const''_this''=''this''axios''.''get''('""'http://localhost:8181/book/findAll/'""')''.''then''(''function''(''resp'')''{''_this''.''books''=''resp''.''data''}'')''}''}''<''/''script''>''<''style scoped''>''<''/''style''>''12.在index.js中添加路由''13.由于端口不能相同，我们需要在springboot项目里添加CrosConfig''package''com''.''xyj''.''config'';''import''org''.''springframework''.''context''.''annotation''.''Configuration'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''CorsRegistry'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''WebMvcConfigurer'';''/**\n * @author xyj\n * @date 2020/7/12 -16:11\n */''@Configuration''public''class''CrosConfig''implements''WebMvcConfigurer''{''@Override''public''void''addCorsMappings''(''CorsRegistry registry'')''{''registry''.''addMapping''(''""/**""'')''.''allowedOrigins''(''""*""'')''.''allowedMethods''(''""GET""'',''""HEAD""'',''""POST""'',''""PUT""'',''""DELETE""'',''""OPTIONS""'')''.''allowCredentials''(''true'')''.''maxAge''(''3600'')''.''allowedHeaders''(''""*""'')'';''}''}''14.这个时候我们可以启动项目''cnpm run serve''这样就可以把数据库数据拿过来了！''上一篇：''vue ui可视化界面进行创建vue项目安装''下一篇：''springboot+vue项目大型实战（二）Elemen UI深入浅出分页操作'"
CSDN,https://blog.csdn.net/laizhichen2280/article/details/86760017,Spring Boot+Vue全栈开发实战――花了一个礼拜读懂了这本书,邓高鹃技术专栏,Vue使用,,2019-02-03 16:40:22,'很幸运能够阅读王松老师的《Spring Boot+Vue全栈开发实战》这本书！之前也看过Spring Boot与Vue的相关知识，自己也会使用了Spring Boot+Vue进行开发项目。 就是没有系统的学习一下！当看到这本书的时候也是有一种相见恨晚的感觉。这本书也是从基础入门，最后到写一个项目的过程。下面我就来说说这本书主要的章节，后面每一章节我都会跟大家详细道来，并且在我学习与网友们学习这本说中遇到的问题以及疑惑做一个总结！''在前言这部分总体意思是这样的，作者接触也是用了Spring Boot几年的时候，当时也出了一些教程，我想应该是写写博客之类的吧，如果是课程的话都是有章节的，但这里作者说他的课程搜都是比较零散。加上使用的Spring Boot版本都比较老。所以王松老师就想系统的整理一下自己写的博客整理成为一本相关的图书。于是在百忙当中抽出时间写下这本书。每一个作者在出书的时候大多都是有工作在身，也许写几书书籍就是为了一种梦想吧！''然后介绍了，传统的Spring项目环境配置复杂臃肿，让我们开发者已苦不堪言，Spring Boot带来的全新自动化配置解决方案已出现就受到了极大的关注，使得Spring Boot在两年成为了Java领域的焦点之一。介绍了本书使用Spring Boot 的版本为2.0.4。我个人觉得如果你是新手你就使用跟王松老师一样的版本，如果你是个老鸟那你随便选个高于王松版本，因为Spring Boot版本都是向后兼容的。''王松老师把这本书分为16章：我们来说一下每一个章节：''1、Spring Boot 入门(我想不管是哪本书在第一章都会这么写吧，但我没有跳过这一章，我不知道大家有没有我一样的习惯，往往我看一本书在前面几张的部分我都会反复的看，随说是入门但是我觉得那些事作者对技术的理解，就好这一章，我们就可以看看作者对Spring Boot的理解，你阅读本章它也许会改变你对Spring Boot的认知)''2、Spring Boot 基础配置''3、Spring Boot 整合视图层技术(我看到本章的时候发现王松老师把目录拆分得很详细)''4、Spring Boot 整合Web技术''5、Spring Boot 整合持久层技术''6、Spring Boot 整合NoSQL''7、构建RESTful服务(这技术之前我没有接触过，所以我在那章节化了时间阅读)''8、开发者工具与单元测试''9、Spring Boot 缓存''10、Spring Boot 安全管理''11、Spring Boot 整合Web Socket''12、消息服务''13、企业开发''14、应用监控''15、构建项目与部署''16、微人事项目实战''可以看出1-15章都是对技术的单一学习，到16章就是把所有技术进行整合，大家可以看到本书是《Spring Boot+Vue全栈开发实战》讲了Spring Boot基础的知识，但是到16章直接使用Vue技术。并没有对Vue技术的基础知识讲解。如果大家没有Vue的基础希望大家去阅读我整理的一本《Vue快速入门》这本书！''最后王松老师对这本书做一个读者的定位：需要用Java Web基础的开发者。''本书的代码下载：下载地址可以联系我或者你可以加入到本群975098348(本群只讨论王松老师写的《Spring Boot+Vue全栈开发实战》学习好本书了自动退群)，但是你能看到我对这本说讲解，你应该已经购买了这本书，自己可以下载的啊！其实就是一个百度云！''技术支持：作者的微信邮箱都有我这里就不写出来给大家！'
CSDN,https://blog.csdn.net/weixin_44625302/article/details/107288668,springboot+vue项目大型实战（一）后端开发,Nym_车厘子,springboot,,2020-07-12 16:59:53,"'源码下载地址！！！点我''数据库创建表''SET NAMES utf8mb4'';''SET FOREIGN_KEY_CHECKS''=''0'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Table structure''for''book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''DROP TABLE IF EXISTS `book`'';''CREATE TABLE `book`''(''`id`''int''(''10'')''NOT NULL'',''`name`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`author`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`publish`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`pages`''int''(''10'')''NULL DEFAULT NULL'',''`price`''float''(''10'',''2'')''NULL DEFAULT NULL'',''`bookcaseid`''int''(''10'')''NULL DEFAULT NULL'',''`abled`''int''(''255'')''NULL DEFAULT NULL'',''PRIMARY KEY''(''`id`'')''USING BTREE'')''ENGINE''=''InnoDB CHARACTER SET''=''utf8 COLLATE''=''utf8_general_ci ROW_FORMAT''=''Compact'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Records of book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''INSERT INTO `book` VALUES''(''1'','""'上下五千年'""','""'曹操'""','""'中国人民出版社'""',''999'',''99.99'',''10'',''1'')'';''INSERT INTO `book` VALUES''(''2'','""'SPSS统计'""','""'王五'""','""'SPSS出版社'""',''330'',''26.00'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''3'','""'四级必备词汇'""','""'李四'""','""'清华出版社'""',''150'',''17.30'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''4'','""'六级必备词汇'""','""'张三'""','""'北大出版社'""',''220'',''59.00'',''3'',''1'')'';''INSERT INTO `book` VALUES''(''5'','""'高考必备'""','""'王强'""','""'上海出版公司'""',''300'',''27.30'',''4'',''1'')'';''INSERT INTO `book` VALUES''(''6'','""'考研必备'""','""'郭德纲'""','""'天津出版社'""',''225'',''22.80'',''1'',''1'')'';''SET FOREIGN_KEY_CHECKS''=''1'';''1.创建项目''2.勾选的依赖''3.目录结构''4.配置application.yml''spring'':''datasource'':''url'':''jdbc'':''mysql'':''/''/''localhost'':''3306''/''library''?''useUnicode''=''true''&''characterEncoding''=''UTF''-''8''&''serverTimezone''=''Asia''/''Shanghai\n    username'':''root\n    password'':''123456''driver''-''class''-''name'':''com''.''mysql''.''cj''.''jdbc''.''Driver\n  jpa'':''show''-''sql'':''true''properties'':''hibernate'':''format_sql'':''true''server'':''port'':''8181''5.Book实体类（使用JPA）''package''com''.''xyj''.''entity'';''import''lombok''.''Data'';''import''javax''.''persistence''.''Entity'';''import''javax''.''persistence''.''Id'';''/**\n * @author xyj\n * @date 2020/7/12 -15:30\n */''@Entity''@Data''public''class''Book''{''@Id''private''Integer id'';''private''String name'';''private''String author'';''}''6.BookRepository接口''package''com''.''xyj''.''repository'';''import''com''.''xyj''.''entity''.''Book'';''import''org''.''springframework''.''data''.''jpa''.''repository''.''JpaRepository'';''public''interface''BookRepository''extends''JpaRepository''<''Book'',''Integer''>''{''}''7.BookHandleer（实现查询功能）''package''com''.''xyj''.''controller'';''import''com''.''xyj''.''entity''.''Book'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''GetMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RequestMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RestController'';''import''java''.''util''.''List'';''/**\n * @author xyj\n * @date 2020/7/12 -15:45\n */''@RestController''@RequestMapping''(''""/book""'')''public''class''BookHandleer''{''@Autowired''private''BookRepository bookRepository'';''@GetMapping''(''""/findAll""'')''public''List''<''Book''>''findAll''('')''{''return''bookRepository''.''findAll''('')'';''}''}''8.我们可以在测试类中查询BookSpringbootApplicationTests（控制台显示）''package''com''.''xyj'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''junit''.''jupiter''.''api''.''Test'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''boot''.''test''.''context''.''SpringBootTest'';''@SpringBootTest''class''BookSpringbootApplicationTests''{''@Autowired''private''BookRepository bookRepository'';''@Test''void''contextLoads''('')''{''System''.''out''.''println''(''bookRepository''.''findAll''('')'')'';''}''}''9.直接启动springboot项目，在页面可以显示所有查询的数据（我们只查询三个字段进行测试）''10.接下来我们需要与前端交互数据（创建的vue工程都是自动生成的，自己添加一个Book.vue）''补充CVue-cli 3.x 添加axios插件''11.Book.vue（其中data（）{}中的数据都是测试用的，created中是从后端获取的数据C数据库中）''<''template''>''<''div''>''<''table''>''<''tr''>''<''td''>''编号''<''/''td''>''<''td''>''图书名称''<''/''td''>''<''td''>''作者''<''/''td''>''<''/''tr''>''<''tr v''-''for''=''""item in books""''>''<''td''>''{''{''item''.''id''}''}''<''/''td''>''<''td''>''{''{''item''.''name''}''}''<''/''td''>''<''td''>''{''{''item''.''author''}''}''<''/''td''>''<''/''tr''>''<''/''table''>''<''/''div''>''<''/''template''>''<''script''>''export''default''{''name'':''""Book""'',''data''('')''{''return''{''msg'':'""'hello xyj'""',''books'':''[''{''id'':''1'',''name'':'""'xyj'""',''author'':'""'AAAAAA'""',''}'',''{''id'':''2'',''name'':'""'wangwu'""',''author'':'""'王五'""',''}'']''}''}'',''created''('')''{''const''_this''=''this''axios''.''get''('""'http://localhost:8181/book/findAll/'""')''.''then''(''function''(''resp'')''{''_this''.''books''=''resp''.''data''}'')''}''}''<''/''script''>''<''style scoped''>''<''/''style''>''12.在index.js中添加路由''13.由于端口不能相同，我们需要在springboot项目里添加CrosConfig''package''com''.''xyj''.''config'';''import''org''.''springframework''.''context''.''annotation''.''Configuration'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''CorsRegistry'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''WebMvcConfigurer'';''/**\n * @author xyj\n * @date 2020/7/12 -16:11\n */''@Configuration''public''class''CrosConfig''implements''WebMvcConfigurer''{''@Override''public''void''addCorsMappings''(''CorsRegistry registry'')''{''registry''.''addMapping''(''""/**""'')''.''allowedOrigins''(''""*""'')''.''allowedMethods''(''""GET""'',''""HEAD""'',''""POST""'',''""PUT""'',''""DELETE""'',''""OPTIONS""'')''.''allowCredentials''(''true'')''.''maxAge''(''3600'')''.''allowedHeaders''(''""*""'')'';''}''}''14.这个时候我们可以启动项目''cnpm run serve''这样就可以把数据库数据拿过来了！''上一篇：''vue ui可视化界面进行创建vue项目安装''下一篇：''springboot+vue项目大型实战（二）Elemen UI深入浅出分页操作'"
CSDN,https://blog.csdn.net/weixin_44625302/article/details/107288668,springboot+vue项目大型实战（一）后端开发,Nym_车厘子,springboot,,2020-07-12 16:59:53,"'源码下载地址！！！点我''数据库创建表''SET NAMES utf8mb4'';''SET FOREIGN_KEY_CHECKS''=''0'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Table structure''for''book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''DROP TABLE IF EXISTS `book`'';''CREATE TABLE `book`''(''`id`''int''(''10'')''NOT NULL'',''`name`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`author`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`publish`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`pages`''int''(''10'')''NULL DEFAULT NULL'',''`price`''float''(''10'',''2'')''NULL DEFAULT NULL'',''`bookcaseid`''int''(''10'')''NULL DEFAULT NULL'',''`abled`''int''(''255'')''NULL DEFAULT NULL'',''PRIMARY KEY''(''`id`'')''USING BTREE'')''ENGINE''=''InnoDB CHARACTER SET''=''utf8 COLLATE''=''utf8_general_ci ROW_FORMAT''=''Compact'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Records of book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''INSERT INTO `book` VALUES''(''1'','""'上下五千年'""','""'曹操'""','""'中国人民出版社'""',''999'',''99.99'',''10'',''1'')'';''INSERT INTO `book` VALUES''(''2'','""'SPSS统计'""','""'王五'""','""'SPSS出版社'""',''330'',''26.00'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''3'','""'四级必备词汇'""','""'李四'""','""'清华出版社'""',''150'',''17.30'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''4'','""'六级必备词汇'""','""'张三'""','""'北大出版社'""',''220'',''59.00'',''3'',''1'')'';''INSERT INTO `book` VALUES''(''5'','""'高考必备'""','""'王强'""','""'上海出版公司'""',''300'',''27.30'',''4'',''1'')'';''INSERT INTO `book` VALUES''(''6'','""'考研必备'""','""'郭德纲'""','""'天津出版社'""',''225'',''22.80'',''1'',''1'')'';''SET FOREIGN_KEY_CHECKS''=''1'';''1.创建项目''2.勾选的依赖''3.目录结构''4.配置application.yml''spring'':''datasource'':''url'':''jdbc'':''mysql'':''/''/''localhost'':''3306''/''library''?''useUnicode''=''true''&''characterEncoding''=''UTF''-''8''&''serverTimezone''=''Asia''/''Shanghai\n    username'':''root\n    password'':''123456''driver''-''class''-''name'':''com''.''mysql''.''cj''.''jdbc''.''Driver\n  jpa'':''show''-''sql'':''true''properties'':''hibernate'':''format_sql'':''true''server'':''port'':''8181''5.Book实体类（使用JPA）''package''com''.''xyj''.''entity'';''import''lombok''.''Data'';''import''javax''.''persistence''.''Entity'';''import''javax''.''persistence''.''Id'';''/**\n * @author xyj\n * @date 2020/7/12 -15:30\n */''@Entity''@Data''public''class''Book''{''@Id''private''Integer id'';''private''String name'';''private''String author'';''}''6.BookRepository接口''package''com''.''xyj''.''repository'';''import''com''.''xyj''.''entity''.''Book'';''import''org''.''springframework''.''data''.''jpa''.''repository''.''JpaRepository'';''public''interface''BookRepository''extends''JpaRepository''<''Book'',''Integer''>''{''}''7.BookHandleer（实现查询功能）''package''com''.''xyj''.''controller'';''import''com''.''xyj''.''entity''.''Book'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''GetMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RequestMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RestController'';''import''java''.''util''.''List'';''/**\n * @author xyj\n * @date 2020/7/12 -15:45\n */''@RestController''@RequestMapping''(''""/book""'')''public''class''BookHandleer''{''@Autowired''private''BookRepository bookRepository'';''@GetMapping''(''""/findAll""'')''public''List''<''Book''>''findAll''('')''{''return''bookRepository''.''findAll''('')'';''}''}''8.我们可以在测试类中查询BookSpringbootApplicationTests（控制台显示）''package''com''.''xyj'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''junit''.''jupiter''.''api''.''Test'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''boot''.''test''.''context''.''SpringBootTest'';''@SpringBootTest''class''BookSpringbootApplicationTests''{''@Autowired''private''BookRepository bookRepository'';''@Test''void''contextLoads''('')''{''System''.''out''.''println''(''bookRepository''.''findAll''('')'')'';''}''}''9.直接启动springboot项目，在页面可以显示所有查询的数据（我们只查询三个字段进行测试）''10.接下来我们需要与前端交互数据（创建的vue工程都是自动生成的，自己添加一个Book.vue）''补充CVue-cli 3.x 添加axios插件''11.Book.vue（其中data（）{}中的数据都是测试用的，created中是从后端获取的数据C数据库中）''<''template''>''<''div''>''<''table''>''<''tr''>''<''td''>''编号''<''/''td''>''<''td''>''图书名称''<''/''td''>''<''td''>''作者''<''/''td''>''<''/''tr''>''<''tr v''-''for''=''""item in books""''>''<''td''>''{''{''item''.''id''}''}''<''/''td''>''<''td''>''{''{''item''.''name''}''}''<''/''td''>''<''td''>''{''{''item''.''author''}''}''<''/''td''>''<''/''tr''>''<''/''table''>''<''/''div''>''<''/''template''>''<''script''>''export''default''{''name'':''""Book""'',''data''('')''{''return''{''msg'':'""'hello xyj'""',''books'':''[''{''id'':''1'',''name'':'""'xyj'""',''author'':'""'AAAAAA'""',''}'',''{''id'':''2'',''name'':'""'wangwu'""',''author'':'""'王五'""',''}'']''}''}'',''created''('')''{''const''_this''=''this''axios''.''get''('""'http://localhost:8181/book/findAll/'""')''.''then''(''function''(''resp'')''{''_this''.''books''=''resp''.''data''}'')''}''}''<''/''script''>''<''style scoped''>''<''/''style''>''12.在index.js中添加路由''13.由于端口不能相同，我们需要在springboot项目里添加CrosConfig''package''com''.''xyj''.''config'';''import''org''.''springframework''.''context''.''annotation''.''Configuration'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''CorsRegistry'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''WebMvcConfigurer'';''/**\n * @author xyj\n * @date 2020/7/12 -16:11\n */''@Configuration''public''class''CrosConfig''implements''WebMvcConfigurer''{''@Override''public''void''addCorsMappings''(''CorsRegistry registry'')''{''registry''.''addMapping''(''""/**""'')''.''allowedOrigins''(''""*""'')''.''allowedMethods''(''""GET""'',''""HEAD""'',''""POST""'',''""PUT""'',''""DELETE""'',''""OPTIONS""'')''.''allowCredentials''(''true'')''.''maxAge''(''3600'')''.''allowedHeaders''(''""*""'')'';''}''}''14.这个时候我们可以启动项目''cnpm run serve''这样就可以把数据库数据拿过来了！''上一篇：''vue ui可视化界面进行创建vue项目安装''下一篇：''springboot+vue项目大型实战（二）Elemen UI深入浅出分页操作'"
CSDN,https://blog.csdn.net/u012394095/article/details/79470904,分布式定时任务对比,sharedCode,xxl-job分布式定时任务,,2018-03-07 14:42:26,"'1. 什么是分布式定时任务''把分散的，可靠性差的计划任务纳入统一的平台，并实现集群管理调度和分布式部署的一种定时任务的管理方式。叫做分布式定时任务。''2. 常见开源方案''elastic-job'',''xxl-job ，''quartz , saturn,\xa0 opencron ,''antares''elastic-job''elastic-job 是由当当网基于quartz 二次开发之后的分布式调度解决方案 ， 由两个相对独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成 。''Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务。''Elastic-Job-Cloud使用Mesos + Docker(TBD)的解决方案，额外提供资源治理、应用分发以及进程隔离等服务''亮点：''基于quartz 定时任务框架为基础的，因此具备quartz的大部分功能''使用zookeeper做协调，调度中心，更加轻量级''支持任务的分片''支持弹性扩容 ， 可以水平扩展 ， 当任务再次运行时，会检查当前的服务器数量，重新分片，分片结束之后才会继续执行任务''失效转移，容错处理，当一台调度服务器宕机或者跟zookeeper断开连接之后，会立即停止作业，然后再去寻找其他空闲的调度服务器，来运行剩余的任务''提供运维界面，可以管理作业和注册中心。''elastic-job结合了quartz非常优秀的时间调度功能，并且利用ZooKeeper实现了灵活的分片策略。除此之外，还加入了大量实用的监控和管理功能，''以及其开源社区活跃、文档齐全、代码优雅等优点，是分布式任务调度框架的推荐选择。''由于elastic-job-lite\xa0 不支持动态添加作业，此处仅贴上elastic-job-Cloud架构图''xxl-job''由个人开源的一个轻量级分布式任务调度框架 ，主要分为 调度中心和执行器两部分 ， 调度中心在启动初始化的时候，会默认生成执行器的RPC代理''对象（http协议调用）， 执行器项目启动之后， 调度中心在触发定时器之后通过jobHandle 来调用执行器项目里面的代码，核心功能和elastic-job差不多''，同时技术文档比较完善''系统架构图：''quartz''quartz 的常见集群方案如下，通过在数据库中配置定时器信息， 以数据库悲观锁的方式达到同一个任务始终只有一个节点在运行，''优点：''保证节点高可用 （HA）， 如果某一个几点挂了， 其他节点可以顶上''缺点：''同一个任务只能有一个节点运行，其他节点将不执行任务，性能低，资源浪费''当碰到大量短任务时，各个节点频繁的竞争数据库锁，节点越多这种情况越严重。性能会很低下''quartz 的分布式仅解决了集群高可用的问题，并没有解决任务分片的问题，不能实现水平扩展''Saturn''Saturn是唯品会在github开源的一款分布式任务调度产品。它是基于当当elastic-job 1.0版本来开发的，其上完善了一些功能和添加了一些新的feature。''亮点：''支持多语言开发 python、Go、Shell、Java、Php。''管理控制台和数据统计分析更加完善''缺点：''技术文档较少 ， 该框架是2016年由唯品会的研发团队基于elastic-job开发而来的''opencron''一个功能完善真正通用的linux定时任务调度定系统,满足多种场景下各种复杂的定时任务调度,同时集成了linux实时监控,webssh,提供一个方便管理定时任务的平台''缺点：仅支持''kill任务， 现场执行，查询任务运行状态 等， 主要功能是着重于任务的修改和查询上。 不能动态的添加任务以及任务分片。''antares''优点：''一个任务仅会被服务器集群中的某个节点调度，调度机制基于成熟的 quartz''并行执行 ， 用户可通过对任务预分片，有效提升任务执行效率''失效转移''弹性扩容，在任务运行时，可以动态的加机器''友好的管理控制台''缺点：''不能动态的添加任务，仅能在控制台对任务进行触发，暂停，删除等操作''文档不多，开源社区不够活跃''系统架构图如下：''4. 比较''此处列出了几个代表性的开源产品''feature''quartz''elastic-job-cloud''xxl-job''antares''opencron''依赖''mysql''jdk1.7+, zookeeper 3.4.6+ ,maven3.0.4+ ,mesos''mysql ,jdk1.7+ , maven3.0+''jdk 1.7+ , redis , zookeeper''jdk1.7+ , Tomcat8.0+''HA''多节点部署，通过竞争数据库锁来保证只有一个节点执行任务''通过zookeeper的注册与发现，可以动态的添加服务器。 支持水平扩容''集群部署''集群部署''―''任务分片''―''支持''支持''支持''―''文档完善''完善''完善''完善''文档略少''文档略少''管理界面''无''支持''支持''支持''支持''难易程度''简单''较复杂''简单''一般''一般''公司''OpenSymphony''当当网''个人''个人''个人''高级功能''―''弹性扩容，多种作业模式，失效转移，运行状态收集，多线程处理数据，幂等性，容错处理，spring命名空间支持''弹性扩容，分片广播，故障转移，Rolling实时日志，GLUE（支持在线编辑代码，免发布）,任务进度监控，任务依赖，数据加密，邮件报警，运行报表，国际化''任务分片， 失效转移，弹性扩容 ，''时间规则支持quartz和crontab ，kill任务， 现场执行，查询任务运行状态''缺点''没有管理界面，以及不支持任务分片等。不适用于分布式场景''需要引入zookeeper , mesos, 增加系统复杂度, 学习成本较高''调度中心通过获取 DB锁来保证集群中执行任务的唯一性， 如果短任务很多，随着调度中心集群数量增加，那么数据库的锁竞争会比较厉害，性能不好。''不支持动态添加任务''不适用于分布式场景''使用企业''大众化产品，对分布式调度要求不高的公司大面积使用''36氪，当当网，国美，金柚网，联想，唯品会，亚信，平安，猪八戒''大众点评，运满满，优信二手车，拍拍贷''―''―''sharedCode源码交流群，欢迎喜欢阅读源码的朋友加群，添加下面的微信， 备注”加群“ 。'"
CSDN,https://blog.csdn.net/u012379844/article/details/82716146,分布式调度框架大集合,路灯下的女孩,框架相关,,2018-09-15 18:03:31,"'分布式任务调度框架''1''、什么是分布式任务调度？''2''、常见的分布式任务调度框架有哪些？''3''、分布式任务调度框架的技术选型？''4''、分布式任务调度框架的安装与使用？''大对比表格：''https://pan.baidu.com/s/1CZAjTFqIhinzlVLnrrMUKQ''分布式任务调度，三个关键词：分布式、任务调度、配置中心。''分布式：平台是分布式部署的，各个节点之间可以无状态和无限的水平扩展；''任务调度：涉及到任务状态管理、任务调度请求的发送与接收、具体任务的分配、任务的具体执行；（这里又会遇到一共要处理哪些任务、任务要分配到哪些机器上处理、任务分发的时候判断哪些机器可以用等问题，所以又需要一个可以感知整个集群运行状态的配置中心）''配置中心：可以感知整个集群的状态、任务信息的注册''一个分布式任务调度系统需要以下内容：''web''模块、''server''模块、''Scheduler''模块、''worker''模块、注册中心。''1''、''Web''模块：用来提供任务的信息，控制任务的状态、信息展示等。''2''、''Server''模块：负责接收''web''端传来的任务执行的信息，下发任务调度请求给''Scheduler''，会去注册中心进行注册''3''、''Scheduler''模块：接收''server''端传来的调度请求，将任务进行更加细化的拆分然后下发，到注册中心进行注册，获取到可以干活的''worker''。''4''、''Worker''模块：负责具体的任务执行。''5''、注册中心。''1、什么是分布式任务调度？''任务调度是指基于给定的时间点，给定的时间间隔或者给定执行次数自动的执行任务。任务调度是是操作系统的重要组成部分，而对于实时的操作系统，任务调度直接影响着操作系统的实时性能。任务调度涉及到多线程并发、运行时间规则定制及解析、线程池的维护等诸多方面的工作。''WEB服务器在接受请求时，会创建一个新的线程服务。但是资源有限，必须对资源进行控制，首先就是限制服务线程的最大数目，其次考虑以线程池共享服务的线程资源，降低频繁创建、销毁线程的消耗；然后任务调度信息的存储包括运行次数、调度规则以及运行数据等。一个合适的任务调度框架对于项目的整体性能来说显得尤为重要。''2、常见的任务调度框架有哪些？''我们在实际的开发工作中，或多或少的都会用到任务调度这个功能。常见的分布式任务调度框架有：cronsun、Elastic-job、saturn、lts、TBSchedule、xxl-job等。''2.1cronsun''crontab是Linux系统里面最简单易用的定时任务管理工具，在Linux上由crond来周期性的执行指令列表，执行的任务称为cron job，多个任务就称为crontab。crontab任务调度指令的基本格式为：''*\xa0\xa0\xa0\xa0*\xa0\xa0\xa0\xa0*\xa0\xa0\xa0*\xa0\xa0\xa0\xa0*\xa0\xa0\xa0\xa0command''分''时''日''月''周''命令''但是时间久了之后会发现，crontab会存在一些问题：''大量的crontab分散在各台服务器，带来了很高的维护成本；''任务没有按时执行，过了很长的时间才能发现，需要重试或者排查；''crontab分散在很多集群上，需要一台一台的去查看日志；''crontab存在单点问题，对于不能重复执行的定时任务很伤脑；''……''因此非常需要一个集中管理定时任务的系统，于是就有了cronsun。cronsun是一个分布式任务系统，单个节点和Linux机器上的contab近似，是为了解决多台Linux机器上crontab任务管理不方便的问题，同时提供了任务高可用的支持（当某个节点死机的时候可以自动调整到正常的节点执行）。与此同时，它还支持界面管理机器上的任务，支持任务失败邮件提醒，安装简单，使用简便，是替换crontab的一个不错的选择。''cronsun中主要有三个组件，都是通过etcd通讯的。cronnode负责节点的分组及节点的状态，cronweb是用来管理任务的、任务的执行结果都可以在上面看。''cronsun的系统架构如下图所示，简单的来说就是，所有的任务都会存储在一个分布式etcd里，单个crond部署成一个服务，也就是图中所示的node.1、node.2、node.n等，然后再由web界面去管理。如果任务执行失败的话，会发送失败的邮件，当单个节点死机的时候，也会自动调整到正常的节点去执行任务。''cronsun是在管理后台添加任务的，所以一旦管理后台泄漏出去了，则存在一定的危险性，所以cronsun支持security.json的安全设置：''{\n""open"": true,\n""#users"": ""允许选择运行脚本的用户"", ""users"": [\n""www"", ""db"" ],\n""#ext"": ""允许添加以下扩展名结束的脚本"", ""ext"": [\n"".cron.sh"", "".cron.py"" ]\n}''如以上设置开启安全限制，则添加和执行任务的时候只允许选择配置里面指定的用户来执行脚本，并且脚本的扩展名要在配置的脚本的扩展名限制的列表里面。''2.2、Elastic-job''Elastic-job是当当开源的一款非常好用的作业框架，Elastic-job在2.x之后，出现了两个相互独立的产品线：Elastic-job-lite和Elastic-job-cloud。''2.2.1、Elastic-job-lite''Elastic-job-lite定位为轻量级无中心化的解决方案，使用jar包的形式提供分布式任务的协调服务，外部依赖仅依赖于zookeeper。''Elastic-job-lite的架构图如下图所示：''从上面的框架图中可以看出，Elastic-job-lite框架使用zookeeper作为注册中心，Elastic-job-lite框架通过监听感知zookeeper数据的变化，并做相应的处理；运维平台也仅是通过读取zk数据来展现作业状态，或是更新zk数据修改全局配置。运维平台和Elastic-job-lite没有直接的关系，完全解耦合。Elastic-job-lite并不直接提供数据处理的功能，框架只会将分片项分配给各个正在运行中的服务器，分片项与真是数据的对应关系需要开发者在应用程序中自行处理。''Elastic-job-lite并无作业调度中心节点，而是基于部署作业框架的程序在到达相应时间点时各自触发调度。注册中心仅用于作业注册和监控信息存储，而主作业节点仅用于处理分片和清理的功能。''（1''）注册中心的数据结构''我们先来了解一下该框架在zookeeper上的节点情况。首先注册中心在命名的空间下创建作业名称节点（''作业名称用来区分不同的作业，一旦修改名称，则认为是新的作业''），作业名称节点下又包含5个子节点：''config：保存作业的配置信息，以JSON格式存储''sharding：保存作业的分片信息，它的子节点是分片项序号，从零开始，至分片总数减一''leader：该节点保存作业服务器主节点的信息，分为election、sharding和failover三个子节点，分别用于主节点的选举、分片和失效转移''instances：该节点保存的是作业运行实例的信息，子节点是当前作业运行实例的主键''servers：该节点保存作业服务器的信息，子节点是作业服务器的IP地址''（2）实现原理''第一台服务器上线触发主服务器选举，主服务器一旦下线，则重新触发选举，选举过程中阻塞，只有当主服务器选举完成，才会去执行其他的任务；''某服务器上线时会自动将服务器的信息注册到注册中心，下线时会自动更新服务器的状态；''主节点选举，服务器上下线，分片总数变更均更新重新分片标记；''定时任务触发时，如需重新分片，则通过主服务器分片，分片过程中阻塞，分片结束后才可以执行任务。如分片过程中主服务器下线，则先选举主服务器在分片；''由上一项说明可知，为了维持作业运行时的稳定性，运行过程中只会标记分片的状态，不会重新分片，分片仅可能发生在下次任务触发前；''每次分片都会按照ip排序，保证分片结果不会产生较大的波动；''实现失效转移功能，在某台服务器执行完毕后主动抓取未分配的分片，并且在某台服务器下线后主动寻找可用的服务器执行任务。''elastic底层的任务调度还是使用的quartz，通过zookeeper来动态给job节点分片。如果很大体量的用户需要我们在特定的时间段内计算完成，那么我们肯定是希望我们的任务可以通过集群达到水平的扩展，集群里的每个节点都处理部分的用户，不管用户的数量有多大，我们只需要增加机器就可以了。举个例子：比如我们希望3台机器跑job，我么将我们的任务分成3片，框架通过zk的协调，最终会让3台机器分配到0，1，2的任务片，比如server0->0、server1->1、server2->2，当server0执行时，可以只查询id%3==0的用户，server1可以只查询id%3==1的用户，server2可以只查询id%3==2的用户。''在以上的基础上再增加一个server3，此时，server3分不到任何的分片，没有分到任务分片的程序将不执行。如果此时server2挂了，那么server2被分到的任务分片将会分配给server3，所以server3就会代替server2执行。如果此时server3也挂了，那么框架也会自动的将server3的任务分片随机分配到server0或者server1，那么就可能成：server0->0、server1->1,2。''这种特性称之为''弹性扩容''。''2.2.2、Elastic-job-cloud''Elastic-job-cloud包含了Elastic-job-lite的全部功能，它是以私有云平台的方式提供集资源、调度以及分片为一体的全量级解决方案，依赖于Mesos和Zookeeper，它额外提供了资源治理、应用分发以及进程隔离等服务。他们两个提供同一套API开发作业，开发者仅需一次开发，然后可根据需要以lite或cloud的方式部署。''2.3、saturn''Saturn（定时任务调度系统）是唯品会自主研发的分布式的定时任务的调度平台，它是基于Elastic-job版本1开发的。目标是取代传统的Linux Cron/Spring Batch Job/Quartz的方式，做到全域统一配置、统一监控、任务高可用以及分片。Saturn的任务可以使用多种语言开发，比如python、Go、Shell、Java、Php等。''Saturn包括两大部分，Saturn Console和Saturn Executor。Console是一个WEB UI，用来对作业/Executor的管理，统计报表展现等。他同时也是整个调度系统的大脑：将作业任务分配到各Executor。Executor是执行任务的worker：按照作业配置的要求去执行部署于Executor所在容器或物理机当中的作业脚本和代码。Saturn高度依赖于zookeeper，每个executor及调度服务都会在zookeeper上进行注册，确保调度程序能够及时得到executor的状态。''Saturn定时任务调度的最小单位是分片，即任务的一个执行单元。Saturn的基本任务就是将任务分成多个分片，并将每个分片通过算法调度到对应的executor上去执行。''2.3.1、Staurn基本原理''Saturn的基本原理是将作业在逻辑上划分为若干个分片，通过作业分片调度器将作业分片指派给特定的执行节点。执行节点通过quartz触发执行作业的具体实现，在执行的时候，会将分片序号和参数作为参数传入。作业的实现逻辑需分析分片序号和分片参数，并以此为依据来调用具体的实现（比如一个批量处理数据库的作业，可以划分0号分片处理1-10号数据库，1号分片可以处理11-20号数据库）。''2.3.2、Saturn作业调度算法''（1''）方案的设计''原理是给每个作业分片一个负载值和优先执行节点（prefer list），当需要重新分片时，参考作业优先设定和执行节点的负载值来进行域内节点之间的资源分配，从而达到资源平衡。''（2''）前置条件''A：每个分片都引入一个负载值（load），由用户通过Saturn UI界面输入''B：为每一个作业引入新的属性prefer list（优先列表，或者叫欲分配列表），由管理员通过ui界面编辑''C：作业引入启用状态（enabled/disabled），用户通过UI界面改变这个状态；启用状态的作业会被节点执行，且不可编辑、删除，不可对prefer list进行调整，禁用状态的作业不会被执行''（3''）实施步骤''第一步，摘取；第二步，放回（将这些作业分片按照负载值从大到小顺序逐个分配给负载最小的执行节点）。''（''3.1''）''executor''上线''摘取：''第一步，找出新上线节点的全部可执行作业列表；对于每个作业，判断prefer list中是否包含了新上线的节点；如果是，则摘取其中全部的分片；这些已经处理过的作业称为预处理作业；''第二步，从新上线节点的作业列表中减去预分配作业，然后使用以下的方法依次摘取：''假如上线的executor为a，它能处理的作业类型为j1，j2（已减去预分配列表）。遍历当前域下的executor列表，拿掉全部作业类型为j1，j2的分片，加上尚未分配的j1，j2作业分片列表，作为算法的待分配列表''在处理每个节点时，每拿掉一个作业分片后判断被拿掉的负载（load）是否已经超过了自身处理前总负载（load）的1/n（n为当前executor节点的总数量），如果超过，则本执行节点摘取完成，继续处理下一个执行节点；如果不超过则继续摘取，直到超过（大于等于）为止。''放回：''a．构造需要添加的作业分片列表，我们起名为待分配列表，长度为n，待分配列表按照负载（load）从大到小排序，排序时需保证相同作业的所有分片时连续的''b．构造每种作业类型的executor列表（如果有prefer list，且有存活，则该作业的executor列表就是prefer list），得到一个map<jobName,executorList>’''c．从待分配列表中依次取出第0到第n-1个作业分片jobi''d．从map中取出可运行jobi的executor列表listi''e．将jobi分配给listi中负载总和最小的executor''举例如下：''（3.2''）''executor''下线''摘取：''取出下线的executor当前分配到的全部作业分片，作为算法的待分配列表''放回：''使用平衡算法逐个处理待分配列表中的作业分片''（''3.3''）作业启动''摘取：''从所有executor中摘取将被启动作业的全部分片作为算法的待分配列表''放回：''使用调整后的平衡算法放回''（''3.4''）作业停止''摘取：''将被停止的作业分片从各节点删除''返回：''无''注：''Saturn''架构文档请见''https://github.com/vipshop/Saturn/wiki/Saturn''架构文档''2.4、lts''LTS是一个轻量级分布式任务调度框架，主要用于解决分布式任务的调度问题，支持实时任务、定时任务和Cron任务，有较好的伸缩性、扩展性以及健壮稳定性。他参考hadoop的思想，主要有以下四个节点：''JobClient：主要负责提交任务，并接收任务执行的反馈结果''JobTracker：负责接收并分配任务，任务调度''TaskTracker：负责执行任务，执行完反馈给JobTracker''LTS-Admin：（管理后台）主要负责节点管理，任务队列管理，监控管理等''其中JobClient、JobTracker、TaskTracker是无状态的，可以部署多个并动态的进行删减，来实现负载均衡，实现更大的负载量，并且框架采用FailStore策略使得LTS具有很好的容错能力。''一个典型的定时任务，大概的执行流程如下：''添加任务以后在注册中心进行注册，zk集群会暴露各个节点的信息，进行master节点选举等''JobClient将任务进行提交，如果成功的话将进行下一步；否则的话进入FailStore，重试''JobTracker接收并分配任务，如果任务已经存在，则结束；否则任务进入可执行队列ExecutableJobQueue，接着进入执行中任务队列ExecutingJobQueue，最后发送给TaskTracker进行执行''TaskTracker执行完毕后，将结果反馈给客户端；如果反馈成功，则回到JobClient执行下一个任务；否则的话进入FeedbackJobQueue重试''2.5、quartz''Quartz是OpenSymphony开源组织在任务调度领域的一个开源项目，完全基于java实现。作为一个优秀的开源框架，Quartz具有以下特点：强大的调度功能、灵活的应用方式、分布式和集群能力，另外作为spring默认的调度框架，很容易实现与Spring集成，实现灵活可配置的调度功能。''Quartz的核心元素如下：''Scheduler：任务调度器，是实际执行任务调度的控制器''Trigger；触发器，用于定义任务调度的时间规则''Calendar：它是一些日历特定时间的集合，一个Trigger可以包含多个Calendar，以便于排除或包含某些时间点''JobDetail：用来描述Job实现类及其他相关的静态信息，如Job的名字、关联监听器等信息''Job：是一个接口，只有一个方法void execute(JobExecutionContext\xa0context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息''Quartz的单机版大家应该都比较熟悉，它的集群方案是使用数据库来实现的。集群架构如下：''上图3个节点在数据库中都有同一份Job定义，如果某一个节点失效，那么Job会在其他节点上执行。因为每个节点上的代码都是一样的，那么如何保证只有一台机器上触发呢？答案是使用了数据库锁。在quartz集群解决方案了有张scheduler_locks，采用了悲观锁的方式对triggers表进行了行加锁，以保证任务同步的正确性。''简单来说，quartz的分布式调度策略是以数据库为边界的一种异步策略。各个调度器都遵守一个基于数据库锁的操作规则从而保证了操作的唯一性，同时多个节点的异步运行保证了服务的可靠。但这种策略有自己的局限性：集群特性对于高CPU使用率的任务效果特别好，但是对于大量的短任务，各个节点都会抢占数据库锁，这样就出现大量的线程等待资源。Quartz的分布式只解决了任务高可用的问题，并没有解决任务分片的问题，还是会有单机处理的极限。''2.6、TBSchedule''TBSchedule是一款非常优秀的分布式调度框架，广泛应用于阿里巴巴、淘宝、支付宝、京东、汽车之家等很多互联网企业的流程调度系统。TBSchedule在时间调度方面虽然没有quartz强大，但是它支持分片的功能。和quartz不同的是，TBSchedule使用zk来实现任务调度的高可用和分片。纯java开发。''TBSchedule项目实际上可以分为两部分。1）schedule管理控制台。负责控制、监控任务执行状态。2）实际执行job的客户端程序。在实际使用时，需要先启动zk，然后部署TBSchedule web界面的管理控制台，最后启动实际执行job的客户端程序。这里的zk并不实际控制任务调度，它只是负责与N台执行job任务的客户端进行通讯，协调、管理、监控这些机器的运行信息。实际分配任务的是管理控制台，控制台从zk获取job的运行信息。TBSchedule通过控制ZNode的创建、修改、删除来间接控制job的执行，执行任务的客户端监听它们对应ZNode的状态更新事件，从而达到TBSchedule控制job执行的目的。特点：''TBSchedule的分布式机制是通过灵活的Sharding方式实现的，比如可以按所有数据的ID按10取模分片、按月份分片等，根据不同的场景由客户端配置分片规则。''TBSchedule的宿主服务器可以进行动态的扩容和资源回收，这个特点主要是因为它后端依赖的zooKeeper，这里的zooKeeper对于TBSchedule来说相当于NoSQL，用于存储策略、任务、心跳等信息数据，他的数据结构类似于文件系统的目录结构，他的节点有临时节点、持久节点之分。一个新的服务器上线后，会在zk中创建一个代表当前服务器的一个唯一性路径（临时节点），并且新上线的服务器会和zk保持长连接，当通信断开后，节点会自动删除。''TBSchedule会定时扫描当前服务器的数量，重新进行任务分配。''TBSchedule不仅提供了服务端的高性能调度服务，还提供了一个scheduleConsole war随着宿主应用的部署直接部署到服务器，可以通过web的方式对调度的任务、策略进行监控管理，以及实时更新调整。''2.7、xxl-job''xxl-job是一个轻量级的分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。''xxl-job的''设计思想''为：''（1）将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求''（2）将任务抽象成分散的JobHandler，交由执行器统一管理，执行器负责接收调度请求并执行对应的JobHandler中业务逻辑''因此，“调度”和“任务”可以互相解偶，提高系统整体的稳定性和扩展性。''xxl-job''系统的组成''分为：''（1）调度模块（调度中心）：负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。''（2）执行模块（执行器）：负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；接收“调度中心”的执行请求、终止请求和日志请求等。''Xxl-job''的执行流程：''首先准备一个将要执行的任务，任务开启后到执行器中注册任务的信息，加载执行器的配置文件，初始化执行器的信息，然后执行器''start''。在''admin''端配置任务信息，配置执行器的信息。就可以控制任务的状态了。''xxl-job的''特性''为：''简单：支持通过web页面对任务进行CRUD操作，操作简单''动态：支持动态修改任务状态、暂停/恢复任务，以及终止运行中的任务，即时生效''调度中心HA（中心式）：调度采用中心式设计，“调度中心”基于集群Quartz实现并支持集群部署，可保证调度中心HA''执行器HA：任务分布式执行，任务执行器支持集群部署，可保证任务执行HA''注册中心：执行器会周期性自动注册任务并触发执行。同时，也支持手动录入执行器地址''弹性扩容缩容：一旦有新的执行器机器上线或下线，下次调度时会重新分配任务''路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、最不经常使用、故障转移等''故障转移：任务路由策略选择""故障转移""情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。''阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行、丢弃后续调度、覆盖之前调度''任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务；''任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；''失败处理策略；调度失败时的处理策略，默认提供失败告警、失败重试等策略；''分片广播任务：执行器集群部署时，任务路由策略选择""分片广播""情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；''动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。''事件触发：除了""Cron方式""和""任务依赖方式""触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。''任务进度监控：支持实时监控任务进度；''Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；''GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。''脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS等类型脚本;''任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行,\xa0多个子任务用逗号分隔；''一致性：“调度中心”通过DB锁保证集群分布式调度的一致性,\xa0一次任务调度只会触发一次执行；''自定义任务参数：支持在线配置调度任务入参，即时生效；''调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；''数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；''邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；''推送maven中央仓库:\xa0将会把最新稳定版推送到maven中央仓库,\xa0方便用户接入和使用;''运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；''全异步：系统底层实现全部异步化，针对密集调度进行流量削峰，理论上支持任意时长任务的运行；''国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文；''xxl-job-lite''的执行器实际是一个''ConcurrentHashMap''容器。''3、任务调度框架的技术选型？''1、Quartz：Java事实上的定时任务标准，但是关注点在于定时任务而非数据，虽然实现了高可用，但是缺少分布式并行调度的功能，性能低。''2、TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用的是Timer而不是线程池执行任务调度。TBSchedule的作业类型比较单一，只能是获取/处理数据一种模式，文档缺失比较严重。''3、详见分布式调度框架对比表格～''4、分布式任务调度框架的安装与使用？''4.1、Elastic-job''1、环境准备：''jdk1.7+、zookeeper3.4.6+、maven3.0.4+''2、安装zookeeper3.4.12并启动''这里zookeeper占用了2181端口。''3、创建简单任务''添加依赖：''写一个简单的任务：''在项目入口处添加作业的配置和zk的配置：''运行，得到结果：''4、下载Elastic-job-lite源码，使用maven进行打包。在elastic-job-lite/elastic-job-lite-console/target/elastic-job-lite-console-3.0.0.M1-SNAPSHOT/中，然后解压，会有start.bat和start.sh两个脚本，启动。''浏览器中输入localhost:8899，就可以管理任务了。''4.2、xxl-job-lite''1、调度数据库初始化，tables_xxl-job.sql''2、下载源码：包括调度中心+公共依赖+执行器示例''3、配置部署“调度中心”：修改数据库配置――将项目进行打包――将xxl-job-admin包部署到tomcat上''4、输入localhost:8080/xxl-job-admin即可访问调度中心''5、配置部署执行器：xxl-job-executor-sample-springboot打成jar包直接运行，其他的打成war包部署在tomcat上。''6、写一个任务，运行，去执行器上进行注册，然后调度中心配置执行器信息，添加任务''附录''1、etcd''etcd是一个开源的、分布式的键值对数据存储系统，提供共享配置、服务的注册和发现。etcd内部采用raft协议作为一致性算法，是基于Go语言实现的。''2、zookeeper''zookeeper是一个开源的分布式协调服务，它为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名空间服务、配置服务和分布式锁等分布式基础服务。''3、分布式锁''假如我们由三台机器，每台机器上都有一个进程。假设我们在第一台机器上挂载了一个资源，三个进程都要来竞争这个资源。我们不希望这三个进程同时来访问，那么就需要有一个协调器，来让他们有序的对该资源进行访问。这个协调器就是我们所说的那个锁，比如说“进程1”在使用该资源的时候，就会先去获得锁，“进程1”就对该资源保持独占，这样其他的进程就无法访问该资源。“进程1”用完该资源后就会将锁释放掉，让其他的进程来获得锁。因此这个锁机制就能保证我们的进程有序的访问该资源。就称作为“分布式锁”，是分布式协调技术实现的核心内容''4、分片''任务的分布式执行，需要将一个任务拆分为多个独立的任务项，然后由分布式的服务器分别执行某一个或几个分片项。''5、单点故障''通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就瘫痪了，这就叫做单点故障。''传统的解决办法：''就是准备一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包后向备用节点发送回复Ack，当备用节点收到回复后就会认为主节点还活着，让他继续提供服务。''当主节点挂了，那么备用节点就收不到Ack回复了，然后备用节点就代替它成为了主节点。''但是存在一个安全隐患，那就是当发生网络故障时，备用节点收不到主节点的回复Ack，他会认为主节点死了，它会代替主节点成为新的主节点。''zookeeper''解决方案：''在引入了zookeeper后我们启用了两个主节点，A和B启动后他们都会去Zookeeper去注册一个节点，假设A注册的节点为master-01，B注册的节点为master-02，注册完之后进行选举，编号最小的节点将被选举为主节点。''如果A挂了，它在zookeeper注册的节点将会被自动删除，Zookeeper感知到节点的变化，然后再次发出选举，这时候B将获胜成为新的主节点。如果A恢复了，它会去zookeeper再注册一个节点，编号为master-03。这时zookeeper感知到节点的变化，会再次发起选举，此时还是B胜出。那么B继续担任主节点，A则成为备用节点。''6、Mesos''――像用一台电脑一样使用整个数据中心''是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，是以与Linux内核同样的原则而创建的，不同点仅仅是在于抽象的层面。使用ZooKeeper实现Master和Slave的容错。''7、FailStore策略''FailStrore，顾名思义就是Fail and Store，这个主要是用于失败了存储的，主要用于节点容错，当远程数据交互失败后，存储在本地，等待远程通讯恢复后，再将数据进行提交。'"
CSDN,https://blog.csdn.net/weixin_44625302/article/details/107288668,springboot+vue项目大型实战（一）后端开发,Nym_车厘子,springboot,,2020-07-12 16:59:53,"'源码下载地址！！！点我''数据库创建表''SET NAMES utf8mb4'';''SET FOREIGN_KEY_CHECKS''=''0'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Table structure''for''book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''DROP TABLE IF EXISTS `book`'';''CREATE TABLE `book`''(''`id`''int''(''10'')''NOT NULL'',''`name`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`author`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`publish`''varchar''(''20'')''CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL'',''`pages`''int''(''10'')''NULL DEFAULT NULL'',''`price`''float''(''10'',''2'')''NULL DEFAULT NULL'',''`bookcaseid`''int''(''10'')''NULL DEFAULT NULL'',''`abled`''int''(''255'')''NULL DEFAULT NULL'',''PRIMARY KEY''(''`id`'')''USING BTREE'')''ENGINE''=''InnoDB CHARACTER SET''=''utf8 COLLATE''=''utf8_general_ci ROW_FORMAT''=''Compact'';''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''Records of book''--''--''--''--''--''--''--''--''--''--''--''--''--''--''--''INSERT INTO `book` VALUES''(''1'','""'上下五千年'""','""'曹操'""','""'中国人民出版社'""',''999'',''99.99'',''10'',''1'')'';''INSERT INTO `book` VALUES''(''2'','""'SPSS统计'""','""'王五'""','""'SPSS出版社'""',''330'',''26.00'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''3'','""'四级必备词汇'""','""'李四'""','""'清华出版社'""',''150'',''17.30'',''1'',''1'')'';''INSERT INTO `book` VALUES''(''4'','""'六级必备词汇'""','""'张三'""','""'北大出版社'""',''220'',''59.00'',''3'',''1'')'';''INSERT INTO `book` VALUES''(''5'','""'高考必备'""','""'王强'""','""'上海出版公司'""',''300'',''27.30'',''4'',''1'')'';''INSERT INTO `book` VALUES''(''6'','""'考研必备'""','""'郭德纲'""','""'天津出版社'""',''225'',''22.80'',''1'',''1'')'';''SET FOREIGN_KEY_CHECKS''=''1'';''1.创建项目''2.勾选的依赖''3.目录结构''4.配置application.yml''spring'':''datasource'':''url'':''jdbc'':''mysql'':''/''/''localhost'':''3306''/''library''?''useUnicode''=''true''&''characterEncoding''=''UTF''-''8''&''serverTimezone''=''Asia''/''Shanghai\n    username'':''root\n    password'':''123456''driver''-''class''-''name'':''com''.''mysql''.''cj''.''jdbc''.''Driver\n  jpa'':''show''-''sql'':''true''properties'':''hibernate'':''format_sql'':''true''server'':''port'':''8181''5.Book实体类（使用JPA）''package''com''.''xyj''.''entity'';''import''lombok''.''Data'';''import''javax''.''persistence''.''Entity'';''import''javax''.''persistence''.''Id'';''/**\n * @author xyj\n * @date 2020/7/12 -15:30\n */''@Entity''@Data''public''class''Book''{''@Id''private''Integer id'';''private''String name'';''private''String author'';''}''6.BookRepository接口''package''com''.''xyj''.''repository'';''import''com''.''xyj''.''entity''.''Book'';''import''org''.''springframework''.''data''.''jpa''.''repository''.''JpaRepository'';''public''interface''BookRepository''extends''JpaRepository''<''Book'',''Integer''>''{''}''7.BookHandleer（实现查询功能）''package''com''.''xyj''.''controller'';''import''com''.''xyj''.''entity''.''Book'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''GetMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RequestMapping'';''import''org''.''springframework''.''web''.''bind''.''annotation''.''RestController'';''import''java''.''util''.''List'';''/**\n * @author xyj\n * @date 2020/7/12 -15:45\n */''@RestController''@RequestMapping''(''""/book""'')''public''class''BookHandleer''{''@Autowired''private''BookRepository bookRepository'';''@GetMapping''(''""/findAll""'')''public''List''<''Book''>''findAll''('')''{''return''bookRepository''.''findAll''('')'';''}''}''8.我们可以在测试类中查询BookSpringbootApplicationTests（控制台显示）''package''com''.''xyj'';''import''com''.''xyj''.''repository''.''BookRepository'';''import''org''.''junit''.''jupiter''.''api''.''Test'';''import''org''.''springframework''.''beans''.''factory''.''annotation''.''Autowired'';''import''org''.''springframework''.''boot''.''test''.''context''.''SpringBootTest'';''@SpringBootTest''class''BookSpringbootApplicationTests''{''@Autowired''private''BookRepository bookRepository'';''@Test''void''contextLoads''('')''{''System''.''out''.''println''(''bookRepository''.''findAll''('')'')'';''}''}''9.直接启动springboot项目，在页面可以显示所有查询的数据（我们只查询三个字段进行测试）''10.接下来我们需要与前端交互数据（创建的vue工程都是自动生成的，自己添加一个Book.vue）''补充CVue-cli 3.x 添加axios插件''11.Book.vue（其中data（）{}中的数据都是测试用的，created中是从后端获取的数据C数据库中）''<''template''>''<''div''>''<''table''>''<''tr''>''<''td''>''编号''<''/''td''>''<''td''>''图书名称''<''/''td''>''<''td''>''作者''<''/''td''>''<''/''tr''>''<''tr v''-''for''=''""item in books""''>''<''td''>''{''{''item''.''id''}''}''<''/''td''>''<''td''>''{''{''item''.''name''}''}''<''/''td''>''<''td''>''{''{''item''.''author''}''}''<''/''td''>''<''/''tr''>''<''/''table''>''<''/''div''>''<''/''template''>''<''script''>''export''default''{''name'':''""Book""'',''data''('')''{''return''{''msg'':'""'hello xyj'""',''books'':''[''{''id'':''1'',''name'':'""'xyj'""',''author'':'""'AAAAAA'""',''}'',''{''id'':''2'',''name'':'""'wangwu'""',''author'':'""'王五'""',''}'']''}''}'',''created''('')''{''const''_this''=''this''axios''.''get''('""'http://localhost:8181/book/findAll/'""')''.''then''(''function''(''resp'')''{''_this''.''books''=''resp''.''data''}'')''}''}''<''/''script''>''<''style scoped''>''<''/''style''>''12.在index.js中添加路由''13.由于端口不能相同，我们需要在springboot项目里添加CrosConfig''package''com''.''xyj''.''config'';''import''org''.''springframework''.''context''.''annotation''.''Configuration'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''CorsRegistry'';''import''org''.''springframework''.''web''.''servlet''.''config''.''annotation''.''WebMvcConfigurer'';''/**\n * @author xyj\n * @date 2020/7/12 -16:11\n */''@Configuration''public''class''CrosConfig''implements''WebMvcConfigurer''{''@Override''public''void''addCorsMappings''(''CorsRegistry registry'')''{''registry''.''addMapping''(''""/**""'')''.''allowedOrigins''(''""*""'')''.''allowedMethods''(''""GET""'',''""HEAD""'',''""POST""'',''""PUT""'',''""DELETE""'',''""OPTIONS""'')''.''allowCredentials''(''true'')''.''maxAge''(''3600'')''.''allowedHeaders''(''""*""'')'';''}''}''14.这个时候我们可以启动项目''cnpm run serve''这样就可以把数据库数据拿过来了！''上一篇：''vue ui可视化界面进行创建vue项目安装''下一篇：''springboot+vue项目大型实战（二）Elemen UI深入浅出分页操作'"
CSDN,https://blog.csdn.net/u012394095/article/details/79470904,分布式定时任务对比,sharedCode,xxl-job分布式定时任务,,2018-03-07 14:42:26,"'1. 什么是分布式定时任务''把分散的，可靠性差的计划任务纳入统一的平台，并实现集群管理调度和分布式部署的一种定时任务的管理方式。叫做分布式定时任务。''2. 常见开源方案''elastic-job'',''xxl-job ，''quartz , saturn,\xa0 opencron ,''antares''elastic-job''elastic-job 是由当当网基于quartz 二次开发之后的分布式调度解决方案 ， 由两个相对独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成 。''Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务。''Elastic-Job-Cloud使用Mesos + Docker(TBD)的解决方案，额外提供资源治理、应用分发以及进程隔离等服务''亮点：''基于quartz 定时任务框架为基础的，因此具备quartz的大部分功能''使用zookeeper做协调，调度中心，更加轻量级''支持任务的分片''支持弹性扩容 ， 可以水平扩展 ， 当任务再次运行时，会检查当前的服务器数量，重新分片，分片结束之后才会继续执行任务''失效转移，容错处理，当一台调度服务器宕机或者跟zookeeper断开连接之后，会立即停止作业，然后再去寻找其他空闲的调度服务器，来运行剩余的任务''提供运维界面，可以管理作业和注册中心。''elastic-job结合了quartz非常优秀的时间调度功能，并且利用ZooKeeper实现了灵活的分片策略。除此之外，还加入了大量实用的监控和管理功能，''以及其开源社区活跃、文档齐全、代码优雅等优点，是分布式任务调度框架的推荐选择。''由于elastic-job-lite\xa0 不支持动态添加作业，此处仅贴上elastic-job-Cloud架构图''xxl-job''由个人开源的一个轻量级分布式任务调度框架 ，主要分为 调度中心和执行器两部分 ， 调度中心在启动初始化的时候，会默认生成执行器的RPC代理''对象（http协议调用）， 执行器项目启动之后， 调度中心在触发定时器之后通过jobHandle 来调用执行器项目里面的代码，核心功能和elastic-job差不多''，同时技术文档比较完善''系统架构图：''quartz''quartz 的常见集群方案如下，通过在数据库中配置定时器信息， 以数据库悲观锁的方式达到同一个任务始终只有一个节点在运行，''优点：''保证节点高可用 （HA）， 如果某一个几点挂了， 其他节点可以顶上''缺点：''同一个任务只能有一个节点运行，其他节点将不执行任务，性能低，资源浪费''当碰到大量短任务时，各个节点频繁的竞争数据库锁，节点越多这种情况越严重。性能会很低下''quartz 的分布式仅解决了集群高可用的问题，并没有解决任务分片的问题，不能实现水平扩展''Saturn''Saturn是唯品会在github开源的一款分布式任务调度产品。它是基于当当elastic-job 1.0版本来开发的，其上完善了一些功能和添加了一些新的feature。''亮点：''支持多语言开发 python、Go、Shell、Java、Php。''管理控制台和数据统计分析更加完善''缺点：''技术文档较少 ， 该框架是2016年由唯品会的研发团队基于elastic-job开发而来的''opencron''一个功能完善真正通用的linux定时任务调度定系统,满足多种场景下各种复杂的定时任务调度,同时集成了linux实时监控,webssh,提供一个方便管理定时任务的平台''缺点：仅支持''kill任务， 现场执行，查询任务运行状态 等， 主要功能是着重于任务的修改和查询上。 不能动态的添加任务以及任务分片。''antares''优点：''一个任务仅会被服务器集群中的某个节点调度，调度机制基于成熟的 quartz''并行执行 ， 用户可通过对任务预分片，有效提升任务执行效率''失效转移''弹性扩容，在任务运行时，可以动态的加机器''友好的管理控制台''缺点：''不能动态的添加任务，仅能在控制台对任务进行触发，暂停，删除等操作''文档不多，开源社区不够活跃''系统架构图如下：''4. 比较''此处列出了几个代表性的开源产品''feature''quartz''elastic-job-cloud''xxl-job''antares''opencron''依赖''mysql''jdk1.7+, zookeeper 3.4.6+ ,maven3.0.4+ ,mesos''mysql ,jdk1.7+ , maven3.0+''jdk 1.7+ , redis , zookeeper''jdk1.7+ , Tomcat8.0+''HA''多节点部署，通过竞争数据库锁来保证只有一个节点执行任务''通过zookeeper的注册与发现，可以动态的添加服务器。 支持水平扩容''集群部署''集群部署''―''任务分片''―''支持''支持''支持''―''文档完善''完善''完善''完善''文档略少''文档略少''管理界面''无''支持''支持''支持''支持''难易程度''简单''较复杂''简单''一般''一般''公司''OpenSymphony''当当网''个人''个人''个人''高级功能''―''弹性扩容，多种作业模式，失效转移，运行状态收集，多线程处理数据，幂等性，容错处理，spring命名空间支持''弹性扩容，分片广播，故障转移，Rolling实时日志，GLUE（支持在线编辑代码，免发布）,任务进度监控，任务依赖，数据加密，邮件报警，运行报表，国际化''任务分片， 失效转移，弹性扩容 ，''时间规则支持quartz和crontab ，kill任务， 现场执行，查询任务运行状态''缺点''没有管理界面，以及不支持任务分片等。不适用于分布式场景''需要引入zookeeper , mesos, 增加系统复杂度, 学习成本较高''调度中心通过获取 DB锁来保证集群中执行任务的唯一性， 如果短任务很多，随着调度中心集群数量增加，那么数据库的锁竞争会比较厉害，性能不好。''不支持动态添加任务''不适用于分布式场景''使用企业''大众化产品，对分布式调度要求不高的公司大面积使用''36氪，当当网，国美，金柚网，联想，唯品会，亚信，平安，猪八戒''大众点评，运满满，优信二手车，拍拍贷''―''―''sharedCode源码交流群，欢迎喜欢阅读源码的朋友加群，添加下面的微信， 备注”加群“ 。'"
CSDN,https://blog.csdn.net/kkorkk/article/details/80898619,vue项目部署运行到tomcat上,kkorkk,前端,,2018-07-03 15:15:08,"'使用webstrorm开发vue前端工程项目时，使用命令npm run dev开启服务，可以通过访问''电脑IP:电脑端口''实时预览页面，当时我在想使用手机端来调试页面时，发现即使手机与电脑处于同一局域网环境下，仍然无法访问。''这就很奇怪了 ，平时只要我的电脑和手机处于同一局域网环境下，使用手机访问''电脑IP:电脑端口/项目名，''就可以正常访问，现在却不行，结果去网上搜索，普遍的一个解决办法是在webstorm中通过添加一个部署来使用的，就像是下图一样：''经过了好一番折腾，发现手机端可以访问电脑端的文件了，可是发现这是一个坑，这样子设置了只是说手机可以访问电脑当前目录的一些文件，对于静态文件还好，但是这是一个服务，那就没办法了。''闲话少叙，说一个我自己的''解决办法''：''1.''【修改index.js】'""修改config目录下的index.js，将assetsPublicPath: '/'改为assetsPublicPath: './'，注意，有两处，都要改，不然打包部署到tomcat上面访问是一片空白；还有一点需要注意的就是，webstorm起服务时，需要改回来，不然也是不行的""'2.''【打包】''项目文件目录下运行命令：npm run build，将项目打包好，然后当前项目目录下有一个dist文件夹，该文件夹下有一个index.html和static文件夹''3.''【tomcat部署】''现在，在tomcat的webapps文件夹下以项目名称新建一个文件夹，比如my_app，然后将index.html和static文件夹复制到my_app文件夹下，现在就可以启动服务器了，访问正常。'"
CSDN,https://blog.csdn.net/u012411231/article/details/89949019,webpack打包vue项目并tomcat启动访问过程踩坑总结,清风问水,vue技术相关,,2019-05-08 11:49:44,"'webpack打包vue项目并启动访问过程踩坑总结''vue项目开发完毕之后，我们使用npm run build 对vue项目进行打包，然后放入到tomcat中运行，再进行地址访问。整个过程清晰明了，但是却容易遇到一些问题，第一次跑完流程，打开地址发现所有的打包的js，css全部找不到，这是为什么呢？''直接打包会再项目里面打包出一个dist文件夹，里面有静态css,js文件以及外部有一个index.html,而我们放到tomcat中确是把dist里面的内容放到了webapp下面的一个自己建的文件夹（起名叫product），如图所示''而我们vue项目中config/index.js里面定义的build地址里面没有这个product，故而启动程序输入localhost:8080/product 发现打包的静态文件都是404''我第一次改成了这种，然后重新打包，发现已经找到4个js文件了，还有一个被打包的 js 迟迟搜索不到，404，仔细查看了一下network，原来是地址中的product和static中间的斜杠丢失掉了，为什么会丢失呢？''我重新仔细想了下，觉得再配置文件中/product后面应该再加一个斜杠会不会可以呢，？ 答案是肯定的！！ ，可以完美解决这个问题，但是一定要注意，要重新的把你的打包的cmd窗口关闭再重启，否则命令缓存影响打包过程，我被这个蒙蔽了好久，一直用一个cmd去打包，本来地址配对了，却被这个问题压住了，毕竟不是Linux系统，像这种加一个扛 还是少一个斜杠的问题，其他JS都是没问题，多半就是打包器的问题，打包不能保证100%打包完整。''因为是要打包给后台去做接口的的，所以这里面，我直接打包成功后发给后台，对接数据就完事了。''原创说明：如需转发，请尊重个人原创，写明原创地址。'"
CSDN,https://blog.csdn.net/u012411231/article/details/89949019,webpack打包vue项目并tomcat启动访问过程踩坑总结,清风问水,vue技术相关,,2019-05-08 11:49:44,"'webpack打包vue项目并启动访问过程踩坑总结''vue项目开发完毕之后，我们使用npm run build 对vue项目进行打包，然后放入到tomcat中运行，再进行地址访问。整个过程清晰明了，但是却容易遇到一些问题，第一次跑完流程，打开地址发现所有的打包的js，css全部找不到，这是为什么呢？''直接打包会再项目里面打包出一个dist文件夹，里面有静态css,js文件以及外部有一个index.html,而我们放到tomcat中确是把dist里面的内容放到了webapp下面的一个自己建的文件夹（起名叫product），如图所示''而我们vue项目中config/index.js里面定义的build地址里面没有这个product，故而启动程序输入localhost:8080/product 发现打包的静态文件都是404''我第一次改成了这种，然后重新打包，发现已经找到4个js文件了，还有一个被打包的 js 迟迟搜索不到，404，仔细查看了一下network，原来是地址中的product和static中间的斜杠丢失掉了，为什么会丢失呢？''我重新仔细想了下，觉得再配置文件中/product后面应该再加一个斜杠会不会可以呢，？ 答案是肯定的！！ ，可以完美解决这个问题，但是一定要注意，要重新的把你的打包的cmd窗口关闭再重启，否则命令缓存影响打包过程，我被这个蒙蔽了好久，一直用一个cmd去打包，本来地址配对了，却被这个问题压住了，毕竟不是Linux系统，像这种加一个扛 还是少一个斜杠的问题，其他JS都是没问题，多半就是打包器的问题，打包不能保证100%打包完整。''因为是要打包给后台去做接口的的，所以这里面，我直接打包成功后发给后台，对接数据就完事了。''原创说明：如需转发，请尊重个人原创，写明原创地址。'"
CSDN,https://blog.csdn.net/u012379844/article/details/82716146,分布式调度框架大集合,路灯下的女孩,框架相关,,2018-09-15 18:03:31,"'分布式任务调度框架''1''、什么是分布式任务调度？''2''、常见的分布式任务调度框架有哪些？''3''、分布式任务调度框架的技术选型？''4''、分布式任务调度框架的安装与使用？''大对比表格：''https://pan.baidu.com/s/1CZAjTFqIhinzlVLnrrMUKQ''分布式任务调度，三个关键词：分布式、任务调度、配置中心。''分布式：平台是分布式部署的，各个节点之间可以无状态和无限的水平扩展；''任务调度：涉及到任务状态管理、任务调度请求的发送与接收、具体任务的分配、任务的具体执行；（这里又会遇到一共要处理哪些任务、任务要分配到哪些机器上处理、任务分发的时候判断哪些机器可以用等问题，所以又需要一个可以感知整个集群运行状态的配置中心）''配置中心：可以感知整个集群的状态、任务信息的注册''一个分布式任务调度系统需要以下内容：''web''模块、''server''模块、''Scheduler''模块、''worker''模块、注册中心。''1''、''Web''模块：用来提供任务的信息，控制任务的状态、信息展示等。''2''、''Server''模块：负责接收''web''端传来的任务执行的信息，下发任务调度请求给''Scheduler''，会去注册中心进行注册''3''、''Scheduler''模块：接收''server''端传来的调度请求，将任务进行更加细化的拆分然后下发，到注册中心进行注册，获取到可以干活的''worker''。''4''、''Worker''模块：负责具体的任务执行。''5''、注册中心。''1、什么是分布式任务调度？''任务调度是指基于给定的时间点，给定的时间间隔或者给定执行次数自动的执行任务。任务调度是是操作系统的重要组成部分，而对于实时的操作系统，任务调度直接影响着操作系统的实时性能。任务调度涉及到多线程并发、运行时间规则定制及解析、线程池的维护等诸多方面的工作。''WEB服务器在接受请求时，会创建一个新的线程服务。但是资源有限，必须对资源进行控制，首先就是限制服务线程的最大数目，其次考虑以线程池共享服务的线程资源，降低频繁创建、销毁线程的消耗；然后任务调度信息的存储包括运行次数、调度规则以及运行数据等。一个合适的任务调度框架对于项目的整体性能来说显得尤为重要。''2、常见的任务调度框架有哪些？''我们在实际的开发工作中，或多或少的都会用到任务调度这个功能。常见的分布式任务调度框架有：cronsun、Elastic-job、saturn、lts、TBSchedule、xxl-job等。''2.1cronsun''crontab是Linux系统里面最简单易用的定时任务管理工具，在Linux上由crond来周期性的执行指令列表，执行的任务称为cron job，多个任务就称为crontab。crontab任务调度指令的基本格式为：''*\xa0\xa0\xa0\xa0*\xa0\xa0\xa0\xa0*\xa0\xa0\xa0*\xa0\xa0\xa0\xa0*\xa0\xa0\xa0\xa0command''分''时''日''月''周''命令''但是时间久了之后会发现，crontab会存在一些问题：''大量的crontab分散在各台服务器，带来了很高的维护成本；''任务没有按时执行，过了很长的时间才能发现，需要重试或者排查；''crontab分散在很多集群上，需要一台一台的去查看日志；''crontab存在单点问题，对于不能重复执行的定时任务很伤脑；''……''因此非常需要一个集中管理定时任务的系统，于是就有了cronsun。cronsun是一个分布式任务系统，单个节点和Linux机器上的contab近似，是为了解决多台Linux机器上crontab任务管理不方便的问题，同时提供了任务高可用的支持（当某个节点死机的时候可以自动调整到正常的节点执行）。与此同时，它还支持界面管理机器上的任务，支持任务失败邮件提醒，安装简单，使用简便，是替换crontab的一个不错的选择。''cronsun中主要有三个组件，都是通过etcd通讯的。cronnode负责节点的分组及节点的状态，cronweb是用来管理任务的、任务的执行结果都可以在上面看。''cronsun的系统架构如下图所示，简单的来说就是，所有的任务都会存储在一个分布式etcd里，单个crond部署成一个服务，也就是图中所示的node.1、node.2、node.n等，然后再由web界面去管理。如果任务执行失败的话，会发送失败的邮件，当单个节点死机的时候，也会自动调整到正常的节点去执行任务。''cronsun是在管理后台添加任务的，所以一旦管理后台泄漏出去了，则存在一定的危险性，所以cronsun支持security.json的安全设置：''{\n""open"": true,\n""#users"": ""允许选择运行脚本的用户"", ""users"": [\n""www"", ""db"" ],\n""#ext"": ""允许添加以下扩展名结束的脚本"", ""ext"": [\n"".cron.sh"", "".cron.py"" ]\n}''如以上设置开启安全限制，则添加和执行任务的时候只允许选择配置里面指定的用户来执行脚本，并且脚本的扩展名要在配置的脚本的扩展名限制的列表里面。''2.2、Elastic-job''Elastic-job是当当开源的一款非常好用的作业框架，Elastic-job在2.x之后，出现了两个相互独立的产品线：Elastic-job-lite和Elastic-job-cloud。''2.2.1、Elastic-job-lite''Elastic-job-lite定位为轻量级无中心化的解决方案，使用jar包的形式提供分布式任务的协调服务，外部依赖仅依赖于zookeeper。''Elastic-job-lite的架构图如下图所示：''从上面的框架图中可以看出，Elastic-job-lite框架使用zookeeper作为注册中心，Elastic-job-lite框架通过监听感知zookeeper数据的变化，并做相应的处理；运维平台也仅是通过读取zk数据来展现作业状态，或是更新zk数据修改全局配置。运维平台和Elastic-job-lite没有直接的关系，完全解耦合。Elastic-job-lite并不直接提供数据处理的功能，框架只会将分片项分配给各个正在运行中的服务器，分片项与真是数据的对应关系需要开发者在应用程序中自行处理。''Elastic-job-lite并无作业调度中心节点，而是基于部署作业框架的程序在到达相应时间点时各自触发调度。注册中心仅用于作业注册和监控信息存储，而主作业节点仅用于处理分片和清理的功能。''（1''）注册中心的数据结构''我们先来了解一下该框架在zookeeper上的节点情况。首先注册中心在命名的空间下创建作业名称节点（''作业名称用来区分不同的作业，一旦修改名称，则认为是新的作业''），作业名称节点下又包含5个子节点：''config：保存作业的配置信息，以JSON格式存储''sharding：保存作业的分片信息，它的子节点是分片项序号，从零开始，至分片总数减一''leader：该节点保存作业服务器主节点的信息，分为election、sharding和failover三个子节点，分别用于主节点的选举、分片和失效转移''instances：该节点保存的是作业运行实例的信息，子节点是当前作业运行实例的主键''servers：该节点保存作业服务器的信息，子节点是作业服务器的IP地址''（2）实现原理''第一台服务器上线触发主服务器选举，主服务器一旦下线，则重新触发选举，选举过程中阻塞，只有当主服务器选举完成，才会去执行其他的任务；''某服务器上线时会自动将服务器的信息注册到注册中心，下线时会自动更新服务器的状态；''主节点选举，服务器上下线，分片总数变更均更新重新分片标记；''定时任务触发时，如需重新分片，则通过主服务器分片，分片过程中阻塞，分片结束后才可以执行任务。如分片过程中主服务器下线，则先选举主服务器在分片；''由上一项说明可知，为了维持作业运行时的稳定性，运行过程中只会标记分片的状态，不会重新分片，分片仅可能发生在下次任务触发前；''每次分片都会按照ip排序，保证分片结果不会产生较大的波动；''实现失效转移功能，在某台服务器执行完毕后主动抓取未分配的分片，并且在某台服务器下线后主动寻找可用的服务器执行任务。''elastic底层的任务调度还是使用的quartz，通过zookeeper来动态给job节点分片。如果很大体量的用户需要我们在特定的时间段内计算完成，那么我们肯定是希望我们的任务可以通过集群达到水平的扩展，集群里的每个节点都处理部分的用户，不管用户的数量有多大，我们只需要增加机器就可以了。举个例子：比如我们希望3台机器跑job，我么将我们的任务分成3片，框架通过zk的协调，最终会让3台机器分配到0，1，2的任务片，比如server0->0、server1->1、server2->2，当server0执行时，可以只查询id%3==0的用户，server1可以只查询id%3==1的用户，server2可以只查询id%3==2的用户。''在以上的基础上再增加一个server3，此时，server3分不到任何的分片，没有分到任务分片的程序将不执行。如果此时server2挂了，那么server2被分到的任务分片将会分配给server3，所以server3就会代替server2执行。如果此时server3也挂了，那么框架也会自动的将server3的任务分片随机分配到server0或者server1，那么就可能成：server0->0、server1->1,2。''这种特性称之为''弹性扩容''。''2.2.2、Elastic-job-cloud''Elastic-job-cloud包含了Elastic-job-lite的全部功能，它是以私有云平台的方式提供集资源、调度以及分片为一体的全量级解决方案，依赖于Mesos和Zookeeper，它额外提供了资源治理、应用分发以及进程隔离等服务。他们两个提供同一套API开发作业，开发者仅需一次开发，然后可根据需要以lite或cloud的方式部署。''2.3、saturn''Saturn（定时任务调度系统）是唯品会自主研发的分布式的定时任务的调度平台，它是基于Elastic-job版本1开发的。目标是取代传统的Linux Cron/Spring Batch Job/Quartz的方式，做到全域统一配置、统一监控、任务高可用以及分片。Saturn的任务可以使用多种语言开发，比如python、Go、Shell、Java、Php等。''Saturn包括两大部分，Saturn Console和Saturn Executor。Console是一个WEB UI，用来对作业/Executor的管理，统计报表展现等。他同时也是整个调度系统的大脑：将作业任务分配到各Executor。Executor是执行任务的worker：按照作业配置的要求去执行部署于Executor所在容器或物理机当中的作业脚本和代码。Saturn高度依赖于zookeeper，每个executor及调度服务都会在zookeeper上进行注册，确保调度程序能够及时得到executor的状态。''Saturn定时任务调度的最小单位是分片，即任务的一个执行单元。Saturn的基本任务就是将任务分成多个分片，并将每个分片通过算法调度到对应的executor上去执行。''2.3.1、Staurn基本原理''Saturn的基本原理是将作业在逻辑上划分为若干个分片，通过作业分片调度器将作业分片指派给特定的执行节点。执行节点通过quartz触发执行作业的具体实现，在执行的时候，会将分片序号和参数作为参数传入。作业的实现逻辑需分析分片序号和分片参数，并以此为依据来调用具体的实现（比如一个批量处理数据库的作业，可以划分0号分片处理1-10号数据库，1号分片可以处理11-20号数据库）。''2.3.2、Saturn作业调度算法''（1''）方案的设计''原理是给每个作业分片一个负载值和优先执行节点（prefer list），当需要重新分片时，参考作业优先设定和执行节点的负载值来进行域内节点之间的资源分配，从而达到资源平衡。''（2''）前置条件''A：每个分片都引入一个负载值（load），由用户通过Saturn UI界面输入''B：为每一个作业引入新的属性prefer list（优先列表，或者叫欲分配列表），由管理员通过ui界面编辑''C：作业引入启用状态（enabled/disabled），用户通过UI界面改变这个状态；启用状态的作业会被节点执行，且不可编辑、删除，不可对prefer list进行调整，禁用状态的作业不会被执行''（3''）实施步骤''第一步，摘取；第二步，放回（将这些作业分片按照负载值从大到小顺序逐个分配给负载最小的执行节点）。''（''3.1''）''executor''上线''摘取：''第一步，找出新上线节点的全部可执行作业列表；对于每个作业，判断prefer list中是否包含了新上线的节点；如果是，则摘取其中全部的分片；这些已经处理过的作业称为预处理作业；''第二步，从新上线节点的作业列表中减去预分配作业，然后使用以下的方法依次摘取：''假如上线的executor为a，它能处理的作业类型为j1，j2（已减去预分配列表）。遍历当前域下的executor列表，拿掉全部作业类型为j1，j2的分片，加上尚未分配的j1，j2作业分片列表，作为算法的待分配列表''在处理每个节点时，每拿掉一个作业分片后判断被拿掉的负载（load）是否已经超过了自身处理前总负载（load）的1/n（n为当前executor节点的总数量），如果超过，则本执行节点摘取完成，继续处理下一个执行节点；如果不超过则继续摘取，直到超过（大于等于）为止。''放回：''a．构造需要添加的作业分片列表，我们起名为待分配列表，长度为n，待分配列表按照负载（load）从大到小排序，排序时需保证相同作业的所有分片时连续的''b．构造每种作业类型的executor列表（如果有prefer list，且有存活，则该作业的executor列表就是prefer list），得到一个map<jobName,executorList>’''c．从待分配列表中依次取出第0到第n-1个作业分片jobi''d．从map中取出可运行jobi的executor列表listi''e．将jobi分配给listi中负载总和最小的executor''举例如下：''（3.2''）''executor''下线''摘取：''取出下线的executor当前分配到的全部作业分片，作为算法的待分配列表''放回：''使用平衡算法逐个处理待分配列表中的作业分片''（''3.3''）作业启动''摘取：''从所有executor中摘取将被启动作业的全部分片作为算法的待分配列表''放回：''使用调整后的平衡算法放回''（''3.4''）作业停止''摘取：''将被停止的作业分片从各节点删除''返回：''无''注：''Saturn''架构文档请见''https://github.com/vipshop/Saturn/wiki/Saturn''架构文档''2.4、lts''LTS是一个轻量级分布式任务调度框架，主要用于解决分布式任务的调度问题，支持实时任务、定时任务和Cron任务，有较好的伸缩性、扩展性以及健壮稳定性。他参考hadoop的思想，主要有以下四个节点：''JobClient：主要负责提交任务，并接收任务执行的反馈结果''JobTracker：负责接收并分配任务，任务调度''TaskTracker：负责执行任务，执行完反馈给JobTracker''LTS-Admin：（管理后台）主要负责节点管理，任务队列管理，监控管理等''其中JobClient、JobTracker、TaskTracker是无状态的，可以部署多个并动态的进行删减，来实现负载均衡，实现更大的负载量，并且框架采用FailStore策略使得LTS具有很好的容错能力。''一个典型的定时任务，大概的执行流程如下：''添加任务以后在注册中心进行注册，zk集群会暴露各个节点的信息，进行master节点选举等''JobClient将任务进行提交，如果成功的话将进行下一步；否则的话进入FailStore，重试''JobTracker接收并分配任务，如果任务已经存在，则结束；否则任务进入可执行队列ExecutableJobQueue，接着进入执行中任务队列ExecutingJobQueue，最后发送给TaskTracker进行执行''TaskTracker执行完毕后，将结果反馈给客户端；如果反馈成功，则回到JobClient执行下一个任务；否则的话进入FeedbackJobQueue重试''2.5、quartz''Quartz是OpenSymphony开源组织在任务调度领域的一个开源项目，完全基于java实现。作为一个优秀的开源框架，Quartz具有以下特点：强大的调度功能、灵活的应用方式、分布式和集群能力，另外作为spring默认的调度框架，很容易实现与Spring集成，实现灵活可配置的调度功能。''Quartz的核心元素如下：''Scheduler：任务调度器，是实际执行任务调度的控制器''Trigger；触发器，用于定义任务调度的时间规则''Calendar：它是一些日历特定时间的集合，一个Trigger可以包含多个Calendar，以便于排除或包含某些时间点''JobDetail：用来描述Job实现类及其他相关的静态信息，如Job的名字、关联监听器等信息''Job：是一个接口，只有一个方法void execute(JobExecutionContext\xa0context)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息''Quartz的单机版大家应该都比较熟悉，它的集群方案是使用数据库来实现的。集群架构如下：''上图3个节点在数据库中都有同一份Job定义，如果某一个节点失效，那么Job会在其他节点上执行。因为每个节点上的代码都是一样的，那么如何保证只有一台机器上触发呢？答案是使用了数据库锁。在quartz集群解决方案了有张scheduler_locks，采用了悲观锁的方式对triggers表进行了行加锁，以保证任务同步的正确性。''简单来说，quartz的分布式调度策略是以数据库为边界的一种异步策略。各个调度器都遵守一个基于数据库锁的操作规则从而保证了操作的唯一性，同时多个节点的异步运行保证了服务的可靠。但这种策略有自己的局限性：集群特性对于高CPU使用率的任务效果特别好，但是对于大量的短任务，各个节点都会抢占数据库锁，这样就出现大量的线程等待资源。Quartz的分布式只解决了任务高可用的问题，并没有解决任务分片的问题，还是会有单机处理的极限。''2.6、TBSchedule''TBSchedule是一款非常优秀的分布式调度框架，广泛应用于阿里巴巴、淘宝、支付宝、京东、汽车之家等很多互联网企业的流程调度系统。TBSchedule在时间调度方面虽然没有quartz强大，但是它支持分片的功能。和quartz不同的是，TBSchedule使用zk来实现任务调度的高可用和分片。纯java开发。''TBSchedule项目实际上可以分为两部分。1）schedule管理控制台。负责控制、监控任务执行状态。2）实际执行job的客户端程序。在实际使用时，需要先启动zk，然后部署TBSchedule web界面的管理控制台，最后启动实际执行job的客户端程序。这里的zk并不实际控制任务调度，它只是负责与N台执行job任务的客户端进行通讯，协调、管理、监控这些机器的运行信息。实际分配任务的是管理控制台，控制台从zk获取job的运行信息。TBSchedule通过控制ZNode的创建、修改、删除来间接控制job的执行，执行任务的客户端监听它们对应ZNode的状态更新事件，从而达到TBSchedule控制job执行的目的。特点：''TBSchedule的分布式机制是通过灵活的Sharding方式实现的，比如可以按所有数据的ID按10取模分片、按月份分片等，根据不同的场景由客户端配置分片规则。''TBSchedule的宿主服务器可以进行动态的扩容和资源回收，这个特点主要是因为它后端依赖的zooKeeper，这里的zooKeeper对于TBSchedule来说相当于NoSQL，用于存储策略、任务、心跳等信息数据，他的数据结构类似于文件系统的目录结构，他的节点有临时节点、持久节点之分。一个新的服务器上线后，会在zk中创建一个代表当前服务器的一个唯一性路径（临时节点），并且新上线的服务器会和zk保持长连接，当通信断开后，节点会自动删除。''TBSchedule会定时扫描当前服务器的数量，重新进行任务分配。''TBSchedule不仅提供了服务端的高性能调度服务，还提供了一个scheduleConsole war随着宿主应用的部署直接部署到服务器，可以通过web的方式对调度的任务、策略进行监控管理，以及实时更新调整。''2.7、xxl-job''xxl-job是一个轻量级的分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。''xxl-job的''设计思想''为：''（1）将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求''（2）将任务抽象成分散的JobHandler，交由执行器统一管理，执行器负责接收调度请求并执行对应的JobHandler中业务逻辑''因此，“调度”和“任务”可以互相解偶，提高系统整体的稳定性和扩展性。''xxl-job''系统的组成''分为：''（1）调度模块（调度中心）：负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。''（2）执行模块（执行器）：负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；接收“调度中心”的执行请求、终止请求和日志请求等。''Xxl-job''的执行流程：''首先准备一个将要执行的任务，任务开启后到执行器中注册任务的信息，加载执行器的配置文件，初始化执行器的信息，然后执行器''start''。在''admin''端配置任务信息，配置执行器的信息。就可以控制任务的状态了。''xxl-job的''特性''为：''简单：支持通过web页面对任务进行CRUD操作，操作简单''动态：支持动态修改任务状态、暂停/恢复任务，以及终止运行中的任务，即时生效''调度中心HA（中心式）：调度采用中心式设计，“调度中心”基于集群Quartz实现并支持集群部署，可保证调度中心HA''执行器HA：任务分布式执行，任务执行器支持集群部署，可保证任务执行HA''注册中心：执行器会周期性自动注册任务并触发执行。同时，也支持手动录入执行器地址''弹性扩容缩容：一旦有新的执行器机器上线或下线，下次调度时会重新分配任务''路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、最不经常使用、故障转移等''故障转移：任务路由策略选择""故障转移""情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。''阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行、丢弃后续调度、覆盖之前调度''任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务；''任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；''失败处理策略；调度失败时的处理策略，默认提供失败告警、失败重试等策略；''分片广播任务：执行器集群部署时，任务路由策略选择""分片广播""情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；''动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。''事件触发：除了""Cron方式""和""任务依赖方式""触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。''任务进度监控：支持实时监控任务进度；''Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；''GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。''脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS等类型脚本;''任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行,\xa0多个子任务用逗号分隔；''一致性：“调度中心”通过DB锁保证集群分布式调度的一致性,\xa0一次任务调度只会触发一次执行；''自定义任务参数：支持在线配置调度任务入参，即时生效；''调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；''数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；''邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；''推送maven中央仓库:\xa0将会把最新稳定版推送到maven中央仓库,\xa0方便用户接入和使用;''运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；''全异步：系统底层实现全部异步化，针对密集调度进行流量削峰，理论上支持任意时长任务的运行；''国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文；''xxl-job-lite''的执行器实际是一个''ConcurrentHashMap''容器。''3、任务调度框架的技术选型？''1、Quartz：Java事实上的定时任务标准，但是关注点在于定时任务而非数据，虽然实现了高可用，但是缺少分布式并行调度的功能，性能低。''2、TBSchedule：阿里早期开源的分布式任务调度系统。代码略陈旧，使用的是Timer而不是线程池执行任务调度。TBSchedule的作业类型比较单一，只能是获取/处理数据一种模式，文档缺失比较严重。''3、详见分布式调度框架对比表格～''4、分布式任务调度框架的安装与使用？''4.1、Elastic-job''1、环境准备：''jdk1.7+、zookeeper3.4.6+、maven3.0.4+''2、安装zookeeper3.4.12并启动''这里zookeeper占用了2181端口。''3、创建简单任务''添加依赖：''写一个简单的任务：''在项目入口处添加作业的配置和zk的配置：''运行，得到结果：''4、下载Elastic-job-lite源码，使用maven进行打包。在elastic-job-lite/elastic-job-lite-console/target/elastic-job-lite-console-3.0.0.M1-SNAPSHOT/中，然后解压，会有start.bat和start.sh两个脚本，启动。''浏览器中输入localhost:8899，就可以管理任务了。''4.2、xxl-job-lite''1、调度数据库初始化，tables_xxl-job.sql''2、下载源码：包括调度中心+公共依赖+执行器示例''3、配置部署“调度中心”：修改数据库配置――将项目进行打包――将xxl-job-admin包部署到tomcat上''4、输入localhost:8080/xxl-job-admin即可访问调度中心''5、配置部署执行器：xxl-job-executor-sample-springboot打成jar包直接运行，其他的打成war包部署在tomcat上。''6、写一个任务，运行，去执行器上进行注册，然后调度中心配置执行器信息，添加任务''附录''1、etcd''etcd是一个开源的、分布式的键值对数据存储系统，提供共享配置、服务的注册和发现。etcd内部采用raft协议作为一致性算法，是基于Go语言实现的。''2、zookeeper''zookeeper是一个开源的分布式协调服务，它为分布式应用提供了高效且可靠的分布式协调服务，提供了诸如统一命名空间服务、配置服务和分布式锁等分布式基础服务。''3、分布式锁''假如我们由三台机器，每台机器上都有一个进程。假设我们在第一台机器上挂载了一个资源，三个进程都要来竞争这个资源。我们不希望这三个进程同时来访问，那么就需要有一个协调器，来让他们有序的对该资源进行访问。这个协调器就是我们所说的那个锁，比如说“进程1”在使用该资源的时候，就会先去获得锁，“进程1”就对该资源保持独占，这样其他的进程就无法访问该资源。“进程1”用完该资源后就会将锁释放掉，让其他的进程来获得锁。因此这个锁机制就能保证我们的进程有序的访问该资源。就称作为“分布式锁”，是分布式协调技术实现的核心内容''4、分片''任务的分布式执行，需要将一个任务拆分为多个独立的任务项，然后由分布式的服务器分别执行某一个或几个分片项。''5、单点故障''通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就瘫痪了，这就叫做单点故障。''传统的解决办法：''就是准备一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包后向备用节点发送回复Ack，当备用节点收到回复后就会认为主节点还活着，让他继续提供服务。''当主节点挂了，那么备用节点就收不到Ack回复了，然后备用节点就代替它成为了主节点。''但是存在一个安全隐患，那就是当发生网络故障时，备用节点收不到主节点的回复Ack，他会认为主节点死了，它会代替主节点成为新的主节点。''zookeeper''解决方案：''在引入了zookeeper后我们启用了两个主节点，A和B启动后他们都会去Zookeeper去注册一个节点，假设A注册的节点为master-01，B注册的节点为master-02，注册完之后进行选举，编号最小的节点将被选举为主节点。''如果A挂了，它在zookeeper注册的节点将会被自动删除，Zookeeper感知到节点的变化，然后再次发出选举，这时候B将获胜成为新的主节点。如果A恢复了，它会去zookeeper再注册一个节点，编号为master-03。这时zookeeper感知到节点的变化，会再次发起选举，此时还是B胜出。那么B继续担任主节点，A则成为备用节点。''6、Mesos''――像用一台电脑一样使用整个数据中心''是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，是以与Linux内核同样的原则而创建的，不同点仅仅是在于抽象的层面。使用ZooKeeper实现Master和Slave的容错。''7、FailStore策略''FailStrore，顾名思义就是Fail and Store，这个主要是用于失败了存储的，主要用于节点容错，当远程数据交互失败后，存储在本地，等待远程通讯恢复后，再将数据进行提交。'"
CSDN,https://blog.csdn.net/weixin_33404412/article/details/111964521,dqn 应用案例_强化学习(十二) Dueling DQN,Thomas Talhelm,dqn 应用案例,,2020-12-24 13:34:21,"'在强化学习(十一) Prioritized Replay DQN中，我们讨论了对DQN的经验回放池按权重采样来优化DQN算法的方法，本文讨论另一种优化方法，Dueling DQN。本章内容主要参考了ICML 2016的deep RL tutorial和Dueling DQN的论文(ICML 2016)。''1.\xa0Dueling DQN的优化点考虑''在前面讲到的DDQN中，我们通过优化目标Q值的计算来优化算法，在Prioritized Replay DQN中，我们通过优化经验回放池按权重采样来优化算法。而在Dueling DQN中，我们尝试通过优化神经网络的结构来优化算法。''具体如何优化网络结构呢？Dueling DQN考虑将Q网络分成两部分，第一部分是仅仅与状态$S$有关，与具体要采用的动作$A$无关，这部分我们叫做价值函数部分，记做$V(S,w,\\alpha)$,第二部分同时与状态状态$S$和动作$A$有关，这部分叫做优势函数(Advantage Function)部分,记为$A(S,A,w,\\beta)$,那么最终我们的价值函数可以重新表示为：$$Q(S,A, w, \\alpha, \\beta) = V(S,w,\\alpha) + A(S,A,w,\\beta)$$''其中，$w$是公共部分的网络参数，而$\\alpha$是价值函数独有部分的网络参数，而$\\beta$是优势函数独有部分的网络参数。''2.\xa0Dueling DQN网络结构''由于Q网络的价值函数被分为两部分，因此Dueling DQN的网络结构也和之前的DQN不同。为了简化算法描述，这里不使用原论文的CNN网络结构，而是使用前面文中用到的最简单的三层神经网络来描述。是否使用CNN对Dueling DQN算法本身无影响。''在前面讲到的DDQN等DQN算法中，我使用了一个简单的三层神经网络：一个输入层，一个隐藏层和一个输出层。如下左图所示：''而在Dueling DQN中，我们在后面加了两个子网络结构，分别对应上面上到价格函数网络部分和优势函数网络部分。对应上面右图所示。最终Q网络的输出由价格函数网络的输出和优势函数网络的输出线性组合得到。'""我们可以直接使用上一节的价值函数的组合公式得到我们的动作价值，但是这个式子无法辨识最终输出里面$V(S,w,\\alpha)$和$A(S,A,w,\\beta)$各自的作用，为了可以体现这种可辨识性(identifiability),实际使用的组合公式如下：$$Q(S,A, w, \\alpha, \\beta) = V(S,w,\\alpha) + (A(S,A,w,\\beta) - \\frac{1}{\\mathcal{A}}\\sum\\limits_{a' \\in \\mathcal{A}}A(S,a', w,\\beta))$$""'其实就是对优势函数部分做了中心化的处理。以上就是Duel DQN的主要算法思路。由于它仅仅涉及神经网络的中间结构的改进，现有的DQN算法可以在使用Duel DQN网络结构的基础上继续使用现有的算法。由于算法主流程和其他算法没有差异，这里就不单独讲Duel DQN的算法流程了。''3.\xa0Dueling DQN实例''下面我们用一个具体的例子来演示Dueling DQN的应用。仍然使用了OpenAI Gym中的CartPole-v0游戏来作为我们算法应用。CartPole-v0游戏的介绍参见这里。它比较简单，基本要求就是控制下面的cart移动使连接在上面的pole保持垂直不倒。这个任务只有两个离散动作，要么向左用力，要么向右用力。而state状态就是这个cart的位置和速度， pole的角度和角速度，4维的特征。坚持到200分的奖励则为过关。''这个实例代基于Nature DQN，并将网络结构改为上图中右边的Dueling DQN网络结构，完整的代码参见我的github:\xa0https://github.com/ljpzzz/machinelearning/blob/master/reinforcement-learning/duel_dqn.py''这里我们重点关注Dueling DQN和Nature DQN的代码的不同之处。也就是网络结构定义部分，主要的代码如下，一共有两个相同结构的Q网络，每个Q网络都有状态函数和优势函数的定义，以及组合后的Q网络输出，如代码红色部分：''defcreate_Q_network(self):#input layer''self.state_input = tf.placeholder(""float"", [None, self.state_dim])#network weights'""with tf.variable_scope('current_net'):""'W1= self.weight_variable([self.state_dim,20])''b1= self.bias_variable([20])#hidden layer 1''h_layer_1 = tf.nn.relu(tf.matmul(self.state_input,W1) +b1)#hidden layer for state value'""with tf.variable_scope('Value'):""'W21= self.weight_variable([20,1])''b21 = self.bias_variable([1])''self.V = tf.matmul(h_layer_1, W21) + b21#hidden layer for action value'""with tf.variable_scope('Advantage'):""'W22 = self.weight_variable([20,self.action_dim])''b22 = self.bias_variable([self.action_dim])''self.A = tf.matmul(h_layer_1, W22) + b22#Q Value layer''self.Q_value = self.V + (self.A - tf.reduce_mean(self.A, axis=1, keep_dims=True))'""with tf.variable_scope('target_net'):""'W1t= self.weight_variable([self.state_dim,20])''b1t= self.bias_variable([20])#hidden layer 1''h_layer_1t = tf.nn.relu(tf.matmul(self.state_input,W1t) +b1t)#hidden layer for state value'""with tf.variable_scope('Value'):""'W2v = self.weight_variable([20,1])''b2v = self.bias_variable([1])''self.VT = tf.matmul(h_layer_1t, W2v) + b2v#hidden layer for action value'""with tf.variable_scope('Advantage'):""'W2a = self.weight_variable([20,self.action_dim])''b2a = self.bias_variable([self.action_dim])''self.AT = tf.matmul(h_layer_1t, W2a) + b2a#Q Value layer''self.target_Q_value = self.VT + (self.AT - tf.reduce_mean(self.AT, axis=1, keep_dims=True))''其余部分代码和Nature DQN基本相同。当然，我们可以也在前面DDQN，Prioritized Replay DQN代码的基础上，把网络结构改成上面的定义，这样Dueling DQN也可以起作用。''4. DQN总结''DQN系列我花了5篇来讲解，一共5个前后有关联的算法：DQN(NIPS2013), Nature DQN, DDQN,\xa0Prioritized Replay DQN和Dueling DQN。目前使用的比较主流的是后面三种算法思路，这三种算法思路也是可以混着一起使用的，相互并不排斥。''当然DQN家族的算法远远不止这些，还有一些其他的DQN算法我没有详细介绍，比如使用一些较复杂的CNN和RNN网络来提高DQN的表达能力，又比如改进探索状态空间的方法等，主要是在DQN的基础上持续优化。''DQN算是深度强化学习的中的主流流派，代表了Value-Based这一大类深度强化学习算法。但是它也有自己的一些问题，就是绝大多数DQN只能处理离散的动作集合，不能处理连续的动作集合。虽然NAF DQN可以解决这个问题，但是方法过于复杂了。而深度强化学习的另一个主流流派Policy-Based而可以较好的解决这个问题，从下一篇我们开始讨论Policy-Based深度强化学习。''(欢迎转载，转载请注明出处。欢迎沟通交流： liujianping-ok@163.com)'"
CSDN,https://blog.csdn.net/qq_35010227/article/details/86102084,Java中this关键字详解,雪碧~,java基础,,2019-01-08 22:15:36,"'最近几天学习了一下Java的spring框架，课程中遇到了几个关于Java的基础知识拿捏不到位，经过查阅了各类Java资料，对几个问题有了大致的理解。干脆写下来和大家分享一下，希望对大家有所帮助。''this''this表示某个对象''this可以出现在实例方法和构造方法中，但是不可以出现在类方法中''this出现在类的构造方法中，就代表该构造方法所创建的对象''this出现在实例方法中，就代表正在调用该方法的当前对象''this不能出现在类方法中，是因为类方法可以通过类名直接调用。在这个时候，可能还没有任何对象诞生。''实例方法:''实例方法只能通过对象来调用，不能用类名来调用''当实例成员变量在实例方法中出现时，默认格式为 ：''this.成员变量''当static成员变量在实例方法中出现时，默认格式为：''类.成员变量''示例如下:''class''A''{''int x'';''static''int y'';''void''f''('')''{''this''.''x''=''100'';''A''.''y''=''200'';''}''}''当一个对象调用方法时，方法中的实例成员变量就是指分配给该对象的实例成员变量。而static变量与其他对象共享。所以通常情况可以省略实例成员变量名字前边的“this”，以及static变量前的“类名”。但是''当实例成员名字和局部变量名字相同时''，成员变量前的“this”以及“类名”就不可以省略。''class''A''{''private''String name'';''public''void''f''(''String name'')''{''this''.''name''=''name'';''//this不能省略''}''}''我们知道类的实例方法可以调用类的其他方法，对于实例方法调用的默认格式是：''this.方法''class''B''{''void''f''('')''{''this''.''g''('')'';''//this可省略''B''.''h''('')'';''//B(类名)可省略''}''void''g''('')''{''System''.''out''.''print''(''""Hello""'')'';''}''static''void''h''('')''{''System''.''out''.''print''(''""World！""'')'';''}''}''以上均为个人理解，有错误的地方还请各位指正，欢迎交流~'"
CSDN,https://blog.csdn.net/shuyv/article/details/108756117,JAVA    this关键字详解,凌薇20,JAVA,,2020-09-25 17:13:30,"'this关键字是Java面向对象中很常用的关键字，可用于任何实例方法内指向当前对象，页可以指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。''this.属性名''大部分时候，普通方法访问其他方法、成员变量时无需使用this关键字，但是如果方法里面有个局部变量和成员变量同名，但程序又需要在该方法里面访问这个被覆盖的成员变量，则必须使用this前缀。''代码演示''public''class''demo04This''{''private''String name'';''private''double''money'';''private''int''age'';''// 等号左边的 this.name 是指当前对象具有的变量 name，''// 等号右边的 name 表示参数传递过来的数值。''// 在构造方法中传递参数进行修改''public''demo04This''(''String name'',''double''money'',''int''age'')''{''this''.''name''=''name'';''this''.''money''=''money'';''this''.''age''=''age'';''}''public''static''void''main''(''String''['']''args'')''{''demo04This person''=''new''demo04This''(''""shuyv""'',''999'',''18'')'';''System''.''out''.''println''(''""-------------个人信息""'')'';''System''.''out''.''println''(''person''.''name''+''"" ""''+''person''.''money''+''"" ""''+''person''.''age'')'';''}''}''当一个类的属性（成员变量）和访问该属性的方法名相同时，则需要使用this关键字来访问类中的属性，以区分类的属性和方法中的参数。''this.方法名''this关键字最大的作用就是让类中的一个方法，访问该类的另一个方法或者实例变量。''先演示一段代码：''我们在一个类当中定义俩个实例方法''public''class''demo06Tiger''{''// 定义一个jump方法''public''void''jump''('')''{''System''.''out''.''println''(''""jump方法已执行""'')'';''}''// 在run方法内执行jump方法''public''void''run''('')''{''System''.''out''.''println''(''""run方法已经执行""'')'';''// 实例化tiger对象，通过该对象来访问jump方法''demo06Tiger tiger1''=''new''demo06Tiger''('')'';''tiger1''.''jump''('')'';''}''}''然后在另一个类中去调用run方法''public''class''demo07TigerTest''{''public''static''void''main''(''String''['']''args'')''{''demo06Tiger tiger2''=''new''demo06Tiger''('')'';''tiger2''.''run''('')'';''}''}''执行结果：''run方法已经执行''jump方法已经执行''注意事项：''在run方法中调用jump方法，必须要实例化一个对象来进行访问。因为没有使用static关键字修饰的成员变量和方法必须使用对象来调用。''存在的问题''：''然后我们分析上面程序，在该程序中一共''实例化了俩次''，产生了俩个对象，在run方法中调用jump方法，通过tiger1对象实现。在另一个类的main方法中通过tiger2对象实现调用run方法。''this关键字便可以解决该问题，因为当程序调用run方法时，在run方法内部一定会创建一个tiger1对象，所以我们利用之后的方法调用利用tiger1对象来实现就OK了，无需再实例化新的对象，''因为每一次实例化新的对象，就会占用内存。''提示：''this可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但是所代表的类型却是确定的，因为它只能代表当前类''。所以说，只有这个方法被调用的时候，this代表的对象才会被确定下来，谁在调用该方法，this就指向谁，就代表谁。''下面我们使用this关键字对上面run方法进行修改''代码演示：''public''void''run''('')''{''// 实例化tiger对象，通过该对象来访问jump方法''// demo06Tiger tiger1 = new demo06Tiger();''// tiger1.jump();''System''.''out''.''println''(''""run方法已经执行""'')'';''this''.''jump''('')'';''}''改过之后的区别就是在run方法中调用jump方法没有通过实例化来进行访问，而是使用this关键字。''注意区别''：之前我们通过tiger2对象调用run方法，在run方法内部又通过tiger1对象调用jump方法，就是说，一个对象的run方法依赖于另一个对象的jump方法，形象一点就是你想让老虎2又跑又跳，但前面的做法确是老虎2跑了，但跳的确是老虎1，你说傻B不傻B，是不是很不符合逻辑。''现在我们通过tiger2对象调用run方法，但是run方法内部使用this关键子，注意this关键字,上面我们已经说过，''this在方法中不一定可以代表具体的对象，但是一定可以代表具体的类，谁调用了this所在的方法，this就代表谁''，所以我们这边的老虎2执行了跑方法，this关键字在跑方法中，this就指向老虎2，那么现在很符合逻辑，老虎2既跑又跳。''总结：''在开发过程中，对象的一个方法依赖于另一个的情形很常见，比如，程序媛对象设计程序的方法就依赖于敲键盘方法，等等。但注意，这种依赖关系都只针对一个对象。因此Java允许对象的一个成员方法直接调用另一个成员方法，可以省略this关键字前缀。''就是说改成下面这样的形式也没毛病，效果一样。''public''void''run''('')''{''// 实例化tiger对象，通过该对象来访问jump方法''// demo06Tiger tiger1 = new demo06Tiger();''// tiger1.jump();''System''.''out''.''println''(''""run方法已经执行""'')'';''jump''('')'';''}''this( )访问构造方法''注意：''1.this()不可以在普通方法中使用，只能写在构造方法中。''2.在构造方法中使用时，必须是第一条语句。''代码演示：''public''class''Person''{''String name'';''// 名字属性''public''Person''(''String name'')''{''this''.''name''=''name'';''// 实例化属性''}''public''Person''('')''{''this''(''""James""'')'';''}''public''void''output''('')''{''System''.''out''.''println''(''""James\' name is ""''+''name'')'';''}''public''static''void''main''(''String''['']''args'')''{''Person James''=''new''Person''('')'';''James''.''output''('')'';''}''}'"
CSDN,https://blog.csdn.net/kuangay/article/details/81535701,Java this关键字详解,,java,,2018-08-09 14:10:46,"'创建对象的过程''创建对象的过程分为四步：''分配对象空间，并将对象的成员变量初始化为0或空''执行属性的显式初始化''执行构造方法''返回对象的地址给相关的变量''this的本质''this的本质就是“创建好的对象的地址”，由于在构造方法调用前，对象已经创建，因此，在构造方法中也可以使用this代表“当前对象”''注意：''this不能用于static方法中''调用构造器''public''class''TestThis {''int''a, b, c;\n\n    TestThis(''int''a,''int''b) {''this''.a = a;''this''.b = b;\n    }\n\n    TestThis(''int''a,''int''b,''int''c) {''this''(a,b);''//调用构造器，不能使用TestThis(a,b)，而且必须放在构造方法的第一行代码''this''.c = c;\n    }''void''sing() {\n    }''void''eat() {''this''.sing();''//调用本类中的sing();''System.''out''.println(''""你妈妈喊你回家吃饭咯！""'');\n    }''public''static''void''main''(String[] args) {\n        TestThis hi =''new''TestThis(''2'',''3'');\n        hi.eat();\n\n    }\n}''输出结果：''你妈妈喊你回家吃饭咯！''this关键字最常用的用法''java中，this关键字一般有以下三种用法：''this.属性''：代表本类属性''this调用本类方法''：代表调用本类方法''this''：代表当前对象''针对这三种用法，分别结合代码来进行说明''代表本类属性''先来一段没有使用this的代码：''public''class''ThisTest1 {''public''static''void''main''(String[] args) {\n        ThisDemo thisDemo =''new''ThisDemo(''""李四""'',''""杭州""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n}\n\nclass ThisDemo {''private''String name;''private''String address;''public''ThisDemo''(String n, String a) {\n        name = n;\n        address = a;\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n}''输出结果：''名字：李四, 地址：杭州''我们可以看下上面代码ThisDemo类的构造方法中两个形参n和a，这种参数命名没有意义，代码维护性比较差，这两个参数目的是为了给属性name和address初始化赋值用的，那么构造方法的这两个参数名称最好也是name和address''修改构造方法的形参名称，代码如下：''public''class''ThisTest1 {''public''static''void''main''(String[] args) {\n        ThisDemo thisDemo =''new''ThisDemo(''""李四""'',''""杭州""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n}\n\nclass ThisDemo {''private''String name;''private''String address;''public''ThisDemo''(String name, String address) {\n        name = name;\n        address = address;\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n}''输出结果为：''名字：''null'', 地址：''null''上面的代码构造方法形参命名虽然有意义了，但输出结果不是我们想要的，属性name和address没有初始化值了。这是因为在java程序之中是以一对大括号”{}”来作为分界，采用就近原则。此时，可以使用this关键字来表示属性为类属性。''public''ThisDemo''(String name, String address) {''this''.name = name;''this''.address = address;\n    }''开发建议：只要是调用本类中的属性，都使用“this.属性”的方式来进行''代表调用本类方法''类方法分为两种：''普通方法''：如果调用本类的普通方法，可以使用“this.方法()”调用''构造方法''：如果调用本类的构造方法，可以使用”this(参数…)”调用''调用类的普通方法''这个比较简单，直接上代码：''public''class''ThisTest2 {''public''static''void''main''(String[] args) {\n        ThisDemo2 thisDemo =''new''ThisDemo2(''""李四""'',''""杭州""'');\n        System.''out''.println(thisDemo.get2());\n    }\n}\n\nclass ThisDemo2 {''private''String name;''private''String address;''public''ThisDemo2''(String name, String address) {''this''.name = name;''this''.address = address;\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }''public''String''get2''() {''return''this''.''get''();\n    }\n\n}''输出结果为：''名字：李四, 地址：杭州''可以看到get2()方法中使用了''this.get()''调用本类的普通方法''调用类的构造方法''举例: 假如一个类中有三个构造方法(无参、一个参数、两个参数)，代码如下：''public''class''ThisTest3 {''public''static''void''main''(String[] args) {\n        ThisDemo3 thisDemo =''new''ThisDemo3(''""李四""'',''""杭州人间天堂""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n\n}\n\nclass ThisDemo3 {''private''String name;''private''String address;''public''ThisDemo3''() {\n\n        System.''out''.println(''""创建了一个新的ThisDemo3实例......""'');\n    }''public''ThisDemo3''(String name) {''this''.name = name;\n\n        System.''out''.println(''""创建了一个新的ThisDemo3实例......""'');\n    }''public''ThisDemo3''(String name, String address) {''this''.name = name;''this''.address = address;\n\n        System.''out''.println(''""创建了一个新的ThisDemo3实例......""'');\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n\n}''输出结果为：''创建了一个新的ThisDemo3实例''...''...''名字：李四, 地址：杭州人间天堂''可以看到上面的代码有大量重复情况，那么我们这时候就可以使用this调用构造方法来简化我们的代码，让代码看起来清爽简洁。''public''class''ThisTest4 {''public''static''void''main''(String[] args) {\n        ThisDemo4 thisDemo =''new''ThisDemo4(''""李四""'',''""杭州人间天堂""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n\n}\n\nclass ThisDemo4 {''private''String name;''private''String address;''public''ThisDemo4''() {\n\n        System.''out''.println(''""创建了一个新的ThisDemo4实例......""'');\n    }''public''ThisDemo4''(String name) {''this''();''this''.name = name;\n    }''public''ThisDemo4''(String name, String address) {''this''(name);''this''.address = address;\n\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n\n}''输出结果为：''创建了一个新的ThisDemo3实例''...''...''名字：李四, 地址：杭州人间天堂''上面就是使用this调用构造方法的优化后的代码，没有重复代码，看起来简洁多了。''这里要注意的是：所有的构造方法都是在对象实例化的时候被默认调用，且是在调用普通方法之前，所以在使用this()调用构造方法，一定要放在构造方法的第一行''public''ThisDemo4''(String name, String address) {''this''(name);''//放在第一行''this''.address = address;\n\n    }''代表当前对象''先了解下当前对象是代表啥意思？当前对象就是指当前正在调用类中方法的对象。''先看下代码：''public''class''ThisTest4 {''public''static''void''main''(String[] args) {\n        ThisDemo4 thisDemo =''new''ThisDemo4(''""李四""'',''""杭州人间天堂""'');\n        System.''out''.println(thisDemo);\n        System.''out''.println(thisDemo.''get''());\n    }\n\n}\n\nclass ThisDemo4 {''private''String name;''private''String address;''public''ThisDemo4''() {\n\n        System.''out''.println(''""创建了一个新的ThisDemo4实例......""'');\n    }''public''ThisDemo4''(String name) {''this''();''this''.name = name;\n    }''public''ThisDemo4''(String name, String address) {''this''(name);''this''.address = address;\n\n    }''public''String''get''() {\n\n        System.''out''.println(''""当前对象this：""''+''this'');''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n\n}''输出结果：''创建了一个新的ThisDemo4实例......''com''.trc''.java''.ThisDemo''4''@8''efb846\n当前对象this：''com''.trc''.java''.ThisDemo''4''@8''efb846\n名字：李四, 地址：杭州人间天堂''可以看到，this其实就是当前创建的对象'"
CSDN,https://blog.csdn.net/shuyv/article/details/108756117,JAVA    this关键字详解,凌薇20,JAVA,,2020-09-25 17:13:30,"'this关键字是Java面向对象中很常用的关键字，可用于任何实例方法内指向当前对象，页可以指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。''this.属性名''大部分时候，普通方法访问其他方法、成员变量时无需使用this关键字，但是如果方法里面有个局部变量和成员变量同名，但程序又需要在该方法里面访问这个被覆盖的成员变量，则必须使用this前缀。''代码演示''public''class''demo04This''{''private''String name'';''private''double''money'';''private''int''age'';''// 等号左边的 this.name 是指当前对象具有的变量 name，''// 等号右边的 name 表示参数传递过来的数值。''// 在构造方法中传递参数进行修改''public''demo04This''(''String name'',''double''money'',''int''age'')''{''this''.''name''=''name'';''this''.''money''=''money'';''this''.''age''=''age'';''}''public''static''void''main''(''String''['']''args'')''{''demo04This person''=''new''demo04This''(''""shuyv""'',''999'',''18'')'';''System''.''out''.''println''(''""-------------个人信息""'')'';''System''.''out''.''println''(''person''.''name''+''"" ""''+''person''.''money''+''"" ""''+''person''.''age'')'';''}''}''当一个类的属性（成员变量）和访问该属性的方法名相同时，则需要使用this关键字来访问类中的属性，以区分类的属性和方法中的参数。''this.方法名''this关键字最大的作用就是让类中的一个方法，访问该类的另一个方法或者实例变量。''先演示一段代码：''我们在一个类当中定义俩个实例方法''public''class''demo06Tiger''{''// 定义一个jump方法''public''void''jump''('')''{''System''.''out''.''println''(''""jump方法已执行""'')'';''}''// 在run方法内执行jump方法''public''void''run''('')''{''System''.''out''.''println''(''""run方法已经执行""'')'';''// 实例化tiger对象，通过该对象来访问jump方法''demo06Tiger tiger1''=''new''demo06Tiger''('')'';''tiger1''.''jump''('')'';''}''}''然后在另一个类中去调用run方法''public''class''demo07TigerTest''{''public''static''void''main''(''String''['']''args'')''{''demo06Tiger tiger2''=''new''demo06Tiger''('')'';''tiger2''.''run''('')'';''}''}''执行结果：''run方法已经执行''jump方法已经执行''注意事项：''在run方法中调用jump方法，必须要实例化一个对象来进行访问。因为没有使用static关键字修饰的成员变量和方法必须使用对象来调用。''存在的问题''：''然后我们分析上面程序，在该程序中一共''实例化了俩次''，产生了俩个对象，在run方法中调用jump方法，通过tiger1对象实现。在另一个类的main方法中通过tiger2对象实现调用run方法。''this关键字便可以解决该问题，因为当程序调用run方法时，在run方法内部一定会创建一个tiger1对象，所以我们利用之后的方法调用利用tiger1对象来实现就OK了，无需再实例化新的对象，''因为每一次实例化新的对象，就会占用内存。''提示：''this可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但是所代表的类型却是确定的，因为它只能代表当前类''。所以说，只有这个方法被调用的时候，this代表的对象才会被确定下来，谁在调用该方法，this就指向谁，就代表谁。''下面我们使用this关键字对上面run方法进行修改''代码演示：''public''void''run''('')''{''// 实例化tiger对象，通过该对象来访问jump方法''// demo06Tiger tiger1 = new demo06Tiger();''// tiger1.jump();''System''.''out''.''println''(''""run方法已经执行""'')'';''this''.''jump''('')'';''}''改过之后的区别就是在run方法中调用jump方法没有通过实例化来进行访问，而是使用this关键字。''注意区别''：之前我们通过tiger2对象调用run方法，在run方法内部又通过tiger1对象调用jump方法，就是说，一个对象的run方法依赖于另一个对象的jump方法，形象一点就是你想让老虎2又跑又跳，但前面的做法确是老虎2跑了，但跳的确是老虎1，你说傻B不傻B，是不是很不符合逻辑。''现在我们通过tiger2对象调用run方法，但是run方法内部使用this关键子，注意this关键字,上面我们已经说过，''this在方法中不一定可以代表具体的对象，但是一定可以代表具体的类，谁调用了this所在的方法，this就代表谁''，所以我们这边的老虎2执行了跑方法，this关键字在跑方法中，this就指向老虎2，那么现在很符合逻辑，老虎2既跑又跳。''总结：''在开发过程中，对象的一个方法依赖于另一个的情形很常见，比如，程序媛对象设计程序的方法就依赖于敲键盘方法，等等。但注意，这种依赖关系都只针对一个对象。因此Java允许对象的一个成员方法直接调用另一个成员方法，可以省略this关键字前缀。''就是说改成下面这样的形式也没毛病，效果一样。''public''void''run''('')''{''// 实例化tiger对象，通过该对象来访问jump方法''// demo06Tiger tiger1 = new demo06Tiger();''// tiger1.jump();''System''.''out''.''println''(''""run方法已经执行""'')'';''jump''('')'';''}''this( )访问构造方法''注意：''1.this()不可以在普通方法中使用，只能写在构造方法中。''2.在构造方法中使用时，必须是第一条语句。''代码演示：''public''class''Person''{''String name'';''// 名字属性''public''Person''(''String name'')''{''this''.''name''=''name'';''// 实例化属性''}''public''Person''('')''{''this''(''""James""'')'';''}''public''void''output''('')''{''System''.''out''.''println''(''""James\' name is ""''+''name'')'';''}''public''static''void''main''(''String''['']''args'')''{''Person James''=''new''Person''('')'';''James''.''output''('')'';''}''}'"
CSDN,https://blog.csdn.net/qq_32172681/article/details/100061068,循环神经网络LSTM论文解读,纸上得来终觉浅～,深度学习,,2019-08-25 14:19:24,'版权声明：本文为CSDN博主「了不起的赵队」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。''原文链接：https://blog.csdn.net/zhaojc1995/article/details/80572098''论文名称：Convolutional LSTM Network: A Machine Learning Approach for Precipitation Nowcasting''论文地址：''https://arxiv.org/pdf/1506.04214.pdf''1、LSTM简介''长短期记忆网络LSTM（long short-term memory）是RNN的一种变体。RNN由于梯度消失的原因只能有短期记忆，LSTM网络通过精妙的门控制将短期记忆与长期记忆结合起来，并且一定程度上解决了梯度消失的问题，可以学习长期依赖信息。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力。所有 RNN 都具有一种重复神经网络模块的链式的形式。''在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 tanh 层。''不同于单一神经网络层，LSTM整体上除了h在随时间流动，细胞状态c也在随时间流动，''细胞状态c就代表着长期记忆''。''LSTM 重复的模块结构如下：''2、LSTM核心思想''（1）细胞状态cell state的传播''LSTM 的关键就是细胞状态，类似于传送带。直接在整个链上运行，只有少量的线性交互，信息在上面流传保持不变很容易。''（2）”门“结构''LSTM 有通过精心设计的称作为“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个 sigmoid 神经网络层和一个 pointwise 乘法操作。Sigmoid 层输出 0 到 1 之间的数值，描述每个部分有多少量可以通过。0 代表“不许任何量通过”，1 就指“允许任意量通过”。''（3）遗忘门''遗忘门决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为遗忘门完成。该门会读取''和''，输出一个在 0 到 1 之间的数值给每个在细胞状态''中的数字。1 表示“完全保留”，0 表示“完全舍弃”。''如何做到遗忘呢？''“遗忘“可以理解为“之前的内容记住多少“，其精髓在于只能输出（0，1）小数的sigmoid函数和粉色圆圈的乘法，LSTM网络经过学习决定让网络记住以前百分之多少的内容。''既然是遗忘旧的内容，为什么这个门还要接收新的''?''决定记住什么遗忘什么，其中新的输入肯定要产生影响。''（4）记忆门''记忆门决定什么样的新信息被存放在细胞状态中。''共包含两个部分：sigmoid 层决定网络要记住的信息、\xa0tanh 层就是一个普通的RNN传播。''（5）更新门''更新门用来更新旧细胞状态，将''更新为''。''前面忘记门已经决定了将会忘记什么，记忆门决定将会记住什么，更新门就是执行这一步骤。''（6）输出门''输出门决定这一时间步骤网络输出什么，这个输出将会基于当前的细胞状态。''分为两部分：sigmoid 层来确定细胞状态的哪个部分将输出，把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值），并将它和 sigmoid 门的输出相乘，最终仅仅会输出我们确定输出的那部分。''这几个门虽然功能上不同，但在执行任务的操作上是相同的。他们都是使用sigmoid函数作为选择工具，tanh函数作为变换工具，这两个函数结合起来实现三个门的功能。''3、LSTM变体''（1）让门层也会接受细胞状态的输入''（2）另一个变体是通过使用 coupled 忘记和输入门。不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。''（3）另一个改动较大的变体是 Gated Recurrent Unit (GRU)，将忘记门和记忆门合成了一个单一的更新门。''4、自己的思考（欢迎指正）''（1）lstm中的记忆细胞c和隐藏状态h分别表示什么？''c保存的是长期记忆，h保存的是短期记忆。lstm中的h相当于普通rnn中的h，c是lstm和rnn的最大区别，c控制长期记忆。''（2）为什么h不能保存长期记忆，而记忆细胞c可以？''h跟rnn中的一样，好长时间之前的记忆由于梯度消失无法保存，所以只能保存短期记忆。''而c通过三个门控制哪些需要忘记、哪些需要记住，直接在主干上传播，所以很好更新，不容易梯度消失，所以可以保存长期记忆。''（3）神经网络怎么就知道，忘记门控制忘记，记住门控制记住，不都是权重和输入作用的结果么？''两个sigmoid的作用是不同的，忘记门的sigmoid决定旧的记忆C（t-1）哪些需要继续传播，哪些需要忘记，记住门的sigmoid决定当前新的记忆（也就是候选记忆细胞）哪些需要继续传播，哪些需要忘记。''ft是通过第1个sigmoid计算出C_t-1中需要保存的概率，C_t-1*ft就是需要记住的旧的记忆。it表示的通过第2个sigmoid计算出当前层中需要保存的概率，C~_t是当前的记忆，由x_t和h_t-1计算得出。最后的输出是将之前网络需要保存的加上当前网络需要保存的，也就是更新门的工作，更新记忆细胞C_t-1为C_t。如下图：'
CSDN,https://blog.csdn.net/Dear_Mr/article/details/72871919,Vue项目webpack打包部署到服务器,Dear_Mr,Vue.js,,2017-06-05 22:01:35,"'Vue项目webpack打包部署到服务器''这篇博文主要说的就是我今天遇到的问题，而且在经过我的询问，好多人在打包部署的时候都遇到了一些问题，下面就来说下，如何将Vue项目放置在服务器上，这里以Tomcat为例。''必须要配置的就是/config/index.js''在vue-cli webpack的模板下的''/config/index.js''，我们可以看到''assetsPublicPath''这个键，并且这个东西还出现了''两次''，我第一次打包的时候，只是修改了最下面的''assetsPublicPath''，将它从'""'/'""'变为了''./''，然后我就执行了''npm run build''，打包成功之后，可以看到项目中会多出来一个文件夹，就是''dist''，里面有一个''static''文件夹和''index.html''，然后我就将''dist''目录下的文件拷贝到Tomcat服务器下，会发现访问到的是一个空白页面，但是当我把它放在''..\\webapps\\ROOT''目录下，它就可以访问了''Tomcat下面的目录结构：''但是这肯定是不行的，然后我就开始寻找答案，也根据别人的一些步骤做了下来，后来发现还是有一些问题的，没有办法访问到主页面，虽然吧，一直都没成功，但是我也没放弃，然后就综合了一下问答里面别人说的，进行了几次尝试，最后成功了。（给大家一个小建议：别放弃就好）。''下面的就是我的''config/index.js''的配置：''// see http://vuejs-templates.github.io/webpack for documentation.''var''path =''require''('""'path'""')\n\nmodule.exports = {\n  build: {\n    env:''require''('""'./prod.env'""'),\n    index: path.resolve(__dirname,'""'../dist/index.html'""'),\n    assetsRoot: path.resolve(__dirname,'""'../dist'""'),\n    assetsSubDirectory:'""'static'""',\n    assetsPublicPath:'""'./'""',\n    productionSourceMap:''true'',''// Gzip off by default as many popular static hosts such as''// Surge or Netlify already gzip all static assets for you.''// Before setting to `true`, make sure to:''// npm install --save-dev compression-webpack-plugin''productionGzip:''false'',\n    productionGzipExtensions: ['""'js'""','""'css'""'],''// Run the build command with an extra argument to''// View the bundle analyzer report after build finishes:''// `npm run build --report`''// Set to `true` or `false` to always turn it on or off''bundleAnalyzerReport: process.env.npm_config_report\n  },\n  dev: {\n    env:''require''('""'./dev.env'""'),\n    port:''8080'',\n    autoOpenBrowser:''true'',\n    assetsSubDirectory:'""'static'""',\n    assetsPublicPath:'""'./'""',\n    proxyTable: {},''// CSS Sourcemaps off by default because relative paths are ""buggy""''// with this option, according to the CSS-Loader README''// (https://github.com/webpack/css-loader#sourcemaps)''// In our experience, they generally work as expected,''// just be aware of this issue when enabling this option.''cssSourceMap:''false''}\n}''可以发现，我就改了两处，就是assetsPublicPath所对应的值，我这里用的是''./''，我也用webapps下的命的项目名试过，只是没得到我想要的结果，后来我还是改成了''./''使用vue-router的情况''当你在项目中使用''vue-router''的时候，就需要给''src/router/index.js''添点东西，如下面：''export''default''new''Router({\n  mode :'""'history'""',\n  base:'""'/ttms/'""',''//添加的地方''...\n }''然后执行''npm run dev''，将打包后的文件放在Tomcat的目录下的WebApps下的ttms中，然后，就可以访问到了：''http://localhost:8080/ttms/'"
CSDN,https://blog.csdn.net/kuangay/article/details/81535701,Java this关键字详解,,java,,2018-08-09 14:10:46,"'创建对象的过程''创建对象的过程分为四步：''分配对象空间，并将对象的成员变量初始化为0或空''执行属性的显式初始化''执行构造方法''返回对象的地址给相关的变量''this的本质''this的本质就是“创建好的对象的地址”，由于在构造方法调用前，对象已经创建，因此，在构造方法中也可以使用this代表“当前对象”''注意：''this不能用于static方法中''调用构造器''public''class''TestThis {''int''a, b, c;\n\n    TestThis(''int''a,''int''b) {''this''.a = a;''this''.b = b;\n    }\n\n    TestThis(''int''a,''int''b,''int''c) {''this''(a,b);''//调用构造器，不能使用TestThis(a,b)，而且必须放在构造方法的第一行代码''this''.c = c;\n    }''void''sing() {\n    }''void''eat() {''this''.sing();''//调用本类中的sing();''System.''out''.println(''""你妈妈喊你回家吃饭咯！""'');\n    }''public''static''void''main''(String[] args) {\n        TestThis hi =''new''TestThis(''2'',''3'');\n        hi.eat();\n\n    }\n}''输出结果：''你妈妈喊你回家吃饭咯！''this关键字最常用的用法''java中，this关键字一般有以下三种用法：''this.属性''：代表本类属性''this调用本类方法''：代表调用本类方法''this''：代表当前对象''针对这三种用法，分别结合代码来进行说明''代表本类属性''先来一段没有使用this的代码：''public''class''ThisTest1 {''public''static''void''main''(String[] args) {\n        ThisDemo thisDemo =''new''ThisDemo(''""李四""'',''""杭州""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n}\n\nclass ThisDemo {''private''String name;''private''String address;''public''ThisDemo''(String n, String a) {\n        name = n;\n        address = a;\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n}''输出结果：''名字：李四, 地址：杭州''我们可以看下上面代码ThisDemo类的构造方法中两个形参n和a，这种参数命名没有意义，代码维护性比较差，这两个参数目的是为了给属性name和address初始化赋值用的，那么构造方法的这两个参数名称最好也是name和address''修改构造方法的形参名称，代码如下：''public''class''ThisTest1 {''public''static''void''main''(String[] args) {\n        ThisDemo thisDemo =''new''ThisDemo(''""李四""'',''""杭州""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n}\n\nclass ThisDemo {''private''String name;''private''String address;''public''ThisDemo''(String name, String address) {\n        name = name;\n        address = address;\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n}''输出结果为：''名字：''null'', 地址：''null''上面的代码构造方法形参命名虽然有意义了，但输出结果不是我们想要的，属性name和address没有初始化值了。这是因为在java程序之中是以一对大括号”{}”来作为分界，采用就近原则。此时，可以使用this关键字来表示属性为类属性。''public''ThisDemo''(String name, String address) {''this''.name = name;''this''.address = address;\n    }''开发建议：只要是调用本类中的属性，都使用“this.属性”的方式来进行''代表调用本类方法''类方法分为两种：''普通方法''：如果调用本类的普通方法，可以使用“this.方法()”调用''构造方法''：如果调用本类的构造方法，可以使用”this(参数…)”调用''调用类的普通方法''这个比较简单，直接上代码：''public''class''ThisTest2 {''public''static''void''main''(String[] args) {\n        ThisDemo2 thisDemo =''new''ThisDemo2(''""李四""'',''""杭州""'');\n        System.''out''.println(thisDemo.get2());\n    }\n}\n\nclass ThisDemo2 {''private''String name;''private''String address;''public''ThisDemo2''(String name, String address) {''this''.name = name;''this''.address = address;\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }''public''String''get2''() {''return''this''.''get''();\n    }\n\n}''输出结果为：''名字：李四, 地址：杭州''可以看到get2()方法中使用了''this.get()''调用本类的普通方法''调用类的构造方法''举例: 假如一个类中有三个构造方法(无参、一个参数、两个参数)，代码如下：''public''class''ThisTest3 {''public''static''void''main''(String[] args) {\n        ThisDemo3 thisDemo =''new''ThisDemo3(''""李四""'',''""杭州人间天堂""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n\n}\n\nclass ThisDemo3 {''private''String name;''private''String address;''public''ThisDemo3''() {\n\n        System.''out''.println(''""创建了一个新的ThisDemo3实例......""'');\n    }''public''ThisDemo3''(String name) {''this''.name = name;\n\n        System.''out''.println(''""创建了一个新的ThisDemo3实例......""'');\n    }''public''ThisDemo3''(String name, String address) {''this''.name = name;''this''.address = address;\n\n        System.''out''.println(''""创建了一个新的ThisDemo3实例......""'');\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n\n}''输出结果为：''创建了一个新的ThisDemo3实例''...''...''名字：李四, 地址：杭州人间天堂''可以看到上面的代码有大量重复情况，那么我们这时候就可以使用this调用构造方法来简化我们的代码，让代码看起来清爽简洁。''public''class''ThisTest4 {''public''static''void''main''(String[] args) {\n        ThisDemo4 thisDemo =''new''ThisDemo4(''""李四""'',''""杭州人间天堂""'');\n        System.''out''.println(thisDemo.''get''());\n    }\n\n}\n\nclass ThisDemo4 {''private''String name;''private''String address;''public''ThisDemo4''() {\n\n        System.''out''.println(''""创建了一个新的ThisDemo4实例......""'');\n    }''public''ThisDemo4''(String name) {''this''();''this''.name = name;\n    }''public''ThisDemo4''(String name, String address) {''this''(name);''this''.address = address;\n\n    }''public''String''get''() {''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n\n}''输出结果为：''创建了一个新的ThisDemo3实例''...''...''名字：李四, 地址：杭州人间天堂''上面就是使用this调用构造方法的优化后的代码，没有重复代码，看起来简洁多了。''这里要注意的是：所有的构造方法都是在对象实例化的时候被默认调用，且是在调用普通方法之前，所以在使用this()调用构造方法，一定要放在构造方法的第一行''public''ThisDemo4''(String name, String address) {''this''(name);''//放在第一行''this''.address = address;\n\n    }''代表当前对象''先了解下当前对象是代表啥意思？当前对象就是指当前正在调用类中方法的对象。''先看下代码：''public''class''ThisTest4 {''public''static''void''main''(String[] args) {\n        ThisDemo4 thisDemo =''new''ThisDemo4(''""李四""'',''""杭州人间天堂""'');\n        System.''out''.println(thisDemo);\n        System.''out''.println(thisDemo.''get''());\n    }\n\n}\n\nclass ThisDemo4 {''private''String name;''private''String address;''public''ThisDemo4''() {\n\n        System.''out''.println(''""创建了一个新的ThisDemo4实例......""'');\n    }''public''ThisDemo4''(String name) {''this''();''this''.name = name;\n    }''public''ThisDemo4''(String name, String address) {''this''(name);''this''.address = address;\n\n    }''public''String''get''() {\n\n        System.''out''.println(''""当前对象this：""''+''this'');''return''""名字：""''+ name +''"", 地址：""''+ address;\n    }\n\n}''输出结果：''创建了一个新的ThisDemo4实例......''com''.trc''.java''.ThisDemo''4''@8''efb846\n当前对象this：''com''.trc''.java''.ThisDemo''4''@8''efb846\n名字：李四, 地址：杭州人间天堂''可以看到，this其实就是当前创建的对象'"
CSDN,https://blog.csdn.net/atongmu09/article/details/86214188,tomcat部署vue项目,__NEW-OBJECT,vue,,2019-01-10 09:39:27,"'1.找到config>index.js 修改assetsPublicPath。''2.tomcat目录中的conf>server.xml 添加新端口''<Service name=""Catalina2"">\n    <Connector port=""8088"" protocol=""HTTP/1.1""\n               connectionTimeout=""20000""\n               redirectPort=""8445"" />\n    <Connector port=""8010"" protocol=""AJP/1.3"" redirectPort=""8445"" />\n    <Engine name=""Catalina2"" defaultHost=""localhost"">\n      <Realm className=""org.apache.catalina.realm.LockOutRealm""> \n        <Realm className=""org.apache.catalina.realm.UserDatabaseRealm""\n               resourceName=""UserDatabase""/>\n      </Realm>\n\t  <Host name=""localhost"" appBase=""webstatics"" unpackWARs=""true"" autoDeploy=""true"" xmlValidation=""false"" xmlNamespaceAware=""false"">  \n\t\t<Context path="""" docBase=""demename"" debug=""0"" reloadable=""true"" crossContext=""true""/>\n      </Host>\n    </Engine>\n  </Service>''3.tomcat根目录新建目录webstatics,把vue项目扔到里面。''4.启动tomca，访问设置的端口8088。'"
CSDN,https://blog.csdn.net/u014008159/article/details/93673853,深度强化学习――Dueling-DDQN（转）,吃住都在网吧,deep learning,,2019-06-25 23:56:54,'https://blog.csdn.net/u013236946/article/details/73161586'
CSDN,https://blog.csdn.net/atongmu09/article/details/86214188,tomcat部署vue项目,__NEW-OBJECT,vue,,2019-01-10 09:39:27,"'1.找到config>index.js 修改assetsPublicPath。''2.tomcat目录中的conf>server.xml 添加新端口''<Service name=""Catalina2"">\n    <Connector port=""8088"" protocol=""HTTP/1.1""\n               connectionTimeout=""20000""\n               redirectPort=""8445"" />\n    <Connector port=""8010"" protocol=""AJP/1.3"" redirectPort=""8445"" />\n    <Engine name=""Catalina2"" defaultHost=""localhost"">\n      <Realm className=""org.apache.catalina.realm.LockOutRealm""> \n        <Realm className=""org.apache.catalina.realm.UserDatabaseRealm""\n               resourceName=""UserDatabase""/>\n      </Realm>\n\t  <Host name=""localhost"" appBase=""webstatics"" unpackWARs=""true"" autoDeploy=""true"" xmlValidation=""false"" xmlNamespaceAware=""false"">  \n\t\t<Context path="""" docBase=""demename"" debug=""0"" reloadable=""true"" crossContext=""true""/>\n      </Host>\n    </Engine>\n  </Service>''3.tomcat根目录新建目录webstatics,把vue项目扔到里面。''4.启动tomca，访问设置的端口8088。'"
CSDN,https://blog.csdn.net/u014008159/article/details/93673853,深度强化学习――Dueling-DDQN（转）,吃住都在网吧,deep learning,,2019-06-25 23:56:54,'https://blog.csdn.net/u013236946/article/details/73161586'
CSDN,https://blog.csdn.net/qq_32172681/article/details/100061068,循环神经网络LSTM论文解读,纸上得来终觉浅～,深度学习,,2019-08-25 14:19:24,'版权声明：本文为CSDN博主「了不起的赵队」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。''原文链接：https://blog.csdn.net/zhaojc1995/article/details/80572098''论文名称：Convolutional LSTM Network: A Machine Learning Approach for Precipitation Nowcasting''论文地址：''https://arxiv.org/pdf/1506.04214.pdf''1、LSTM简介''长短期记忆网络LSTM（long short-term memory）是RNN的一种变体。RNN由于梯度消失的原因只能有短期记忆，LSTM网络通过精妙的门控制将短期记忆与长期记忆结合起来，并且一定程度上解决了梯度消失的问题，可以学习长期依赖信息。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力。所有 RNN 都具有一种重复神经网络模块的链式的形式。''在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 tanh 层。''不同于单一神经网络层，LSTM整体上除了h在随时间流动，细胞状态c也在随时间流动，''细胞状态c就代表着长期记忆''。''LSTM 重复的模块结构如下：''2、LSTM核心思想''（1）细胞状态cell state的传播''LSTM 的关键就是细胞状态，类似于传送带。直接在整个链上运行，只有少量的线性交互，信息在上面流传保持不变很容易。''（2）”门“结构''LSTM 有通过精心设计的称作为“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个 sigmoid 神经网络层和一个 pointwise 乘法操作。Sigmoid 层输出 0 到 1 之间的数值，描述每个部分有多少量可以通过。0 代表“不许任何量通过”，1 就指“允许任意量通过”。''（3）遗忘门''遗忘门决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为遗忘门完成。该门会读取''和''，输出一个在 0 到 1 之间的数值给每个在细胞状态''中的数字。1 表示“完全保留”，0 表示“完全舍弃”。''如何做到遗忘呢？''“遗忘“可以理解为“之前的内容记住多少“，其精髓在于只能输出（0，1）小数的sigmoid函数和粉色圆圈的乘法，LSTM网络经过学习决定让网络记住以前百分之多少的内容。''既然是遗忘旧的内容，为什么这个门还要接收新的''?''决定记住什么遗忘什么，其中新的输入肯定要产生影响。''（4）记忆门''记忆门决定什么样的新信息被存放在细胞状态中。''共包含两个部分：sigmoid 层决定网络要记住的信息、\xa0tanh 层就是一个普通的RNN传播。''（5）更新门''更新门用来更新旧细胞状态，将''更新为''。''前面忘记门已经决定了将会忘记什么，记忆门决定将会记住什么，更新门就是执行这一步骤。''（6）输出门''输出门决定这一时间步骤网络输出什么，这个输出将会基于当前的细胞状态。''分为两部分：sigmoid 层来确定细胞状态的哪个部分将输出，把细胞状态通过 tanh 进行处理（得到一个在 -1 到 1 之间的值），并将它和 sigmoid 门的输出相乘，最终仅仅会输出我们确定输出的那部分。''这几个门虽然功能上不同，但在执行任务的操作上是相同的。他们都是使用sigmoid函数作为选择工具，tanh函数作为变换工具，这两个函数结合起来实现三个门的功能。''3、LSTM变体''（1）让门层也会接受细胞状态的输入''（2）另一个变体是通过使用 coupled 忘记和输入门。不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。''（3）另一个改动较大的变体是 Gated Recurrent Unit (GRU)，将忘记门和记忆门合成了一个单一的更新门。''4、自己的思考（欢迎指正）''（1）lstm中的记忆细胞c和隐藏状态h分别表示什么？''c保存的是长期记忆，h保存的是短期记忆。lstm中的h相当于普通rnn中的h，c是lstm和rnn的最大区别，c控制长期记忆。''（2）为什么h不能保存长期记忆，而记忆细胞c可以？''h跟rnn中的一样，好长时间之前的记忆由于梯度消失无法保存，所以只能保存短期记忆。''而c通过三个门控制哪些需要忘记、哪些需要记住，直接在主干上传播，所以很好更新，不容易梯度消失，所以可以保存长期记忆。''（3）神经网络怎么就知道，忘记门控制忘记，记住门控制记住，不都是权重和输入作用的结果么？''两个sigmoid的作用是不同的，忘记门的sigmoid决定旧的记忆C（t-1）哪些需要继续传播，哪些需要忘记，记住门的sigmoid决定当前新的记忆（也就是候选记忆细胞）哪些需要继续传播，哪些需要忘记。''ft是通过第1个sigmoid计算出C_t-1中需要保存的概率，C_t-1*ft就是需要记住的旧的记忆。it表示的通过第2个sigmoid计算出当前层中需要保存的概率，C~_t是当前的记忆，由x_t和h_t-1计算得出。最后的输出是将之前网络需要保存的加上当前网络需要保存的，也就是更新门的工作，更新记忆细胞C_t-1为C_t。如下图：'
CSDN,https://blog.csdn.net/HouChan2017/article/details/55805448,Android之利用AccessibilityService实现微信提别提示,HoHoHoliday,android,,2018-07-01 17:51:22,"'相信很多人有这样的苦恼，在日常学习、工作、运动时不太喜欢被打扰，就喜欢将手机设置为静音或取消掉各种社交工具的提示，比如微信，偶尔会有些求转发、集赞、群@等并不需要立即回复的消息干扰，但是有时候却会错过一些重要消息。QQ倒是有特别提示，只不过我们的国民级应用微信就没有设计这个功能了。''最近刚接触到Google提供的无障碍辅助服务AccessibilityService，这是一个系统级的服务，运行在后台，并且能够收到由系统发出的一些事件，比如焦点改变，输入内容变化，按钮被点击等等，该种服务能够请求获取当前活动窗口并查找其中的内容。最典型的运用想必也是微信自动抢红包工具了，当然，根据它的特点，做一款微信特别提示工具也是轻而易举的。''首先讲讲实现原理，当接收到微信消息时，我们可以在通知栏看见发送者备注，然后我们可以在AccessibilityService的事件回调方法onAccessibilityEvent里进行switch匹配，如果event.getEventType()值为AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED，说明通知栏状态改变，这时我们只要提取消息文本进行过滤，如果含有特别提示好友的备注名，则发出特别提示。''下面请看app部分截图：''1.app主界面：可以添加需要特别提示好友的备注，当然也可以取消（没完善UI，丑请见谅）。''2.运行过app设置完特别提示好友后找到“手机设置”下的“辅助功能”或“无障碍”（不同机型不同，下图为模拟器界面），在此页面可以看到多了一个“微信特别提示”，打开后将其设置为开启，本app没有申请网络、SD卡读写等敏感权限，可以放心使用。（不过，app的安装包经过第三方加固处理，在安装时可能会提醒使用了某些权限，如不放心可以自行设置拒绝这些权限而不影响使用，另外，“锁屏显示”和“后台弹出界面”这两项权限不得关闭）。''开启后就能正常使用了，当然，经过短暂的测试周期，还存在以下问题（以MIUI8.1，android6.0为例）：1.手动清空所有运行进程，服务将被立即关闭。2.手动移除此app进程，服务在一段时间后也会自动关闭。3.当手机电量过低，运行内存过高服务也会被关闭。4.在锁屏状态下接收第一条消息时是不会有特别提示的，第二条消息开始就能正常提示，这估计是锁屏下状态栏更新机制的问题吧，当然不同手机会有不同的效果。''如果有更好的实现方式可以一起交流。''实现过程：''1.创建服务类继承AccessibilityService并重写相关方法。''private MediaPlayer player;// 播放器对象，用于播放提示音\n\tprivate ArrayList<String> names;// 用户所设置的特别提示好友备注，从本地读取\n\tprivate ChSharedPreferencesUtils csp;// 本地数据读取工具类\n\n\t/**\n\t * 事件回调方法\n\t */\n\t@Override\n\tpublic void onAccessibilityEvent(AccessibilityEvent event) {\n\t\tswitch (event.getEventType()) {// 进行事件匹配，功能待扩充\n\t\tcase AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:\n\t\t\thandleNotification(event);// 监听到通知栏改变，执行相关操作\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * 在手机设置里找到“辅助服务”或“无障碍”开启后调用此方法初始化数据\n\t */\n\t@Override\n\tprotected void onServiceConnected() {\n\t\tplayer = MediaPlayer.create(this, R.raw.facebook_tip);// 初始化播放器对象用于播放提示音\n\t\tcsp = new ChSharedPreferencesUtils(this, ""config"");// 使用自制工具类读取本地数据（用户所设置的特别提示好友）\n\t\tnames = csp.getObject(""names"", null);// 初始化数据源\n\t\t// 参数配置\n\t\tAccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n\t\tserviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;// 全局事件响应\n\t\tserviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;// 通用的反馈\n\t\tserviceInfo.packageNames = new String[] { ""com.tencent.mm"" };//微信包名\n\t\tserviceInfo.notificationTimeout = 100;\n\t\tsetServiceInfo(serviceInfo);\n\t}\n\n\t/**\n\t * 自制通知栏文本过滤方法\n\t * \n\t * @param event\n\t */\n\tprivate void handleNotification(AccessibilityEvent event) {\n\t\tList<CharSequence> texts = event.getText();\n\t\tif (!texts.isEmpty()) {\n\t\t\tfor (CharSequence text : texts) {\n\t\t\t\tString content = text.toString();\n\t\t\t\tif (names != null) {\n\t\t\t\t\tfor (int i = 0, n = names.size(); i < n; i++) {// 每条消息都要遍历所有特别提示好友\n\t\t\t\t\t\t// 放前面，后面有break\n\t\t\t\t\t\tif (content.contains(names.get(i))) {// 文本匹配到特别提示好友则发出提示音\n\t\t\t\t\t\t\tif (!player.isPlaying()) {\n\t\t\t\t\t\t\t\tplayer.start();\n\t\t\t\t\t\t\t\tbreak;// 提示完跳出循环即可\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 在正常关闭这个服务时会被调用。在这个方法中进行一些释放资源的工作。\n\t */\n\t@Override\n\tpublic boolean onUnbind(Intent intent) {\n\t\treturn super.onUnbind(intent);\n\t}''2.在清单布局文件里配置服务类：''<service\n            android:name="".服务类类名""\n            android:enabled=""true""\n            android:exported=""true""\n            android:permission=""android.permission.BIND_ACCESSIBILITY_SERVICE"" >\n            <intent-filter>\n                <action android:name=""android.accessibilityservice.AccessibilityService"" />\n            </intent-filter>\n\n            <meta-data\n                android:name=""android.accessibilityservice""\n                android:resource=""@xml/accessibility"" />\n        </service>''其中accessibility.xml的相关配置：''<?xml version=""1.0"" encoding=""utf-8""?>\n<accessibility-service xmlns:android=""http://schemas.android.com/apk/res/android""\n    android:accessibilityEventTypes=""typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged""\n    android:accessibilityFeedbackType=""feedbackGeneric""\n    android:accessibilityFlags=""flagDefault""\n    android:canRetrieveWindowContent=""true""\n    android:notificationTimeout=""100""\n    android:packageNames=""com.tencent.mm"" />''由于app只是雏形阶段，测试时间也较短，所以就不放在服务器上了，有需要（想做小白鼠）的朋友可以私我。当然想要对其他app设置特别提醒功能也大同小异，只要收到消息时能触发状态栏更新即可，剩下的就是改包名的事了。''参考博客：''点击打开''，另外再推荐一篇博客：''Android service 不被杀死“永不退出的服务”（双进程，服务，多进程，微信）'"
CSDN,https://blog.csdn.net/qq_38499859/article/details/90523283,Android之辅助服务上篇――――AccessibilityService使用,冰炭不投day,Android 应用层,,2019-06-26 19:36:41,"'Android之辅助服务上篇――――AccessibilityService使用''文章目录''Android之辅助服务上篇――――AccessibilityService使用''一.前言''二.概述''1.辅助服务是什么''2.辅助服务生命周期''三.配置''1.继承AccessbilityService类''2.在AndroidManifest中注册该服务''3.配置AccessbilityService''四.使用''1.启动服务''2.获取事件信息''3.处理事件--寻找控件''4.处理事件--操作控件''五.综合应用''1.获得View对应的id''2.AccessibilityService的手势控制''3.AccessibilityService的基础类''4.实际应用''六.参考资料''一.前言''最近好久没写博客了，特别是Android系统启动这一个系列，虽然过程已经理了很多遍了，但是由于实习期间是在抽不出时间，没办法输出文章。最近接触了Android辅助服务，即AccessibilityService的相关内容，也算是解决了我一直一来的困惑――微信抢红包插件是怎么实现的。这两天，抽空总结一下这一部分相关的内容，上篇介绍使用，下篇分析原理。''二.概述''1.辅助服务是什么''下面两个链接是Google官方对于辅助服务的介绍：''辅助服务使用官方介绍''辅助服务类官方api文档''辅助服务的设计初衷提供给无法和界面进行交互的残疾用户。来协助帮助他们进行一些用户操作，比如点击，返回，长按，获取屏幕信息等能力。后来被开发者另辟蹊径，用于一些插件开发，做一些监听第三方应用的插件。''下面是辅助服务的继承关系：''2.辅助服务生命周期''辅助服务的生命周期由系统专门管理，并遵循Server的生命周期。服务的启动只能用户在设备设置中明确启动服务来触发。当系统绑定到服务后，它会调用AccessibilityService#onServiceConnected()方法。当用户在设置设置中关闭时，辅助服务功能将停止，或者调用AccessibilityService#disableSelf()方法。giant服务会被关闭销毁''设备设置无障碍选择：''下面是关于AccessibilityService的使用''三.配置''1.继承AccessbilityService类''要使用辅助服务，首先先继承AccessbilityService类，并且重写其方法。''public''class''StatusAccessibilityService''extends''AccessibilityService''{''/**\n     * 发生用户界面事件回调此事件\n     * @param event\n     */''@Override''public''void''onAccessibilityEvent''(''AccessibilityEvent event'')''{''}''/**\n     * 中断可访问性反馈\n     */''@Override''public''void''onInterrupt''('')''{''}''}''除了上面的两个必须要重写的方法外，AccessbilityService还提供了下面的一些方法：''disableSelf()，禁用当前服务，也就是说关闭当服务''dispatchGesture(GestureDescription gesture, AccessibilityService.GestureResultCallback callback, Handler handler)，将手势发送到触摸屏''findFocus(int focus)：寻找到具有指定焦点类型的视图。''getRootInActiveWindow()：获取当前活动窗口中的根节点。''getServiceInfo()：获取当前服务的配置信息''getSystemService(String name)：获取系统服务''getWindows():获取屏幕上的窗口。''performGlobalAction(int action)：执行全局操作：比如返回，回到主页，打开最近等操作''setServiceInfo(AccessibilityServiceInfo info):设置当前服务的配置信息 (下面的配置AccessbilityService会介绍)''不太常用的：''getAccessibilityButtonController()：返回系统导航区域内辅助功能按钮的控制器。''getFingerprintGestureController()：获取指纹手势的控制器。''getMagnificationController():返回放大器控制器，可用于查询和修改显示放大率的状态。''getSoftKeyboardController():返回软键盘控制器，可用于查询和修改软键盘显示模式。''2.在AndroidManifest中注册该服务''AccessbilityService是一个服务，所以同样，他也要在AndroidManifest中注册：''<''service\n            android'':''name''=''""com.hahak.walle.accessibilitydame.StatusAccessibilityService""''android'':''label''=''""辅助服务测试""''android'':''permission''=''""android.permission.BIND_ACCESSIBILITY_SERVICE""''>''<''intent''-''filter''>''<''action android'':''name''=''""android.accessibilityservice.AccessibilityService""''/''>''<''/''intent''-''filter''>''<''/''service''>''android:permission：需要指定BIND_ACCESSIBILITY_SERVICE权限，这是4.0以上的系统要求的''intent-filter：这个name是固定不变的''3.配置AccessbilityService''接下来，就是配置服务参数，即设定AccessbilityService所能干的事。''配置方法有两种，一种是在代码中动态设置，一种是写配置文件。''方法1.写配置文件''首先在AndroidManifest中生命配置文件的位置''<''service''android:''name''=''""''com.hahack.walle.AutoCheckStatusAccessibilityService''""''android:''label''=''""''运营助手：自动艾特用户''""''android:''permission''=''""''android.permission.BIND_ACCESSIBILITY_SERVICE''""''>''<''intent-filter''>''<''action''android:''name''=''""''android.accessibilityservice.AccessibilityService''""''/>''</''intent-filter''>''<''meta-data''android:''name''=''""''android.accessibilityservice''""''android:''resource''=''""''@xml/allocation''""''/>''</''service''>''其次，在@xml/allocation文件中，声明下面的内容''<''accessibility-service''xmlns:''android''=''""''http://schemas.android.com/apk/res/android''""''android:''accessibilityEventTypes''=''""''typeAllMask''""''android:''description''=''""''demo''""''android:''accessibilityFeedbackType''=''""''feedbackSpoken''""''android:''canRetrieveWindowContent''=''""''true''""''android:''notificationTimeout''=''""''1000''""''/>''方法2:.在代码中动态添加''在自定义的AccessibilityService类中，可以通过在AccessibilityServiceInfo类重写onServiceConnected()，并通过 this.setServiceInfo来添加配置''@Override''public''void''onServiceConnected''('')''{''info''.''eventTypes''=''AccessibilityEvent''.''TYPE_VIEW_CLICKED''|''AccessibilityEvent''.''TYPE_VIEW_FOCUSED'';''info''.''packageNames''=''new''String''['']''{''""com.example.android.myFirstApp""'',''""com.example.android.mySecondApp""''}'';''info''.''feedbackType''=''AccessibilityServiceInfo''.''FEEDBACK_SPOKEN\n\n    info''.''notificationTimeout''=''100'';''this''.''setServiceInfo''(''info'')'';''}''下面说说配置内容的具体含义：''accessibilityEventTypes：此服务希望按照指定接收的事件类型(AccessibilityEvent)''常量''描述''typeViewClicked''点击事件''typeViewSelected''view被选择''typeViewScrolled''滑动事件''typeWindowContentChanged''窗口内容该表''typeAllMask''所有事件''accessibilityFeedbackType：此服务提供的反馈类型，比如说是语音播报还是真的震动''常量''描述''feedbackSpoken''语音反馈''feedbackHaptic''触觉（震动）反馈''feedbackAudible''音频反馈''feedbackVisual''视频反馈''feedbackGeneric''通用反馈''feedbackAllMask''以上都具有''canRetrieveWindowContent：表示该服务能否访问活动窗口中的内容。也就是如果你希望在服务中获取窗体内容，则需要设置其值为true''description：对该无障碍功能的描述。''notificationTimeout：接受事件的时间间隔，通常将其设置为100即可''packageNames：表示对该服务是用来监听哪个包的产生的事件，上面以微信的包名为例''canPerformGestures:表示是否允许进行手势分发''canRequestFilterKeyEvents：辅助服务希望能够请求过滤关键事件。''nonInteractiveUiTimeout：超时设置，未不包含交互式空间返回合适的值''四.使用''1.启动服务''辅助服务的启动必须通过用户设置来开启，所以我们要先提醒用户进行无障碍功能列表''Intent intent''=''new''Intent''(''Settings''.''ACTION_ACCESSIBILITY_SETTINGS'')'';''startActivity''(''intent'')'';''通过上面的代码就可以打开系统的无障碍功能列表''2.获取事件信息''当我们监听的目标应用界面或者界面等信息，会通过onAccessibilityEvent回调我们的事件，接着进行事件的处理。''@Override''public''void''onAccessibilityEvent''(''final''AccessibilityEvent event'')''{''String packageName''=''event''.''getPackageName''('')''.''toString''('')'';''if''(''!''packageName''.''equals''(''""com.tencent.mm""'')'')''{''return'';''}''int''eventType''=''event''.''getEventType''('')'';''switch''(''eventType'')''{''case''AccessibilityEvent''.''TYPE_WINDOW_STATE_CHANGED'':''处理''.''.''.''.''}''可以看出，当发生变化时，回调onAccessibilityEvent方法，并传入AccessibilityEvent类型。下面让我们看看AccessibilityEvent的含义。''先看看AccessibilityEvent提供的方法(源是指触发此方法的ui/时间)：''getAction()：获取触发此世界的已执行操作''getEventTime()：获取发送此事件的时间''getEventType()：获取事件类型。''getPackageName()：获取源的包名称''从AccessibilityRecord基础的方法''getMaxScrollY()：获取源上边缘的最大滚动偏移（以像素为单位）''getMaxScrollX()：获取源左边缘的最大滚动偏移量（以像素为单位）。''getClassName()：获取源的类名。''getText()：获取事件的文本，比如事件是有TextView发出的,此时获取的就是TextView的text属性。如果该事件源是树结构，那么此时获取的是这个树上所有具有text属性的值的集合''getToIndex()： 获取滚动时文本选择结束的索引或最后一个可见项的索引。''getItemCount()：如果事件源是树结构，将返回该树根节点下子节点的数量''更详细的可以参考官方文档：''AccessibilityEvent官方api介绍''关于事件类型getEventType()返回值：''TYPE_VIEW_LONG_CLICKED 长按事件''TYPE_VIEW_CONTEXT_CLICKED点击事件''TYPE_WINDOW_STATE_CHANGED 表示用户界面被更改。''TYPE_NOTIFICATION_STATE_CHANGED：通知栏的改变''TYPE_WINDOWS_CHANGED：表示系统窗口的时间变更''…还有很多，详情可以看看官方文档''3.处理事件C寻找控件''当我们接受到事件后，根据事件就可以处理对应的时间，比如说检测到弹窗，就可以转换为动作：点击弹窗。''处理事件总的来说，分为两个步骤。第一步，寻找该控件。第二部，模拟人的操作对各个控件进行操作(点击，长按，输入，读取)''寻找控件''寻找控件首先要找的它对象窗口内容对应的树，即AccessibilityWindowInfo(代表)和AccessibilityNodeInfo(代表具体的View)。注意，这个功能需要在xml资源配置中声明SERVICE_META_DATA。''针对寻找AccessibilityWindowInfo和AccessibilityNodeInfo，谷歌官方提供了下面的api''AccessibilityEvent#getSource(),返回值为发起当前事件的控件的AccessibilityNodeInfo''AccessibilityService#findFocus(int)，参数表示输入焦点，返回值为指定焦点对应的AccessibilityNodeInfo''AccessibilityService#getWindows()，返回值为当前所有可交互窗户的 AccessibilityWindowInfo列表（List）''AccessibilityService#getRootInActiveWindow()，返回值为当前活动的AccessibilityWindowInfo，如果用户没有触摸任何窗口，则活动窗口是具有输入焦点的窗口。''AccessibilityWindowInfo''：''AccessibilityWindowInfo表示可访问窗口的状态快照。屏幕内容包含一个或者多个窗口，其中一些窗口可以是其他窗口的后代，窗口是次序排序的。''AccessibilityWindowInfor提供的api简介：''getChild(int index) ，返回给定索引处的子窗口的AccessibilityWindowInfo''getChildCount()，返回代表子窗口的数量的int值''getId(),返回代表唯一的窗口id的int值''getParent()，返回代表父窗口的AccessibilityWindowInfo''getLayer()，返回代表窗口在z轴的图层的int值''getRoot()''，返回代表窗口层次中根节点的AccessibilityNodeInfo''…其余详见官网文档''AccessibilityNodeInfo''：''AccessibilityNodeInfo表示窗口内容的节点以及可以进行的操作。''AccessibilityNodeInfo内部类介绍：''AccessibilityAction，表示可以对AccessibilityNodeInfo提供的操作''CollectionInfo，表示当节点是集合时，包含集合信息的类。''CollectionItemInfo，表示当节点是集合子项，包含集合子项信息的类。''RangeInfo，表示当节点是范围，包含该范围包含信息的类。''AccessibilityNodeInfo提供的api简述''addAction(action: AccessibilityNodeInfo.AccessibilityAction)/(action: Int)，添加可在节点上执行的操作,有两个同名方法，参数不同''performAction(action: Int)，在节点上执行操作''addChild(child: View!)添加一个子项''findAccessibilityNodeInfosByText(text: String!)，按文字寻找对应的控件，并返回其 AccessibilityNodeInfo''findAccessibilityNodeInfosByViewId(viewId: String!)，根据View的id资源名称查找对应的View，返回AccessibilityNodeInfo''findFocus(focus: Int)，找到具有指定焦点类型的视图。返回AccessibilityNodeInfo''focusSearch(direction: Int)，搜索指定方向上可以获取输入焦点的最近视图。返回AccessibilityNodeInfo''getActionList()，获取可以在节点上执行的操作。''getHintText()，获取此节点的提示文本''getText()，获取此节点的文本''isClickable()，获取此节点是否可单击，还有其他对于的方法，判断节点是否可操作''…其余详见官网文档''4.处理事件C操作控件''在上面一小节里，我们通过addAction，可以给AccessibilityNodeInfo添加对于的动作，其参数是 AccessibilityNodeInfo的内部类AccessibilityAction。''AccessibilityAction''AccessibilityAction表示可以对AccessibilityNodeInfo。每个操作都有一个唯一的ID，这是必需的和可选的数据。''其有三类动作''标准操作 - 这些操作由平台中的标准UI小部件报告和处理。对于每个标准动作，在该类中定义了一个静态常量，例如ACTION_FOCUS。这些操作将有null标签。''自定义操作操作 - 这些是由自定义窗口小部件报告和处理的操作。即不属于UI工具包的那些。例如，应用程序可以定义用于清除用户历史的自定义操作。''覆盖标准操作 - 这些操作会覆盖标准操作以自定义它们。例如，应用可以向标准ACTION_CLICK操作添加标签，以向用户指示此操作清除浏览历史记录。''可提供的操作''ACTION_ACCESSIBILITY_FOCUS，为可访问性提供焦点的操作。''ACTION_CLEAR_ACCESSIBILITY_FOCUS，清除节点可访问性焦点的操作。''ACTION_CLICK，单击节点信息的操作。''ACTION_LONG_CLICK,长按''ACTION_FOCUS，为输入焦点提供节点''ACTION_COPY，将当前选择复制到剪贴板的操作。''ACTION_CUT，剪切''ACTION_PAGE_DOWN，移动到下一页，以及移动到下，左，右页面''ACTION_PASTE，粘贴剪切板内容''ACTION_SCROLL_BACKWARD/ACTION_SCROLL_FORWARD ,下滑/上滑''ACTION_SET_TEXT，设置节点文本''…其余详见官网文档''五.综合应用''1.获得View对应的id''打开toolsC>AndroidC>Android Device Monitor''选择设备，并点击图中坐标''选择对应的控件进行点击查看''2.AccessibilityService的手势控制''在Android7.0之后，AccessibilityService又增加了一个新的方法dispatchGesture。可以将手势发送到触摸屏上。但是要使用这个功能必须在配置文件中声明，canPerformGestures = “true”''api接口:''public''final''boolean''dispatchGesture''(''GestureDescription gesture'',''AccessibilityService''.''GestureResultCallback callback'',''Handler handler'')''参数:''GestureDescription：要分派的手势''AccessibilityService.GestureResultCallback:完成后的回调''Handler；处理回调程序的线程，如果传入null,则为主线程''使用示例''Path path''=''new''Path''('')'';''path''.''moveTo''(''0'',''400'')'';''path''.''lineTo''(''400'',''400'')'';''final''GestureDescription''.''StrokeDescription sd'';''sd''=''new''GestureDescription''.''StrokeDescription''(''path'',''100'',''50'')'';''//先横滑''boolean''flag''=''this''.''dispatchGesture''(''new''GestureDescription''.''Builder''('')''.''addStroke''(''sd'')''.''build''('')'',''new''AccessibilityService''.''GestureResultCallback''('')''{''@Override''public''void''onCompleted''(''GestureDescription gestureDescription'')''{''super''.''onCompleted''(''gestureDescription'')'';''Log''.''d''(''""22222""'',''""onCompleted:横滑 ""'')'';''Path path2''=''new''Path''('')'';''path2''.''moveTo''(''600'',''600'')'';''path2''.''lineTo''(''600'',''800'')'';''final''GestureDescription''.''StrokeDescription sd2''=''new''GestureDescription''.''StrokeDescription''(''path2'',''1000'',''500'')'';''//滑完后再过1秒竖滑''BaseAccessibilityService''.''this''.''dispatchGesture''(''new''GestureDescription''.''Builder''('')''.''addStroke''(''sd2'')''/*.addStroke(sd2)*/''.''build''('')'',''null'',''null'')'';''}''@Override''public''void''onCancelled''(''GestureDescription gestureDescription'')''{''Log''.''d''(''""22222""'',''""onCancelled""'')'';''super''.''onCancelled''(''gestureDescription'')'';''}''}'',''null'')'';''上图的示例为左滑和下滑，如果要实现点击事件，则可以只传入一个点Path。即''Path path''=''new''Path''('')'';''path''.''moveTo''(''0'',''400'')'';''sd''=''new''GestureDescription''.''StrokeDescription''(''path'',''100'',''50'')'';''3.AccessibilityService的基础类''下面是对AccessibilityService提供的各种方法的封装''public''class''BaseAccessibilityService''extends''AccessibilityService''{''private''AccessibilityManager mAccessibilityManager'';''private''Context mContext'';''private''static''BaseAccessibilityService mInstance'';''public''void''init''(''Context context'')''{''mContext''=''context''.''getApplicationContext''('')'';''mAccessibilityManager''=''(''AccessibilityManager'')''mContext''.''getSystemService''(''Context''.''ACCESSIBILITY_SERVICE'')'';''}''public''static''BaseAccessibilityService''getInstance''('')''{''if''(''mInstance''==''null'')''{''mInstance''=''new''BaseAccessibilityService''('')'';''}''return''mInstance'';''}''/**\n     * Check当前辅助服务是否启用\n     *\n     * @param serviceName serviceName\n     * @return 是否启用\n     */''private''boolean''checkAccessibilityEnabled''(''String serviceName'')''{''List''<''AccessibilityServiceInfo''>''accessibilityServices''=''mAccessibilityManager''.''getEnabledAccessibilityServiceList''(''AccessibilityServiceInfo''.''FEEDBACK_GENERIC'')'';''for''(''AccessibilityServiceInfo info'':''accessibilityServices'')''{''if''(''info''.''getId''('')''.''equals''(''serviceName'')'')''{''return''true'';''}''}''return''false'';''}''/**\n     * 前往开启辅助服务界面\n     */''public''void''goAccess''('')''{''Intent intent''=''new''Intent''(''Settings''.''ACTION_ACCESSIBILITY_SETTINGS'')'';''intent''.''setFlags''(''Intent''.''FLAG_ACTIVITY_NEW_TASK'')'';''mContext''.''startActivity''(''intent'')'';''}''/**\n     * 模拟点击事件\n     *\n     * @param nodeInfo nodeInfo\n     */''public''void''performViewClick''(''AccessibilityNodeInfo nodeInfo'')''{''if''(''nodeInfo''==''null'')''{''return'';''}''while''(''nodeInfo''!=''null'')''{''if''(''nodeInfo''.''isClickable''('')'')''{''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_CLICK'')'';''break'';''}''nodeInfo''=''nodeInfo''.''getParent''('')'';''}''}''/**\n     * 模拟返回操作\n     */''public''void''performBackClick''('')''{''try''{''Thread''.''sleep''(''500'')'';''}''catch''(''InterruptedException''e'')''{''e''.''printStackTrace''('')'';''}''performGlobalAction''(''GLOBAL_ACTION_BACK'')'';''}''/**\n     * 模拟下滑操作\n     */''public''void''performScrollBackward''('')''{''try''{''Thread''.''sleep''(''500'')'';''}''catch''(''InterruptedException''e'')''{''e''.''printStackTrace''('')'';''}''performGlobalAction''(''AccessibilityNodeInfo''.''ACTION_SCROLL_BACKWARD'')'';''}''/**\n     * 模拟上滑操作\n     */''@RequiresApi''(''api''=''Build''.''VERSION_CODES''.''N'')''public''void''performScrollForward''('')''{''try''{''Thread''.''sleep''(''500'')'';''}''catch''(''InterruptedException''e'')''{''e''.''printStackTrace''('')'';''}''performGlobalAction''(''AccessibilityNodeInfo''.''ACTION_SCROLL_FORWARD'')'';''}''/**\n     * 查找对应文本的View\n     *\n     * @param text text\n     * @return View\n     */''public''AccessibilityNodeInfo''findViewByText''(''String text'')''{''return''findViewByText''(''text'',''false'')'';''}''/**\n     * 查找对应文本的View\n     *\n     * @param text      text\n     * @param clickable 该View是否可以点击\n     * @return View\n     */''public''AccessibilityNodeInfo''findViewByText''(''String text'',''boolean''clickable'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return''null'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByText''(''text'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''if''(''nodeInfo''!=''null''&&''(''nodeInfo''.''isClickable''('')''==''clickable'')'')''{''return''nodeInfo'';''}''}''}''return''null'';''}''/**\n     * 查找对应ID的View\n     *\n     * @param id id\n     * @return View\n     */''@TargetApi''(''Build''.''VERSION_CODES''.''JELLY_BEAN_MR2'')''public''AccessibilityNodeInfo''findViewByID''(''String id'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return''null'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByViewId''(''id'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''Log''.''d''(''""dd""'',''""findViewByID: ""''+''nodeInfoList''.''size''('')'')'';''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''Log''.''d''(''""dd""'',''""findViewByID: ""''+''nodeInfo''.''toString''('')'')'';''if''(''nodeInfo''!=''null'')''{''return''nodeInfo'';''}''}''}''return''null'';''}''public''void''clickTextViewByText''(''String text'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByText''(''text'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''if''(''nodeInfo''!=''null'')''{''performViewClick''(''nodeInfo'')'';''break'';''}''}''}''}''@TargetApi''(''Build''.''VERSION_CODES''.''JELLY_BEAN_MR2'')''public''void''clickTextViewByID''(''String id'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByViewId''(''id'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''if''(''nodeInfo''!=''null'')''{''performViewClick''(''nodeInfo'')'';''break'';''}''}''}''}''/**\n     * 模拟输入\n     *\n     * @param nodeInfo nodeInfo\n     * @param text     text\n     */''public''void''inputText''(''AccessibilityNodeInfo nodeInfo'',''String text'')''{''if''(''Build''.''VERSION''.''SDK_INT''>=''Build''.''VERSION_CODES''.''LOLLIPOP'')''{''Bundle arguments''=''new''Bundle''('')'';''arguments''.''putCharSequence''(''AccessibilityNodeInfo''.''ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE'',''text'')'';''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_SET_TEXT'',''arguments'')'';''}''else''if''(''Build''.''VERSION''.''SDK_INT''>=''Build''.''VERSION_CODES''.''JELLY_BEAN_MR2'')''{''ClipboardManager clipboard''=''(''ClipboardManager'')''getSystemService''(''Context''.''CLIPBOARD_SERVICE'')'';''ClipData clip''=''ClipData''.''newPlainText''(''""label""'',''text'')'';''clipboard''.''setPrimaryClip''(''clip'')'';''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_FOCUS'')'';''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_PASTE'')'';''}''}''@Override''public''void''onAccessibilityEvent''(''AccessibilityEvent event'')''{''Log''.''d''(''""dd""'',''""onAccessibilityEvent: ""''+''event''.''toString''('')'')'';''}''@Override''public''void''onInterrupt''('')''{''}''@Override''protected''void''onServiceConnected''('')''{''super''.''onServiceConnected''('')'';''Log''.''d''(''""llll""'',''""onServiceConnected: ""'')'';''}''}''4.实际应用''学习了大部分的AccessibilityService相关知识。就可以灵活运用这些内容进行组装。''比如说：''微信红包外挂''支付宝自动收能量''微信自动发消息''朋友圈自动点赞''…''六.参考资料''官方api文档''官网辅助服务介绍''妙用AccessibilityService黑科技实现微信自动加好友拉人进群聊'"
CSDN,https://blog.csdn.net/dichi4045/article/details/102444406,mysql  / pgsql  使用sql语句查询数据库所有表注释已经表字段注释,dichi4045,数据库,,2018-10-30 18:10:00,"'场景：''1. 要查询数据库 ""mammothcode"" 下所有表名以及表注释'""/* 查询数据库 ‘mammothcode’ 所有表注释 */\nSELECT TABLE_NAME,TABLE_COMMENT FROM information_schema.TABLES WHERE table_schema='mammothcode';""'2. 要查询表字段的注释'""/* 查询数据库 ‘mammothcode’ 下表 ‘t_adminuser’ 所有字段注释 */\nSELECT COLUMN_NAME,column_comment FROM INFORMATION_SCHEMA.Columns WHERE table_name='t_adminuser' AND table_schema='mammothcode'""'3. 一次性查询数据库\xa0""mammothcode"" 下表注释以及对应表字段注释'""SELECT t.TABLE_NAME,t.TABLE_COMMENT,c.COLUMN_NAME,c.COLUMN_TYPE,c.COLUMN_COMMENT FROM information_schema.TABLES t,INFORMATION_SCHEMA.Columns c WHERE c.TABLE_NAME=t.TABLE_NAME AND t.`TABLE_SCHEMA`='mammothcode'""'扩展：使用存储过程，对上面sql语句进行存储，sql如下：'""DELIMITER//  \nDROP PROCEDURE IF EXISTS findComment//\nCREATE PROCEDURE findComment (dbName VARCHAR(50))\nBEGIN  \n   DECLARE stmt VARCHAR(65535);  \n   #如果用户名长度大于0\n   IF LENGTH(dbName)>0 THEN\n     BEGIN\n       SET @sqlstr=CONCAT('SELECT t.TABLE_NAME,t.TABLE_COMMENT,c.COLUMN_NAME,c.COLUMN_TYPE,c.COLUMN_COMMENT FROM information_schema.TABLES t,INFORMATION_SCHEMA.Columns c WHERE c.TABLE_NAME=t.TABLE_NAME AND t.`TABLE_SCHEMA`=','''',dbName,'''');\n      END;\n   ELSE\n     BEGIN\n      SET @sqlstr=CONCAT('SELECT ','''','数据库名不能为空','''', 'AS ','''','提示','''');\n     END;\n     END IF;\n   PREPARE stmt FROM @sqlstr;\n   EXECUTE stmt;\nEND//\nDELIMITER ;""'调用存储过程：'""CALL findComment('xiyinli_test');""'上面的存储过程还可以简化：在存储过程中直接查询当前使用的数据库，如下：'""DELIMITER//  \nDROP PROCEDURE IF EXISTS findComment//\nCREATE PROCEDURE findComment ()\nBEGIN  \n   DECLARE stmt VARCHAR(65535);  \n   #查询当前的 use-->database\n   SET @dbName=(SELECT DATABASE());\n     BEGIN\n       SET @sqlstr=CONCAT('SELECT t.TABLE_NAME,t.TABLE_COMMENT,c.COLUMN_NAME,c.COLUMN_TYPE,c.COLUMN_COMMENT FROM information_schema.TABLES t,INFORMATION_SCHEMA.Columns c WHERE c.TABLE_NAME=t.TABLE_NAME AND t.`TABLE_SCHEMA`=','''',@dbName,'''');\n      END;\n   PREPARE stmt FROM @sqlstr;\n   EXECUTE stmt;\nEND//\nDELIMITER ;""'调用：''CALL findComment();''转载自：''http://blog.csdn.net/cicon/article/details/51577655''获取表名及注释：'""select relname as tabname,cast(obj_description(relfilenode,'pg_class') as varchar) as comment from pg_class c""""where \xa0relkind = 'r' and relname not like 'pg_%' and relname not like 'sql_%' order by relname""'过滤掉分表：''加条件 and relchecks=0 即可''获取字段名、类型、注释、是否为空:''SELECT col_description(a.attrelid,a.attnum) as comment,format_type(a.atttypid,a.atttypmod) as type,a.attname as name, a.attnotnull as notnull'""FROM pg_class as c,pg_attribute as a where c.relname = '表名' and a.attrelid = c.oid and a.attnum>0""'转载于:https://www.cnblogs.com/zengpeng/p/9878546.html'"
CSDN,https://blog.csdn.net/liuhongkai111/article/details/81381471,莫烦pytorch学习笔记（十三）――LSTM循环神经网络,小汤河河神,pytorch,,2018-08-03 09:50:42,"'高级神经网络――LSTM循环神经网络''RNN的弊端''之前我们说过,''RNN''是在有顺序的数据上进行学习的. 为了记住这些数据, RNN 会像人一样产生对先前发生事件的记忆. 不过一般形式的 RNN 就像一个老爷爷, 有时候比较健忘. 为什么会这样呢?''想像现在有这样一个 RNN, 他的输入值是一句话: ‘我今天要做红烧排骨, 首先要准备排骨, 然后…., 最后美味的一道菜就出锅了’, shua ~ 说着说着就流口水了. 现在请 RNN 来分析, 我今天做的到底是什么菜呢. RNN可能会给出“辣子鸡”这个答案. 由于判断失误, RNN就要开始学习 这个长序列 X 和 ‘红烧排骨’ 的关系 , 而RNN需要的关键信息 ”红烧排骨”却出现在句子开头。''来看看 RNN是怎样学习的吧. 红烧排骨这个信息原的记忆要进过长途跋涉才能抵达最后一个时间点. 然后我们得到误差, 而且在 反向传递 得到的误差的时候, 他在每一步都会 乘以一个自己的参数 W. 如果这个 W 是一个小于1 的数, 比如0.9. 这个0.9 不断乘以误差, 误差传到初始时间点也会是一个接近于零的数, 所以对于初始时刻, 误差相当于就消失了. 我们把这个问题叫做梯度消失或者梯度弥散 Gradient vanishing. 反之如果 W 是一个大于1 的数, 比如1.1 不断累乘, 则到最后变成了无穷大的数, RNN被这无穷大的数撑死了, 这种情况我们叫做剃度爆炸, Gradient exploding. 这就是普通 RNN 没有办法回忆起久远记忆的原因.''LSTM''LSTM 就是为了解决这个问题而诞生的. LSTM 和普通 RNN 相比, 多出了三个控制器. (输入控制, 输出控制, 忘记控制). 现在, LSTM RNN 内部的情况是这样.''他多了一个 控制全局的记忆, 我们用粗线代替. 为了方便理解, 我们把粗线想象成电影或游戏当中的 主线剧情. 而原本的 RNN 体系就是 分线剧情. 三个控制器都是在原始的 RNN 体系上, 我们先看 输入方面 , 如果此时的分线剧情对于剧终结果十分重要, 输入控制就会将这个分线剧情按重要程度 写入主线剧情 进行分析. 再看 忘记方面, 如果此时的分线剧情更改了我们对之前剧情的想法, 那么忘记控制就会将之前的某些主线剧情忘记, 按比例替换成现在的新剧情. 所以 主线剧情的更新就取决于输入 和忘记 控制. 最后的输出方面, 输出控制会基于目前的主线剧情和分线剧情判断要输出的到底是什么.基于这些控制机制, LSTM 就像延缓记忆衰退的良药, 可以带来更好的结果.'"
CSDN,https://blog.csdn.net/wzp6010625/article/details/104545421,Vue项目打包部署到Tomcat,wzp6010625,,,2020-02-27 22:45:28,"'一、''使用 npm run build打包完成之后会出现一个dist文件夹，里面有static文件夹和一个index.html文件，一般我们部署在tomcat上面会将文件放在webapps文件夹下''如果不进行任何修改将dist文件夹放进去的话，会出现资源路径错误的问题，因为config文件夹下index文件build默认的 assetsPublicPath:""/""，除非部署的时候将dist文件里的文件放在webapps下，这样就很不科学，那我们如何解决这个问题呢''修改config文件夹下index文件中的build里的assetsPublicPath:""./""''修改router文件夹下index.js添加 base: ‘/文件夹名称/’\xa0\xa0 \xa0（例如：vue，可以自己随意设置）''在tomcat下webapps里面新建一个文件夹，名称是之前配置时设置的名称（vue）''npm run build打包后将dist文件夹下的文件放在""vue""文件夹下''访问地址为''http://xxxxxxxxx/vue/''二、''如果出现css等文件404的问题，细心观察你会发现是资源路径错误，那要如何解决呢？''修改build下的utils.js文件'""// Extract CSS when that option is specified\n // (which is the case during production build)\n if (options.extract) {\n   return ExtractTextPlugin.extract({\n      use: loaders,\n      publicPath: '../../',             //添加该行（解释：pubicpath为打包后app.css至index.html的相对路径）\n      fallback: 'vue-style-loader'\n   })\n } else {\n    return ['vue-style-loader'].concat(loaders)\n }""'三、''如果你的项目路由使用的模式是history模式，那么你一定会遇到上线后页面刷新出现404的问题''查阅文档后发现如果使用history模式需要后端人员给予支持，直接在tomcat下webapps下你的项目文件夹中新建一个WEB-INF文件夹，里面创建一个web.xml文件，文件内容为''<?xml version=""1.0"" encoding=""UTF-8""?>\n<web-app xmlns=""http://xmlns.jcp.org/xml/ns/javaee"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""\n  xsi:schemaLocation=""http://xmlns.jcp.org/xml/ns/javaee\n           http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd""\n  version=""3.1"" metadata-complete=""true"">\n  <display-name>Router for Tomcat</display-name>\n  <error-page>\n    <error-code>404</error-code>\n    <location>/index.html</location>\n  </error-page>\n</web-app>'"
CSDN,https://blog.csdn.net/qq_38499859/article/details/90523283,Android之辅助服务上篇――――AccessibilityService使用,冰炭不投day,Android 应用层,,2019-06-26 19:36:41,"'Android之辅助服务上篇――――AccessibilityService使用''文章目录''Android之辅助服务上篇――――AccessibilityService使用''一.前言''二.概述''1.辅助服务是什么''2.辅助服务生命周期''三.配置''1.继承AccessbilityService类''2.在AndroidManifest中注册该服务''3.配置AccessbilityService''四.使用''1.启动服务''2.获取事件信息''3.处理事件--寻找控件''4.处理事件--操作控件''五.综合应用''1.获得View对应的id''2.AccessibilityService的手势控制''3.AccessibilityService的基础类''4.实际应用''六.参考资料''一.前言''最近好久没写博客了，特别是Android系统启动这一个系列，虽然过程已经理了很多遍了，但是由于实习期间是在抽不出时间，没办法输出文章。最近接触了Android辅助服务，即AccessibilityService的相关内容，也算是解决了我一直一来的困惑――微信抢红包插件是怎么实现的。这两天，抽空总结一下这一部分相关的内容，上篇介绍使用，下篇分析原理。''二.概述''1.辅助服务是什么''下面两个链接是Google官方对于辅助服务的介绍：''辅助服务使用官方介绍''辅助服务类官方api文档''辅助服务的设计初衷提供给无法和界面进行交互的残疾用户。来协助帮助他们进行一些用户操作，比如点击，返回，长按，获取屏幕信息等能力。后来被开发者另辟蹊径，用于一些插件开发，做一些监听第三方应用的插件。''下面是辅助服务的继承关系：''2.辅助服务生命周期''辅助服务的生命周期由系统专门管理，并遵循Server的生命周期。服务的启动只能用户在设备设置中明确启动服务来触发。当系统绑定到服务后，它会调用AccessibilityService#onServiceConnected()方法。当用户在设置设置中关闭时，辅助服务功能将停止，或者调用AccessibilityService#disableSelf()方法。giant服务会被关闭销毁''设备设置无障碍选择：''下面是关于AccessibilityService的使用''三.配置''1.继承AccessbilityService类''要使用辅助服务，首先先继承AccessbilityService类，并且重写其方法。''public''class''StatusAccessibilityService''extends''AccessibilityService''{''/**\n     * 发生用户界面事件回调此事件\n     * @param event\n     */''@Override''public''void''onAccessibilityEvent''(''AccessibilityEvent event'')''{''}''/**\n     * 中断可访问性反馈\n     */''@Override''public''void''onInterrupt''('')''{''}''}''除了上面的两个必须要重写的方法外，AccessbilityService还提供了下面的一些方法：''disableSelf()，禁用当前服务，也就是说关闭当服务''dispatchGesture(GestureDescription gesture, AccessibilityService.GestureResultCallback callback, Handler handler)，将手势发送到触摸屏''findFocus(int focus)：寻找到具有指定焦点类型的视图。''getRootInActiveWindow()：获取当前活动窗口中的根节点。''getServiceInfo()：获取当前服务的配置信息''getSystemService(String name)：获取系统服务''getWindows():获取屏幕上的窗口。''performGlobalAction(int action)：执行全局操作：比如返回，回到主页，打开最近等操作''setServiceInfo(AccessibilityServiceInfo info):设置当前服务的配置信息 (下面的配置AccessbilityService会介绍)''不太常用的：''getAccessibilityButtonController()：返回系统导航区域内辅助功能按钮的控制器。''getFingerprintGestureController()：获取指纹手势的控制器。''getMagnificationController():返回放大器控制器，可用于查询和修改显示放大率的状态。''getSoftKeyboardController():返回软键盘控制器，可用于查询和修改软键盘显示模式。''2.在AndroidManifest中注册该服务''AccessbilityService是一个服务，所以同样，他也要在AndroidManifest中注册：''<''service\n            android'':''name''=''""com.hahak.walle.accessibilitydame.StatusAccessibilityService""''android'':''label''=''""辅助服务测试""''android'':''permission''=''""android.permission.BIND_ACCESSIBILITY_SERVICE""''>''<''intent''-''filter''>''<''action android'':''name''=''""android.accessibilityservice.AccessibilityService""''/''>''<''/''intent''-''filter''>''<''/''service''>''android:permission：需要指定BIND_ACCESSIBILITY_SERVICE权限，这是4.0以上的系统要求的''intent-filter：这个name是固定不变的''3.配置AccessbilityService''接下来，就是配置服务参数，即设定AccessbilityService所能干的事。''配置方法有两种，一种是在代码中动态设置，一种是写配置文件。''方法1.写配置文件''首先在AndroidManifest中生命配置文件的位置''<''service''android:''name''=''""''com.hahack.walle.AutoCheckStatusAccessibilityService''""''android:''label''=''""''运营助手：自动艾特用户''""''android:''permission''=''""''android.permission.BIND_ACCESSIBILITY_SERVICE''""''>''<''intent-filter''>''<''action''android:''name''=''""''android.accessibilityservice.AccessibilityService''""''/>''</''intent-filter''>''<''meta-data''android:''name''=''""''android.accessibilityservice''""''android:''resource''=''""''@xml/allocation''""''/>''</''service''>''其次，在@xml/allocation文件中，声明下面的内容''<''accessibility-service''xmlns:''android''=''""''http://schemas.android.com/apk/res/android''""''android:''accessibilityEventTypes''=''""''typeAllMask''""''android:''description''=''""''demo''""''android:''accessibilityFeedbackType''=''""''feedbackSpoken''""''android:''canRetrieveWindowContent''=''""''true''""''android:''notificationTimeout''=''""''1000''""''/>''方法2:.在代码中动态添加''在自定义的AccessibilityService类中，可以通过在AccessibilityServiceInfo类重写onServiceConnected()，并通过 this.setServiceInfo来添加配置''@Override''public''void''onServiceConnected''('')''{''info''.''eventTypes''=''AccessibilityEvent''.''TYPE_VIEW_CLICKED''|''AccessibilityEvent''.''TYPE_VIEW_FOCUSED'';''info''.''packageNames''=''new''String''['']''{''""com.example.android.myFirstApp""'',''""com.example.android.mySecondApp""''}'';''info''.''feedbackType''=''AccessibilityServiceInfo''.''FEEDBACK_SPOKEN\n\n    info''.''notificationTimeout''=''100'';''this''.''setServiceInfo''(''info'')'';''}''下面说说配置内容的具体含义：''accessibilityEventTypes：此服务希望按照指定接收的事件类型(AccessibilityEvent)''常量''描述''typeViewClicked''点击事件''typeViewSelected''view被选择''typeViewScrolled''滑动事件''typeWindowContentChanged''窗口内容该表''typeAllMask''所有事件''accessibilityFeedbackType：此服务提供的反馈类型，比如说是语音播报还是真的震动''常量''描述''feedbackSpoken''语音反馈''feedbackHaptic''触觉（震动）反馈''feedbackAudible''音频反馈''feedbackVisual''视频反馈''feedbackGeneric''通用反馈''feedbackAllMask''以上都具有''canRetrieveWindowContent：表示该服务能否访问活动窗口中的内容。也就是如果你希望在服务中获取窗体内容，则需要设置其值为true''description：对该无障碍功能的描述。''notificationTimeout：接受事件的时间间隔，通常将其设置为100即可''packageNames：表示对该服务是用来监听哪个包的产生的事件，上面以微信的包名为例''canPerformGestures:表示是否允许进行手势分发''canRequestFilterKeyEvents：辅助服务希望能够请求过滤关键事件。''nonInteractiveUiTimeout：超时设置，未不包含交互式空间返回合适的值''四.使用''1.启动服务''辅助服务的启动必须通过用户设置来开启，所以我们要先提醒用户进行无障碍功能列表''Intent intent''=''new''Intent''(''Settings''.''ACTION_ACCESSIBILITY_SETTINGS'')'';''startActivity''(''intent'')'';''通过上面的代码就可以打开系统的无障碍功能列表''2.获取事件信息''当我们监听的目标应用界面或者界面等信息，会通过onAccessibilityEvent回调我们的事件，接着进行事件的处理。''@Override''public''void''onAccessibilityEvent''(''final''AccessibilityEvent event'')''{''String packageName''=''event''.''getPackageName''('')''.''toString''('')'';''if''(''!''packageName''.''equals''(''""com.tencent.mm""'')'')''{''return'';''}''int''eventType''=''event''.''getEventType''('')'';''switch''(''eventType'')''{''case''AccessibilityEvent''.''TYPE_WINDOW_STATE_CHANGED'':''处理''.''.''.''.''}''可以看出，当发生变化时，回调onAccessibilityEvent方法，并传入AccessibilityEvent类型。下面让我们看看AccessibilityEvent的含义。''先看看AccessibilityEvent提供的方法(源是指触发此方法的ui/时间)：''getAction()：获取触发此世界的已执行操作''getEventTime()：获取发送此事件的时间''getEventType()：获取事件类型。''getPackageName()：获取源的包名称''从AccessibilityRecord基础的方法''getMaxScrollY()：获取源上边缘的最大滚动偏移（以像素为单位）''getMaxScrollX()：获取源左边缘的最大滚动偏移量（以像素为单位）。''getClassName()：获取源的类名。''getText()：获取事件的文本，比如事件是有TextView发出的,此时获取的就是TextView的text属性。如果该事件源是树结构，那么此时获取的是这个树上所有具有text属性的值的集合''getToIndex()： 获取滚动时文本选择结束的索引或最后一个可见项的索引。''getItemCount()：如果事件源是树结构，将返回该树根节点下子节点的数量''更详细的可以参考官方文档：''AccessibilityEvent官方api介绍''关于事件类型getEventType()返回值：''TYPE_VIEW_LONG_CLICKED 长按事件''TYPE_VIEW_CONTEXT_CLICKED点击事件''TYPE_WINDOW_STATE_CHANGED 表示用户界面被更改。''TYPE_NOTIFICATION_STATE_CHANGED：通知栏的改变''TYPE_WINDOWS_CHANGED：表示系统窗口的时间变更''…还有很多，详情可以看看官方文档''3.处理事件C寻找控件''当我们接受到事件后，根据事件就可以处理对应的时间，比如说检测到弹窗，就可以转换为动作：点击弹窗。''处理事件总的来说，分为两个步骤。第一步，寻找该控件。第二部，模拟人的操作对各个控件进行操作(点击，长按，输入，读取)''寻找控件''寻找控件首先要找的它对象窗口内容对应的树，即AccessibilityWindowInfo(代表)和AccessibilityNodeInfo(代表具体的View)。注意，这个功能需要在xml资源配置中声明SERVICE_META_DATA。''针对寻找AccessibilityWindowInfo和AccessibilityNodeInfo，谷歌官方提供了下面的api''AccessibilityEvent#getSource(),返回值为发起当前事件的控件的AccessibilityNodeInfo''AccessibilityService#findFocus(int)，参数表示输入焦点，返回值为指定焦点对应的AccessibilityNodeInfo''AccessibilityService#getWindows()，返回值为当前所有可交互窗户的 AccessibilityWindowInfo列表（List）''AccessibilityService#getRootInActiveWindow()，返回值为当前活动的AccessibilityWindowInfo，如果用户没有触摸任何窗口，则活动窗口是具有输入焦点的窗口。''AccessibilityWindowInfo''：''AccessibilityWindowInfo表示可访问窗口的状态快照。屏幕内容包含一个或者多个窗口，其中一些窗口可以是其他窗口的后代，窗口是次序排序的。''AccessibilityWindowInfor提供的api简介：''getChild(int index) ，返回给定索引处的子窗口的AccessibilityWindowInfo''getChildCount()，返回代表子窗口的数量的int值''getId(),返回代表唯一的窗口id的int值''getParent()，返回代表父窗口的AccessibilityWindowInfo''getLayer()，返回代表窗口在z轴的图层的int值''getRoot()''，返回代表窗口层次中根节点的AccessibilityNodeInfo''…其余详见官网文档''AccessibilityNodeInfo''：''AccessibilityNodeInfo表示窗口内容的节点以及可以进行的操作。''AccessibilityNodeInfo内部类介绍：''AccessibilityAction，表示可以对AccessibilityNodeInfo提供的操作''CollectionInfo，表示当节点是集合时，包含集合信息的类。''CollectionItemInfo，表示当节点是集合子项，包含集合子项信息的类。''RangeInfo，表示当节点是范围，包含该范围包含信息的类。''AccessibilityNodeInfo提供的api简述''addAction(action: AccessibilityNodeInfo.AccessibilityAction)/(action: Int)，添加可在节点上执行的操作,有两个同名方法，参数不同''performAction(action: Int)，在节点上执行操作''addChild(child: View!)添加一个子项''findAccessibilityNodeInfosByText(text: String!)，按文字寻找对应的控件，并返回其 AccessibilityNodeInfo''findAccessibilityNodeInfosByViewId(viewId: String!)，根据View的id资源名称查找对应的View，返回AccessibilityNodeInfo''findFocus(focus: Int)，找到具有指定焦点类型的视图。返回AccessibilityNodeInfo''focusSearch(direction: Int)，搜索指定方向上可以获取输入焦点的最近视图。返回AccessibilityNodeInfo''getActionList()，获取可以在节点上执行的操作。''getHintText()，获取此节点的提示文本''getText()，获取此节点的文本''isClickable()，获取此节点是否可单击，还有其他对于的方法，判断节点是否可操作''…其余详见官网文档''4.处理事件C操作控件''在上面一小节里，我们通过addAction，可以给AccessibilityNodeInfo添加对于的动作，其参数是 AccessibilityNodeInfo的内部类AccessibilityAction。''AccessibilityAction''AccessibilityAction表示可以对AccessibilityNodeInfo。每个操作都有一个唯一的ID，这是必需的和可选的数据。''其有三类动作''标准操作 - 这些操作由平台中的标准UI小部件报告和处理。对于每个标准动作，在该类中定义了一个静态常量，例如ACTION_FOCUS。这些操作将有null标签。''自定义操作操作 - 这些是由自定义窗口小部件报告和处理的操作。即不属于UI工具包的那些。例如，应用程序可以定义用于清除用户历史的自定义操作。''覆盖标准操作 - 这些操作会覆盖标准操作以自定义它们。例如，应用可以向标准ACTION_CLICK操作添加标签，以向用户指示此操作清除浏览历史记录。''可提供的操作''ACTION_ACCESSIBILITY_FOCUS，为可访问性提供焦点的操作。''ACTION_CLEAR_ACCESSIBILITY_FOCUS，清除节点可访问性焦点的操作。''ACTION_CLICK，单击节点信息的操作。''ACTION_LONG_CLICK,长按''ACTION_FOCUS，为输入焦点提供节点''ACTION_COPY，将当前选择复制到剪贴板的操作。''ACTION_CUT，剪切''ACTION_PAGE_DOWN，移动到下一页，以及移动到下，左，右页面''ACTION_PASTE，粘贴剪切板内容''ACTION_SCROLL_BACKWARD/ACTION_SCROLL_FORWARD ,下滑/上滑''ACTION_SET_TEXT，设置节点文本''…其余详见官网文档''五.综合应用''1.获得View对应的id''打开toolsC>AndroidC>Android Device Monitor''选择设备，并点击图中坐标''选择对应的控件进行点击查看''2.AccessibilityService的手势控制''在Android7.0之后，AccessibilityService又增加了一个新的方法dispatchGesture。可以将手势发送到触摸屏上。但是要使用这个功能必须在配置文件中声明，canPerformGestures = “true”''api接口:''public''final''boolean''dispatchGesture''(''GestureDescription gesture'',''AccessibilityService''.''GestureResultCallback callback'',''Handler handler'')''参数:''GestureDescription：要分派的手势''AccessibilityService.GestureResultCallback:完成后的回调''Handler；处理回调程序的线程，如果传入null,则为主线程''使用示例''Path path''=''new''Path''('')'';''path''.''moveTo''(''0'',''400'')'';''path''.''lineTo''(''400'',''400'')'';''final''GestureDescription''.''StrokeDescription sd'';''sd''=''new''GestureDescription''.''StrokeDescription''(''path'',''100'',''50'')'';''//先横滑''boolean''flag''=''this''.''dispatchGesture''(''new''GestureDescription''.''Builder''('')''.''addStroke''(''sd'')''.''build''('')'',''new''AccessibilityService''.''GestureResultCallback''('')''{''@Override''public''void''onCompleted''(''GestureDescription gestureDescription'')''{''super''.''onCompleted''(''gestureDescription'')'';''Log''.''d''(''""22222""'',''""onCompleted:横滑 ""'')'';''Path path2''=''new''Path''('')'';''path2''.''moveTo''(''600'',''600'')'';''path2''.''lineTo''(''600'',''800'')'';''final''GestureDescription''.''StrokeDescription sd2''=''new''GestureDescription''.''StrokeDescription''(''path2'',''1000'',''500'')'';''//滑完后再过1秒竖滑''BaseAccessibilityService''.''this''.''dispatchGesture''(''new''GestureDescription''.''Builder''('')''.''addStroke''(''sd2'')''/*.addStroke(sd2)*/''.''build''('')'',''null'',''null'')'';''}''@Override''public''void''onCancelled''(''GestureDescription gestureDescription'')''{''Log''.''d''(''""22222""'',''""onCancelled""'')'';''super''.''onCancelled''(''gestureDescription'')'';''}''}'',''null'')'';''上图的示例为左滑和下滑，如果要实现点击事件，则可以只传入一个点Path。即''Path path''=''new''Path''('')'';''path''.''moveTo''(''0'',''400'')'';''sd''=''new''GestureDescription''.''StrokeDescription''(''path'',''100'',''50'')'';''3.AccessibilityService的基础类''下面是对AccessibilityService提供的各种方法的封装''public''class''BaseAccessibilityService''extends''AccessibilityService''{''private''AccessibilityManager mAccessibilityManager'';''private''Context mContext'';''private''static''BaseAccessibilityService mInstance'';''public''void''init''(''Context context'')''{''mContext''=''context''.''getApplicationContext''('')'';''mAccessibilityManager''=''(''AccessibilityManager'')''mContext''.''getSystemService''(''Context''.''ACCESSIBILITY_SERVICE'')'';''}''public''static''BaseAccessibilityService''getInstance''('')''{''if''(''mInstance''==''null'')''{''mInstance''=''new''BaseAccessibilityService''('')'';''}''return''mInstance'';''}''/**\n     * Check当前辅助服务是否启用\n     *\n     * @param serviceName serviceName\n     * @return 是否启用\n     */''private''boolean''checkAccessibilityEnabled''(''String serviceName'')''{''List''<''AccessibilityServiceInfo''>''accessibilityServices''=''mAccessibilityManager''.''getEnabledAccessibilityServiceList''(''AccessibilityServiceInfo''.''FEEDBACK_GENERIC'')'';''for''(''AccessibilityServiceInfo info'':''accessibilityServices'')''{''if''(''info''.''getId''('')''.''equals''(''serviceName'')'')''{''return''true'';''}''}''return''false'';''}''/**\n     * 前往开启辅助服务界面\n     */''public''void''goAccess''('')''{''Intent intent''=''new''Intent''(''Settings''.''ACTION_ACCESSIBILITY_SETTINGS'')'';''intent''.''setFlags''(''Intent''.''FLAG_ACTIVITY_NEW_TASK'')'';''mContext''.''startActivity''(''intent'')'';''}''/**\n     * 模拟点击事件\n     *\n     * @param nodeInfo nodeInfo\n     */''public''void''performViewClick''(''AccessibilityNodeInfo nodeInfo'')''{''if''(''nodeInfo''==''null'')''{''return'';''}''while''(''nodeInfo''!=''null'')''{''if''(''nodeInfo''.''isClickable''('')'')''{''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_CLICK'')'';''break'';''}''nodeInfo''=''nodeInfo''.''getParent''('')'';''}''}''/**\n     * 模拟返回操作\n     */''public''void''performBackClick''('')''{''try''{''Thread''.''sleep''(''500'')'';''}''catch''(''InterruptedException''e'')''{''e''.''printStackTrace''('')'';''}''performGlobalAction''(''GLOBAL_ACTION_BACK'')'';''}''/**\n     * 模拟下滑操作\n     */''public''void''performScrollBackward''('')''{''try''{''Thread''.''sleep''(''500'')'';''}''catch''(''InterruptedException''e'')''{''e''.''printStackTrace''('')'';''}''performGlobalAction''(''AccessibilityNodeInfo''.''ACTION_SCROLL_BACKWARD'')'';''}''/**\n     * 模拟上滑操作\n     */''@RequiresApi''(''api''=''Build''.''VERSION_CODES''.''N'')''public''void''performScrollForward''('')''{''try''{''Thread''.''sleep''(''500'')'';''}''catch''(''InterruptedException''e'')''{''e''.''printStackTrace''('')'';''}''performGlobalAction''(''AccessibilityNodeInfo''.''ACTION_SCROLL_FORWARD'')'';''}''/**\n     * 查找对应文本的View\n     *\n     * @param text text\n     * @return View\n     */''public''AccessibilityNodeInfo''findViewByText''(''String text'')''{''return''findViewByText''(''text'',''false'')'';''}''/**\n     * 查找对应文本的View\n     *\n     * @param text      text\n     * @param clickable 该View是否可以点击\n     * @return View\n     */''public''AccessibilityNodeInfo''findViewByText''(''String text'',''boolean''clickable'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return''null'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByText''(''text'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''if''(''nodeInfo''!=''null''&&''(''nodeInfo''.''isClickable''('')''==''clickable'')'')''{''return''nodeInfo'';''}''}''}''return''null'';''}''/**\n     * 查找对应ID的View\n     *\n     * @param id id\n     * @return View\n     */''@TargetApi''(''Build''.''VERSION_CODES''.''JELLY_BEAN_MR2'')''public''AccessibilityNodeInfo''findViewByID''(''String id'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return''null'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByViewId''(''id'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''Log''.''d''(''""dd""'',''""findViewByID: ""''+''nodeInfoList''.''size''('')'')'';''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''Log''.''d''(''""dd""'',''""findViewByID: ""''+''nodeInfo''.''toString''('')'')'';''if''(''nodeInfo''!=''null'')''{''return''nodeInfo'';''}''}''}''return''null'';''}''public''void''clickTextViewByText''(''String text'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByText''(''text'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''if''(''nodeInfo''!=''null'')''{''performViewClick''(''nodeInfo'')'';''break'';''}''}''}''}''@TargetApi''(''Build''.''VERSION_CODES''.''JELLY_BEAN_MR2'')''public''void''clickTextViewByID''(''String id'')''{''AccessibilityNodeInfo accessibilityNodeInfo''=''getRootInActiveWindow''('')'';''if''(''accessibilityNodeInfo''==''null'')''{''return'';''}''List''<''AccessibilityNodeInfo''>''nodeInfoList''=''accessibilityNodeInfo''.''findAccessibilityNodeInfosByViewId''(''id'')'';''if''(''nodeInfoList''!=''null''&&''!''nodeInfoList''.''isEmpty''('')'')''{''for''(''AccessibilityNodeInfo nodeInfo'':''nodeInfoList'')''{''if''(''nodeInfo''!=''null'')''{''performViewClick''(''nodeInfo'')'';''break'';''}''}''}''}''/**\n     * 模拟输入\n     *\n     * @param nodeInfo nodeInfo\n     * @param text     text\n     */''public''void''inputText''(''AccessibilityNodeInfo nodeInfo'',''String text'')''{''if''(''Build''.''VERSION''.''SDK_INT''>=''Build''.''VERSION_CODES''.''LOLLIPOP'')''{''Bundle arguments''=''new''Bundle''('')'';''arguments''.''putCharSequence''(''AccessibilityNodeInfo''.''ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE'',''text'')'';''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_SET_TEXT'',''arguments'')'';''}''else''if''(''Build''.''VERSION''.''SDK_INT''>=''Build''.''VERSION_CODES''.''JELLY_BEAN_MR2'')''{''ClipboardManager clipboard''=''(''ClipboardManager'')''getSystemService''(''Context''.''CLIPBOARD_SERVICE'')'';''ClipData clip''=''ClipData''.''newPlainText''(''""label""'',''text'')'';''clipboard''.''setPrimaryClip''(''clip'')'';''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_FOCUS'')'';''nodeInfo''.''performAction''(''AccessibilityNodeInfo''.''ACTION_PASTE'')'';''}''}''@Override''public''void''onAccessibilityEvent''(''AccessibilityEvent event'')''{''Log''.''d''(''""dd""'',''""onAccessibilityEvent: ""''+''event''.''toString''('')'')'';''}''@Override''public''void''onInterrupt''('')''{''}''@Override''protected''void''onServiceConnected''('')''{''super''.''onServiceConnected''('')'';''Log''.''d''(''""llll""'',''""onServiceConnected: ""'')'';''}''}''4.实际应用''学习了大部分的AccessibilityService相关知识。就可以灵活运用这些内容进行组装。''比如说：''微信红包外挂''支付宝自动收能量''微信自动发消息''朋友圈自动点赞''…''六.参考资料''官方api文档''官网辅助服务介绍''妙用AccessibilityService黑科技实现微信自动加好友拉人进群聊'"
CSDN,https://blog.csdn.net/blogdevteam/article/details/103478461,博客帮助文档,CSDN官方博客,帮助文档,,2019-12-11 14:46:59,"'目录''博客积分规则''博客等级''C币规则（试运营）''博客VIP文章说明''博客专家''如何成为博客专家？''企业博客''如何开通企业博客''博客勋章''分类专栏''博客搬家''自定义百度统计''CSDN博客用户准则''总则：''博客注册''博客行为规则''被投诉侵权用户处理规则''附则''博客评论活跃等级规则（试运营）''Markdown帮助''付费专栏开通规则''博客积分规则''博客积分是CSDN对用户努力的认可和奖励，也是衡量博客水平的重要标准。博客等级也将由博客积分唯一决定。积分规则具体如下：''1、每发布一篇原创或者翻译文章：可获得10分；''2、每发布一篇转载文章：可获得2分；''3、博主的文章每被评论一次：可获得1分；''4、每发表一次评论：可获得1分（自己给自己评论、博主回复评论不获得积分）；''5、博文阅读次数每超过100次：可获得1分，阅读加分最高加到100分，即文章点击上万次截止；''6、文章被管理员或博主本人删除，相应减去博主基于该篇博文所获得的分数；''7、评论被管理员或博主删除，相应减去发评论者和博主基于该评论各自获得的分数（博主应减积分不会动态实时去掉，是每周固定时间清理一次）；''8、另外会开设相应的抄袭举报功能，一旦举报证实某篇原创文章抄袭，将扣除博主该篇文章相应的得分。''博客等级''图标''等级''所需积分''L1''0''L2''100''L3''400''L4''800''L5''1600''L6''4500''L7''9000''L8''25000''L9''50000''L10''100000''L11''200000''L12''300000''L13''500000''L14''800000''L15''1000000''C币规则（试运营）''什么是C币''查看详细C币规则''博客VIP文章说明''博主专享福利,发付费文章后可获得返利。''VIP文章即读者购买VIP付费后才可解锁阅读的文章，拥有VIP文章发表权限的作者可以发表VIP文章。''发VIP文章,根据文章购买转化数据返利(详见收益中心:''https://order.csdn.net/myorder/revenue''）''如何取消VIP可读：进入该篇文章的编辑页面，在“发布形式”模块取消选择“VIP可见”重新发布''博客专家''“博客专家”是CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定。''成为博客专家后会得到什么：''用户头像上显示“专家”勋章；''发布博客时可以直接引用CSDN站外的图片；''有机会免费参加CSDN举办的各种会议；''有机会成为CSDN学院讲师、CSDN博乐、CSDN问答导师等；''有更多演讲机会，CSDN会推荐给厂商或者各种IT技术大会作为演讲嘉宾；''享有月度原创奖励，C币、图书或定制礼品；''享有自定义模块、自定义域名、全站免广告等权益；''文章获得更多的推荐机会：博客专家所发的文章都会进入文章预选库，我们有专门的编辑负责从中筛选优质内容，并推荐到CSDN首页或其他内容频道。''注意情况：''所有博客专家（包括荣誉专家）均为实名制；''CSDN博客专家在三个月内如果没有发布任何原创或翻译博文，其博客专家身份将自动取消，转为博客频道荣誉专家，不能继续享有博客专家的福利；''CSDN博客专家不是CSDN博客的全职或兼职管理人员，不具备CSDN博客的管理权力，其观点及行为仅代表个人，不代表CSDN官方立场；''CSDN博客专家如有违反CSDN网站规则的行为，如大量发布广告或软文，对CSDN网站造成不良影响等，将永久取消其CSDN博客专家身份；希望恢复博客专家身份可重新申请，''点击这里申请博客专家''。''如何成为博客专家？''申请CSDN博客专家应具备的条件：''在CSDN坚持写作三年及以上；''原创技术文章总数超过100篇，并且最近6个月内有一定的活跃度；''博客文章总浏览量超过20万次以上，同时参考点赞、评论、收藏等交互数据；''原创文章占比80%以上，且文章内容有一定深度；''企业、团队等非个人开设的博客，需要原创技术文章总数超过150篇，并且最近一个月内发布了新的原创技术文章，博文总浏览量超30万次才能申请博客专家；''其他情况：''在CSDN学院成功发布过课程的博主可适当放宽要求；''如果已经在某IT领域具有较大影响力，但是尚没有达到上述申请条件的用户，可以通过现有博客专家或者CSDN编辑部的推荐，暂时成为“特约专家”，待达到上述条件之后，再转为正式的博客专家（申请用户自成为“特约专家”后六个月内如仍未达到CSDN博客专家应具备的条件，则“特约专家”身份取消）。''CSDN已开通博客专家在线申请功能，''点击这里申请博客专家''。''企业博客''CSDN企业博客旨在利用CSDN站内流量、内容、用户等资源，为技术型企业提供营销推广平台''企业博客免费版主要功能如下：''1、优质企业博文可提高推荐权重；''2、支持设置自定义主题图，方便更换企业品牌形象及广告图；''3、企业博客内无联盟广告展示；''4、企业博客有专属身份标识；''5、企业博客内的相关推荐内容为该企业自己的博文；''6、支持设置自定义背景色，支持添加自定义链接导航（目前最多可添加五个）；''7、支持百度关键词查询；''8、搜索专区。''如何开通企业博客''企业博客已经开通在线申请功能，''点击这里开通企业博客''CSDN管理员在收到您的申请后，会在2个工作日内开通服务。如有问题可以直接发信至tobblog@csdn.net咨询。''博客勋章''博客专家''CSDN给予质量较高、影响力较大的IT类博客的荣誉称号，代表了CSDN官方对其博客的肯定。成为博客专家后会得到我们一系列的服务，如在头像上加象征荣誉的专家勋章、有专人对接提供服务、文章获得更多的推荐机会、不定时获得CSDN的礼品、优先获得CSDN举办的各种会议的的门票等。''博客之星''授予在“CSDN年度博客之星评选”中获得“博客之星”称号的用户。为了鼓励专业、乐于分享的广大CSDN博客用户。每年12月的CSDN博客之星评选中，综合专家评审和大众投票的结果，评选出“CSDN年度博客之星”。''1024勋章''#1024程序员节#活动勋章，当日发布原创博客即可获得''1024超级勋章''授予原创文章总数达到1024篇的博主，感谢你对CSDN社区的贡献，CSDN与你一起成长。''勤写标兵Lv1''授予每个自然周发布1篇到3篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv2''授予每个自然周发布4篇到6篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv3''授予每个自然周发布7篇到8篇原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''勤写标兵Lv4''授予每个自然周发布9篇以上（包括9篇）原创IT博文的用户。本勋章将于次周周三上午根据用户上周的博文发布情况由系统自动颁发。''分类专栏''分类专栏是把相同标签属性的技术博文聚集起来，集中展示，系统全面，更具目标性。CSDN鼓励每位博主撰写专属自己的专栏博文，构建自己的知识体系。''发布分类专栏建议：''1. 每个专栏至少发布10篇原创技术博文。''2. 博文紧扣专栏主题，技术定位清晰，内容扎实详尽。''CSDN博客频道编辑定期会把精华分类专栏荐给相应的受众群体。''博客搬家''CSDN是IT技术网站，欢迎大家发布原创或翻译IT技术类博客，非IT技术类博客将不提供搬家服务。博主可以''点击这里''申请博客搬家。''CSDN推出博客搬家功能，目前支持以下站点的博客搬迁：''博客园，微信公众号，简书，51CTO.com,新浪，开源中国，chinaUnix,个人博客，掘金，GitHub,知乎，segmentfault''。''温馨提示：''原创技术文章不能少于10篇方可申请。''原博客数据不会丢失，仍然保留。''如果检测到恶意导入，您的博客使用将会受到影响。''审核通过的搬家申请，会持续与搬家源进行内容同步（个人博客和github同步历史文章）。''审核时间一般为1个工作日，审核结果将通过站内信等方式告知。''同一个站点只允许进行1次搬家申请，如申请失败则需要重新申请。''对博客搬家有任何问题或建议请向博客客服邮箱发邮件咨询：webmaster@csdn.net。''声明：CSDN用户要完成博客搬家需要承诺搬迁的博客为用户本人博客，如搬迁非用户本人博客所产生的后果由用户本人承担。''自定义百度统计''申请方式''百度统计账号查询方式如下图所示''1）登录百度统计账号链接：''https://tongji.baidu.com/sc-web/home/site/getjs''2）路径是：管理/代码管理/代码获取''CSDN博客用户准则''总则：''第1条 CSDN博客隶属于CSDN（包括CSDN网站与相应客户端、自媒体平台、主运营网站等），是为中国的软件开发者、IT从业者及其他人员提供以交流IT技术为主的网络社区。''第2条 为保障CSDN博客健康发展，维护用户正当权益，规范信息发布行为，依据国家有关法律、法规、政策及CSDN相关规定，制定本博客用户准则（以下称“本准则”）。''第3条 CSDN经营者（即北京创新乐知网络技术有限公司及其他相关联的公司）无法对用户传播内容的权属、合法性、真实性、科学性、完整性等问题进行实质审查，博客用户须对自己发布的内容独立承担责任，CSDN经营者不承担因此产生的任何法律责任。''第4条 为保障CSDN博客的专业性与集成性，博客用户的交流不得涉及任何政治话题，CSDN博客用户须严格按照本准则的规定行使权利和履行义务。''博客注册''第1条 拟注册用户在CSDN博客进行注册时，需要按照提示填写详尽的用户信息（包括但不限于姓名或名称、身份证号码、邮箱、联系方式等），并对提供信息的真实性负责。在用户信息发生变动时，用户有责任及时更新、修改信息。如果博客用户提供的信息资料不准确，CSDN经营者保留终止用户使用CSDN博客提供的相关网络服务的权利。''第2条 CSDN博客用户因提供用户信息不真实、不准确等而发生纠纷或需要帮助时，因不能确认用户身份及其帐号的使用权利，无法向用户提供相应的帮助所带来的一切后果由用户自己承担。''第3条 CSDN经营者尊重用户隐私，未经用户合法授权，不会公开或透露其注册资料。''第4条 用户注册并激活成功后，便成为CSDN博客的正式用户，正式博客用户拥有CSDN博客规定用户所应享有的一切权限。用户将获得一个用户名和密码，用户对自己的用户名、密码及帐号安全性负全部责任。用户同意，若发现任何非法使用帐号、密码或存在安全漏洞等其它有损用户利益的情况，应立即通知CSDN经营者。每个用户都应对以其用户名进行的所有活动和事件负全部责任。''博客行为规则''第1条 CSDN博客用户享有言论自由的权利，但不得违反法律法规及政策规定，不得违反诚实信用原则及公序良俗，不得损害国家、CSDN经营者及第三方权利及利益，不得违反CSDN用户协议及相关规则。严禁发表含有下列内容的信息：''1.违反宪法确定的基本原则的；''2.危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的；''3.损害国家荣誉和利益的；''4.煽动民族仇恨、民族歧视，破坏民族团结的；''5.破坏国家宗教政策，宣扬邪教和封建迷信的；''6.散布谣言，扰乱社会秩序，破坏社会稳定的；''7.散布淫秽、色情、赌博、暴力、恐怖或者教唆犯罪的；''8.侮辱或者诽谤他人，侵害他人合法权益的；''9.煽动非法集会、结社、游行、示威、聚众扰乱社会秩序的；''10.以非法民间组织名义活动的；''11.可能教唆他人犯罪的；''12.可能损害CSDN经营者名誉或商誉等权益的；''13.其他违反中华人民共和国法律、法规、政策，违反诚实信用及公序良俗，或CSDN经营者认为不当及不宜传播的信息。 CSDN博客用户违反上述规定的，CSDN经营者有权在不通知用户的情况下，根据其独立判断，采取删除已发表言论，暂停账户使用，直至取消用户资格等措施。''第2条 CSDN博客用户发表的文章、言论或其他信息仅代表其自身观点与立场，CSDN经营者不对用户发表内容的准确性、合法性、完整性负责。博客用户须承担一切因自己的行为而直接或间接导致的民事、行政或刑事法律责任。在任何情况下，CSDN经营者不承担因用户发表内容而引起的任何损失、损害的法律责任。''第3条 CSDN博客用户不得发布非IT技术内容。''第4条 未经CSDN经营者同意，禁止在博客发布与CSDN提供服务无关的广告。博客管理规则''第1条 CSDN博客的管理权限由博客管理员享有，博客管理员由CSDN经营者正式全职员工担任，并由其按照相关法律、法规、政策以及CSDN规则行使本博客全部站务管理职责和权利，管理员代表本博客官方立场，除管理员之外的任何用户及网友言论或行为，由相关人员自行承担，均与本博客无关。''第2条 用户恶意破坏CSDN博客版块正常秩序（包含但不限于恶意投票、刷流量、刷评论、利用自定义栏目传播病毒、垃圾广告、非法信息等）的，CSDN经营者有权视情节轻重给予警告、删帖、暂停账号使用、注销帐号等处理，并依法追究民事责任及其他法律责任。''被投诉侵权用户处理规则''第一次：封杀，解封时要求文章改为转载并注明出处''第二次：封杀一个月，给予严重警告，解封时要求文章改为转载并注明出处''第三次：不予解封''附则''第1条 CSDN提示博客用户，在用户与通过博客相识的其他用户进行交往时，应遵循谨慎原则。对于博客用户之间相识、交往所发生或可能发生的任何心理、身体上的伤害和经济上的损失与纠纷，由相关用户自行承担一切法律责任，CSDN经营者不承担任何法律责任。''第2条 本准则如存在与国家法律、法规或司法解释、政策等有冲突的条款，以届时有效的国家法律、法规或司法解释、政策等为准。本准则的其余条款仍然有效并具有约束力。''第3条 CSDN经营者有权对本准则进行修改，相关条款修改后，CSDN经营者将在相关页面公布修改的内容，修改后的条款一经公布即有效的代替原条款。用户如不同意相关条款的修改，可立即停止访问或使用CSDN博客或取消已经获得的服务；如用户选择在本准则修改后继续访问或使用CSDN博客，则视为用户已接受相关条款的修改。''第4条 用户接受本准则的内容，并不能完全涵盖用户使用CSDN博客所产生的权利和义务，CSDN经营者公布的其他声明、规则等均视为本准则之补充条款，为本准则不可分割的组成部分，与本准则具有同等法律效力。''第5条 本准则自发布之日起生效。''第6条 本准则最终解释权归北京创新乐知网络技术有限公司所有。''博客评论活跃等级规则（试运营）''评论活跃等级是CSDN对用户在博客评论区活跃程度的辨别标准，旨在鼓励读者和博主互动交流，提高用户活跃度。活跃等级规则具体如下（该规则适用于所有用户）：''1、所有用户初始评论次数均为零''2、活跃等级用评论次数衡量，评论次数越多，等级越高''3、超过10天没有进行任何评论，等级称谓变成“潜水”，初始评论次数清零''4、发布评论且审核通过后计算当前的有效评论数，根据当前的有效评论数展示不同的“评论等级称谓”''5、该规则从2020年4月23日起开始执行，在此之前进行的评论不予计算，仅计算该日期以后进行的有效评论''以下是评论次数对应的评论等级称谓''评论等级称谓''评论次数区间''潜水''0次''码哥''1-3次''码农''4-7次''码工''8-15次''码皇''16-31次''码神''32-63次''爱码士''64次以上''Markdown帮助''# 欢迎使用Markdown编辑器写博客''---------------------------''撤销：Ctrl/Command + Z''重做：Ctrl/Command + Y''加粗：Ctrl/Command + B''斜体：Ctrl/Command + I''标题：Ctrl/Command + Shift + H''无序列表：Ctrl/Command + Shift + U''有序列表：Ctrl/Command + Shift + O''检查列表：Ctrl/Command + Shift + C''插入代码：Ctrl/Command + Shift + K''插入链接：Ctrl/Command + Shift + L''插入图片：Ctrl/Command + Shift + G''标题''---------------------------''# 1级标题''## 2级标题''### 3级标题''#### 四级标题''##### 五级标题''###### 陆级标题''文本样式''---------------------------''*强调文本* _强调文本_''**加粗文本** __加粗文本__''==标记文本==''~~删除文本~~''> 引用文本''H~2~O is是液体。''2^10^ 运算结果是 1024。''列表''---------------------------''- 项目''* 项目''+ 项目''1. 项目1''2. 项目2''3. 项目3''- [ ] 计划任务''- [x] 完成任务''链接''---------------------------''链接: [link](https://mp.csdn.net).''图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg)''带尺寸的图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg =30x30)''代码片''---------------------------''下面展示一些 `内联代码片`。''```''// A code block'""var foo = 'bar';""'```''```javascript''// An highlighted block'""var foo = 'bar';""'```''1. 代码片必须手动声明代码语言类型''2. 目前支持代码类型: `markup`、`html`、`svg`、`xml`、`c`、`clike`、`cpp`、`csharp`、`java`、`vbnet`、`go`、`ruby/rb`、`python/py`、`php`、`sql`、`perl`、`objectivec`、`swift`、`javascript/js`、`css`、`handlebars`、`bash`、`kotlin`''3. 代码片主题''默认主题为：Atom One Dark''可以前往 [**写作中心/博客设置**](https://mp.csdn.net/configure) 在**代码片样式**项进行更改''表格''---------------------------''项目 | Value''-------- | -----''电脑 | $1600''手机 | $12''导管 | $1''| Column 1 | Column 2 |''|:--------:| -------------:|''| centered 文本居中 | right-aligned 文本居右 |''自定义列表''---------------------------''Markdown'': Text-to-HTML conversion tool''Authors'': John'': Luke''注脚''---------------------------''一个具有注脚的文本。[^1]''[^1]: 注脚的解释''注释''---------------------------''Markdown将文本转换为 HTML。''*[HTML]: 超文本标记语言''KaTex 数学公式''---------------------------''Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall''n\\in\\mathbb N$ 是通过 Euler integral''$$''\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.''$$''新的数学公式使用了KaTex，其语法与 LaTex基本一致，但也有一些不同的地方，具体请参考KaTex官方使用文档： [https://katex.org/docs/supported.html](https://katex.org/docs/supported.html)''插入甘特图''---------------------------''```mermaid''gantt''dateFormat YYYY-MM-DD''title Adding GANTT diagram functionality to mermaid''section 现有任务''已完成 :done, des1, 2014-01-06,2014-01-08''进行中 :active, des2, 2014-01-09, 3d''计划中 : des3, after des2, 5d''```''插入UML图''------------''```mermaid''sequenceDiagram''张三 ->> 李四: 你好！李四, 最近怎么样?''李四-->>王五: 你最近怎么样，王五？''李四--x 张三: 我很好，谢谢!''李四-x 王五: 我很好，谢谢!''Note right of 王五: 李四想了很长时间, 文字太长了''不适合放在一行.''李四-->>张三: 打量着王五...''张三->>王五: 很好... 王五, 你怎么样?''```''插入Mermaid流程图''--------''```mermaid''graph LR''A[长方形] -- 链接 --> B((圆))''A --> C(圆角长方形)''B --> D{菱形}''C --> D''```''插入Flowchart流程图''-------''```mermaid''flowchat''st=>start: 开始''e=>end: 结束''op=>operation: 我的操作''cond=>condition: 确认？''st->op->cond''cond(yes)->e''cond(no)->op''```''付费专栏开通规则''付费专栏是博主根据自己想变现的意愿而选择的一项可变现的产品，开通付费专栏事项须知：''付费专栏开通提交前，请认真阅读《CSDN付费专栏写作协议》，知晓双方的权利与义务''专栏文章需为原创文章且不少于15篇，每篇文章字数不得少于5000字（包括代码片段内字符数量）''专栏申请需提交审核，审核时间1-2个工作日''专栏定价，博主可以按照从系统已设定好的价格里选择定价''确保专栏内容无违规、违法、广告等不当内容''专栏一旦设置为收费，审核通过以后，无法取消，请谨慎操作'"
